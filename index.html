
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<meta name="screen-orientation" content="portrait">
<title>マジカル・ヘクサー(Magical Hexa)</title>

<!--
=======================================================================
 マジカル・ヘクサー (Magical Hexa) - ゲーム仕様書
 ハンゲームの「ヘクサー」を再現した落ち物パズル対戦ゲーム
=======================================================================

【基本ルール】
・フィールド: 縦15 × 横8マス
・落下ブロック: 縦に3つ積まれたブロックが上部から落下
・マッチ条件: 縦・横・斜めに3つ以上同じ色が揃うと消去（連鎖あり）
・ゲームオーバー条件: 左から5列目（インデックス4）が最上段まで積み上がると終了
  ※ただし、排出口が埋まってもマッチがあれば消去処理を優先
・Nextブロック表示あり（文字なし、大きめ、隙間なく表示）
・ブロック排出時、一番下のブロックがフィールド外にはみ出た状態で開始
・接地時の操作猶予（Lock Delay）あり
・コンボ継続猶予: 1秒（手動配置時はリセット、アイテムR使用時は継続）

【操作方法】
・十字キー（丸ボタンタイプ、画面下部中央配置）
  - ←→: 左右移動（長押しで連続移動対応、判定エリア外側拡張済み）
  - ↑: ブロックの順序入れ替え（ローテーション）
  - ↓: ハードドロップ（一気に最下段まで落下）
・ITEMボタン: 先頭のアイテムを使用
・CHANGEボタン: 所持アイテムの順序を入れ替え（先頭を最後尾へ）
・一時停止ボタン: 画面左上（一時停止中は操作ボタン非表示）
・カウントダウン終了後に操作ボタンを表示

【アイテムシステム】
・ストック上限: 最大7個
・初期所持: アイテム「P」を1つ
・獲得タイミング: コンボ継続猶予終了後（重複獲得防止）
・獲得確率:
  - 2 Combo: アイテム「R」 (15%)
  - 3 Combo: アイテム「R」 (20%)
  - 4 Combo: アイテム「R」 (30%) またはアイテム「S」(10%) 確定
  - 5 Combo: アイテム「P」 (50%) またはアイテム「S」(20%) 確定
  - 6 Combo以上: アイテム「C」(30%) / 「P」(40%) / 「S」(30%) 確定
・アイテム効果:
  - 【P】プリズム: 次の出現ブロックが「Pブロック」に。落下地点のブロックと同色を全消し（罰マーク解除）
    ※操作中は排出口が埋まってもゲームオーバーにならない
  - 【R】リバース: 自フィールドを上下反転（逆転のチャンス）
  - 【C】クリア: 自フィールドの全ブロックを消去（緊急回避）
  - 【S】スワップ: 相手とフィールド(1〜11段目)を入替。12段目以上は消滅。コンボ状態も奪取

【対戦・攻撃システム】
・モード: Player vs CPU（コンピュータ対戦）
・攻撃ゲージ: 消したブロック数 × コンボ倍率 で加算
  - 1連鎖:1.0倍, 2連鎖:1.5倍, 3連鎖:2.0倍, ... (0.5ずつ増加)
・お邪魔ブロック: ゲージ15ごとに相手フィールドを1段底上げ
  - 罰マーク付与率: 50%
  - 罰マーク付きは消去不可、隣接ブロック消去で解除（封印解除）
・攻撃演出: データストリームエフェクト

【CPU・難易度】
・レベル: 0〜100で調整可能
・AI思考: 高速思考、連鎖優先、先読み深度向上済み
・アイテム使用: ピンチ時・攻撃チャンス時に使用
  ※5列目が高くても他が空いていればアイテム温存、消去優先
・隠しモード「般若」: レベル100でアイコンを10回タップで解放
  - レベル無限大、背景赤化
  - ブロック移動速度2倍（超高速化）
  - 専用BGM（音量増加済み）
  - ミサイル攻撃（1〜7箇所ランダム、警告音あり）
  - ブロック消滅演出: 原子レベル分解（神の力）
  - フェーズ移行演出中は両者操作不能

【般若モード・フェーズ詳細】
・フェーズ1: ミサイル2発 (100%罰付与)
・フェーズ2 (初回復活後):
  - レーザー攻撃(20秒毎, 3発: 2発罰付与+1発消去, 列重複なし)
  - アイテムP付与
・フェーズ3 (2回目復活後):
  - ミサイル5〜10発 (80%罰, 20%消去)
  - アイテムC付与
  - 画面全体爆発演出(揺れなし、軽量化済み)
  - 移行時にプレイヤー全ブロック罰付与

【ゲームモード】
・AI対戦モード: CPUと対戦
・トレーニングモード:
  - AI監視アニメーションと統計情報表示（フィールドと重ならないよう配置）
  - AIアシスト機能（目標コンボ数達成前は作成アシスト、達成後は特定アシスト）
  - アシスト設定: OFF / 2〜8コンボで切り替え可能
  - 3コンボ以上のみ表示、控えめなデザイン
  - プレイヤーの操作ブロックと並び順一致時のみ強調表示
  - アイテムS出現禁止（代わりにPまたはC）
・フレンド対戦モード: パスワード「Hexapo」で解放

【デザイン・演出】
・テーマ: サイバーパンク、AI、デジタル、ネオン、グリッチ
・ブロック: 5種類、テクスチャ画像使用、隙間なく表示
・ブロック消滅演出: ビットパーティクル（0/1）散乱、軽量化済み
・落下アニメーション: 滑らか（ゆっくり）
・着地時: バウンド演出
・2 Combo以上: 「SYNC!!」表示とデジタル花火演出
・落下位置ガイド（ゴースト）表示
・コンボ数に応じて消去演出速度を段階的に遅延（2コンボ毎に30ms、最大90ms）
・攻撃ゲージ: 発光するネオン調デザイン
・罰マーク: 透明度調整済み、マーク細め
・画面遷移: AIコアへの吸い込み・ワープ演出
・カウントダウン: Neural sync 0%→100% 動的変化

【リザルト画面】
・AIによるプレイ分析機能（ランク、パラメータ評価、コメント）
・メッセージ: AI風表現（SYSTEM FAILURE、TARGET ELIMINATED等）
・リスタートボタン: 結果全表示後に表示・押下可能
・演出スキップ: 表示開始1秒後以降に画面タップで可能

【チュートリアル】
・スタート画面にチュートリアルボタン配置
・アイテム表記は実際のブロック画像アイコンで表示
・最終メッセージ: 「レベル100のニューラルリンクは繊細、過度にタップしないよう注意」

【サウンド】
・通常BGM: コミカル調
・般若モード: 専用BGM（音量増加）
・効果音: Web Audio API使用、コンボ数で音階変化、通常時は水音
・効果音はプレイヤー側のみ再生
・ミサイル警告音: ピピピッ
-->

<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap');

body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #001e36;
  background: radial-gradient(circle at 50% 50%, #0a0a12 0%, #000000 100%);
  background-position: center;
  font-family: 'Share Tech Mono', 'M PLUS Rounded 1c', sans-serif;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Quantum Impact Effect (replaces shake) */
#game-container.quantum-impact {
  animation: quantum-flash 0.15s ease-out;
}

@keyframes quantum-flash {
  0% { 
    filter: brightness(1) saturate(1);
  }
  30% { 
    filter: brightness(2) saturate(1.5) hue-rotate(10deg);
  }
  60% { 
    filter: brightness(1.5) saturate(1.2) hue-rotate(-5deg);
  }
  100% { 
    filter: brightness(1) saturate(1);
  }
}

/* UI Overlay */
#ui-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
  display: none;
  flex-direction: column;
  justify-content: flex-end;
}

/* =====================================================
   FUTURISTIC AI LEVEL SELECT - Start Screen
   Next-Gen Holographic Interface Design
   ===================================================== */
#start-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at 50% 30%, rgba(10, 25, 47, 0.98) 0%, rgba(3, 7, 18, 0.99) 50%, #000 100%);
  display: none;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  z-index: 50;
  perspective: 2000px;
  overflow: hidden;
  touch-action: none;
  -webkit-overflow-scrolling: none;
  overscroll-behavior: none;
  padding-top: clamp(10px, 2vh, 20px);
  padding-bottom: 20px;
  box-sizing: border-box;
}

/* Falling Blocks Background Canvas */
#falling-blocks-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}

/* Background Effects Layer */
.ai-select-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.ai-select-bg .volumetric-fog {
  position: absolute;
  width: 100%;
  height: 100%;
  /* 軽量化: グラデーションを3つ→1つに削減 */
  background: 
    radial-gradient(ellipse 80% 50% at 50% 100%, rgba(255, 0, 102, 0.08) 0%, transparent 60%);
  /* 軽量化: アニメーション時間を長くし、GPUアクセラレーションを追加 */
  animation: ai-fog-drift 30s ease-in-out infinite;
  will-change: opacity;
  z-index: 1;
}

@keyframes ai-fog-drift {
  /* 軽量化: scaleを削除し、opacityのみのアニメーションに */
  0%, 100% { opacity: 0.5; }
  50% { opacity: 0.7; }
}

.ai-select-bg .holo-grid {
  position: absolute;
  bottom: 0;
  left: -50%;
  width: 200%;
  height: 60%;
  /* 軽量化: グリッドを1つに削減 */
  background: 
    linear-gradient(90deg, transparent 49%, rgba(255, 0, 102, 0.03) 49.5%, rgba(255, 0, 102, 0.03) 50.5%, transparent 51%);
  background-size: 60px 60px;
  transform: perspective(500px) rotateX(60deg) translateY(50%);
  transform-origin: center bottom;
  mask-image: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 80%);
  -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 80%);
  /* 軽量化: アニメーション時間を長く */
  animation: ai-grid-scroll 25s linear infinite;
  will-change: background-position;
  z-index: 1;
}

@keyframes ai-grid-scroll {
  0% { background-position: 0 0; }
  100% { background-position: 0 60px; }
}

.ai-select-bg .scan-lines {
  position: absolute;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent 0px,
    transparent 2px,
    rgba(255, 0, 102, 0.015) 2px,
    rgba(255, 0, 102, 0.015) 4px
  );
  pointer-events: none;
  z-index: 3;
}

.ai-select-bg .horizontal-scanner {
  display: none !important;
}

/* AI Level Status Badge */
.ai-level-status {
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px;
  color: rgba(255, 0, 102, 0.6);
  text-transform: uppercase;
  letter-spacing: 3px;
  margin-bottom: 15px;
  margin-top: 5px;
  z-index: 10;
  position: relative;
  flex-shrink: 0;
}

.ai-level-status::before,
.ai-level-status::after {
  content: '//';
  margin: 0 10px;
  opacity: 0.4;
}

.ai-level-status .status-dot {
  display: inline-block;
  width: 6px;
  height: 6px;
  background: #ff0066;
  border-radius: 50%;
  margin-right: 8px;
  box-shadow: 0 0 8px #ff0066;
  /* 軽量化: アニメーション時間を長く */
  animation: ai-status-blink 4s ease-in-out infinite;
}

@keyframes ai-status-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* Data Stream Decorations for AI Select */
.ai-data-stream {
  position: absolute;
  font-family: 'Share Tech Mono', monospace;
  font-size: 8px;
  color: rgba(255, 0, 102, 0.3);
  writing-mode: vertical-rl;
  text-orientation: mixed;
  letter-spacing: 2px;
  /* 軽量化: アニメーション時間を長く */
  animation: ai-data-scroll 15s linear infinite;
  will-change: opacity;
  z-index: 5;
  pointer-events: none;
}

.ai-data-stream.left {
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
}

.ai-data-stream.right {
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
}

@keyframes ai-data-scroll {
  0% { opacity: 0.2; }
  50% { opacity: 0.5; }
  100% { opacity: 0.2; }
}

.title {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(36px, 8vw, 56px);
  color: #fff;
  text-align: center;
  line-height: 1.2;
  margin-bottom: clamp(10px, 2vh, 20px);
  flex-shrink: 0;
  text-shadow: 
    0 0 7px #fff,
    0 0 10px #fff,
    0 0 21px #fff,
    0 0 42px #bc13fe,
    0 0 82px #bc13fe,
    0 0 92px #bc13fe,
    0 0 102px #bc13fe,
    0 0 151px #bc13fe;
  animation: neon-flicker 1.5s infinite alternate;
}

@keyframes neon-flicker {
  0%, 18%, 22%, 25%, 53%, 57%, 100% {
    text-shadow: 
    0 0 7px #fff,
    0 0 10px #fff,
    0 0 21px #fff,
    0 0 42px #bc13fe,
    0 0 82px #bc13fe,
    0 0 92px #bc13fe,
    0 0 102px #bc13fe,
    0 0 151px #bc13fe;
  }
  20%, 24%, 55% {
    text-shadow: none;
  }
}

/* =====================================================
   NEURAL TRANSCENDENCE EFFECT - AI Level ∞ Awakening
   ===================================================== */
#transcendence-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  pointer-events: none;
  opacity: 0;
  background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.3) 100%);
  transition: opacity 0.3s ease;
}

#transcendence-overlay.active {
  pointer-events: all;
  opacity: 1;
}

#transcendence-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

/* Infinity Symbol Final State - SMART AI AWAKENING */
.infinity-symbol {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-family: 'Orbitron', sans-serif;
  font-size: 120px;
  font-weight: 900;
  color: transparent;
  background: linear-gradient(135deg, 
    #00d4ff 0%, 
    #ffffff 30%,
    #00d4ff 50%, 
    #ffffff 70%,
    #00d4ff 100%);
  background-size: 200% 200%;
  -webkit-background-clip: text;
  background-clip: text;
  opacity: 0;
  animation: infinity-gradient-smart 4s ease-in-out infinite;
  filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.6));
}

.infinity-symbol::before {
  content: '';
  display: none;
}

.infinity-symbol::after {
  content: '';
  display: none;
}

@keyframes glitch-shift {
  0% { transform: translate(0, 0); opacity: 0; }
  100% { transform: translate(0, 0); opacity: 0; }
}

@keyframes infinity-gradient {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes infinity-gradient-smart {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.infinity-symbol.emerge {
  animation: infinity-emerge-smart 2s cubic-bezier(0.4, 0, 0.2, 1) forwards,
             infinity-gradient-smart 4s ease-in-out infinite;
}

@keyframes infinity-emerge-smart {
  0% { 
    opacity: 0; 
    transform: translate(-50%, -50%) scale(0.8);
    filter: blur(10px) drop-shadow(0 0 10px rgba(0, 212, 255, 0.3));
  }
  50% {
    opacity: 0.7;
    transform: translate(-50%, -50%) scale(1.02);
    filter: blur(2px) drop-shadow(0 0 25px rgba(0, 212, 255, 0.8));
  }
  100% { 
    opacity: 1; 
    transform: translate(-50%, -50%) scale(1);
    filter: blur(0px) drop-shadow(0 0 20px rgba(0, 212, 255, 0.6));
  }
}

@keyframes infinity-pulse {
  0%, 100% { 
    filter: drop-shadow(0 0 15px rgba(0, 212, 255, 0.5));
  }
  50% { 
    filter: drop-shadow(0 0 25px rgba(0, 212, 255, 0.8));
  }
}

/* Holographic Distortion */
.holo-distortion {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    45deg,
    transparent 40%,
    rgba(255, 255, 255, 0.03) 45%,
    rgba(255, 255, 255, 0.05) 50%,
    rgba(255, 255, 255, 0.03) 55%,
    transparent 60%
  );
  background-size: 200% 200%;
  animation: holo-sweep 2s ease-in-out infinite;
  pointer-events: none;
  mix-blend-mode: overlay;
}

@keyframes holo-sweep {
  0% { background-position: -100% -100%; }
  100% { background-position: 200% 200%; }
}

/* Screen Flash */
.screen-flash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
}

.screen-flash.flash {
  animation: screen-flash-anim-smart 0.4s ease-out forwards;
}

@keyframes screen-flash-anim {
  0% { opacity: 0; }
  20% { opacity: 0.9; }
  100% { opacity: 0; }
}

@keyframes screen-flash-anim-smart {
  0% { opacity: 0; background: rgba(0, 212, 255, 0.3); }
  30% { opacity: 0.4; background: rgba(0, 212, 255, 0.2); }
  100% { opacity: 0; background: transparent; }
}

/* Energy Ring Pulse */
.energy-ring {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 10px;
  height: 10px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  border-radius: 50%;
  opacity: 0;
}

.energy-ring.pulse {
  animation: energy-ring-expand-smart 2s ease-out forwards;
}

@keyframes energy-ring-expand {
  0% { 
    width: 10px; 
    height: 10px; 
    opacity: 1;
    border-width: 3px;
    border-color: rgba(255, 255, 255, 1);
    box-shadow: 0 0 30px rgba(255, 255, 255, 0.8), inset 0 0 30px rgba(255, 255, 255, 0.3);
  }
  100% { 
    width: 300vmax; 
    height: 300vmax; 
    opacity: 0;
    border-width: 1px;
    border-color: rgba(155, 89, 182, 0.3);
    box-shadow: 0 0 100px rgba(155, 89, 182, 0.2), inset 0 0 50px rgba(155, 89, 182, 0.1);
  }
}

@keyframes energy-ring-expand-smart {
  0% { 
    width: 10px; 
    height: 10px; 
    opacity: 0.8;
    border-width: 2px;
    border-color: rgba(0, 212, 255, 0.9);
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
  }
  100% { 
    width: 200vmax; 
    height: 200vmax; 
    opacity: 0;
    border-width: 1px;
    border-color: rgba(0, 212, 255, 0.2);
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.1);
  }
}

/* Transcendence Status Text - SMART AI DESIGN */
.transcendence-status {
  position: absolute;
  bottom: 18%;
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Share Tech Mono', 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 400;
  color: rgba(0, 212, 255, 0.9);
  text-transform: uppercase;
  letter-spacing: 4px;
  opacity: 0;
  text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

.transcendence-status::before {
  content: '[ ';
  color: rgba(0, 212, 255, 0.6);
}

.transcendence-status::after {
  content: ' ]';
  color: rgba(0, 212, 255, 0.6);
}

.transcendence-status.show {
  animation: status-appear-smart 1s ease forwards;
}

@keyframes status-appear {
  0% { 
    opacity: 0; 
    transform: translateX(-50%) translateY(30px) scale(0.8);
    filter: blur(10px) drop-shadow(0 0 10px rgba(255, 0, 255, 0.5));
  }
  50% {
    filter: blur(0px) drop-shadow(0 0 20px rgba(255, 0, 255, 0.8)) drop-shadow(0 0 40px rgba(0, 255, 255, 0.5));
  }
  100% { 
    opacity: 1; 
    transform: translateX(-50%) translateY(0) scale(1);
    filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.5)) drop-shadow(0 0 20px rgba(0, 255, 255, 0.3));
  }
}

@keyframes status-appear-smart {
  0% { 
    opacity: 0; 
    transform: translateX(-50%) translateY(10px);
  }
  100% { 
    opacity: 1; 
    transform: translateX(-50%) translateY(0);
  }
}

@keyframes status-gradient {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}

/* Warning Scan Line for Transcendence */
.transcendence-scan {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 4px;
  background: linear-gradient(90deg, transparent, #ff0066, #00ffff, #ff0066, transparent);
  opacity: 0;
  animation: scan-sweep 1.5s ease-in-out infinite;
}

@keyframes scan-sweep {
  0% { top: 0; opacity: 0; }
  10% { opacity: 0.8; }
  90% { opacity: 0.8; }
  100% { top: 100%; opacity: 0; }
}

/* Chromatic Aberration Effect */
.chromatic-aberration {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  opacity: 0;
}

.chromatic-aberration.active {
  animation: chromatic-pulse 2s ease-in-out;
}

@keyframes chromatic-pulse {
  0%, 100% { 
    opacity: 0;
    filter: none;
  }
  30%, 70% {
    opacity: 1;
    filter: url(#chromatic-aberration-filter);
  }
}

/* Vignette Effect */
.transcendence-vignette {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at center, 
    transparent 0%, 
    transparent 40%,
    rgba(0, 0, 0, 0.4) 80%,
    rgba(0, 0, 0, 0.8) 100%);
  pointer-events: none;
  opacity: 0;
  transition: opacity 1s ease;
}

.transcendence-vignette.active {
  opacity: 1;
}

/* =====================================================
   MODE TRANSCENDED - AI Level ∞ Permanent State
   ===================================================== */
#start-screen.mode-transcended {
  background: radial-gradient(ellipse at 50% 30%, 
    rgba(30, 20, 50, 0.98) 0%, 
    rgba(10, 5, 25, 0.99) 50%, 
    #000 100%);
}

#start-screen.mode-transcended .ai-select-bg .volumetric-fog {
  /* 軽量化: グラデーションを1つに削減 */
  background: 
    radial-gradient(ellipse 80% 50% at 50% 100%, rgba(255, 215, 0, 0.1) 0%, transparent 60%);
}

#start-screen.mode-transcended .ai-select-bg .holo-grid {
  /* 軽量化: グリッドを1つに削減 */
  background: 
    linear-gradient(90deg, transparent 49%, rgba(255, 215, 0, 0.05) 49.5%, rgba(255, 215, 0, 0.05) 50.5%, transparent 51%);
  background-size: 60px 60px;
}

#start-screen.mode-transcended .ai-select-bg .horizontal-scanner {
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 215, 0, 0.3) 20%, 
    rgba(255, 215, 0, 0.6) 50%, 
    rgba(255, 215, 0, 0.3) 80%, 
    transparent 100%);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

#start-screen.mode-transcended .ai-level-status {
  color: rgba(255, 215, 0, 0.8);
}

#start-screen.mode-transcended .ai-level-status .status-dot {
  background: linear-gradient(135deg, #ffd700, #9b59b6);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 0 0 10px #ffd700;
}

#start-screen.mode-transcended .cpu-setting-container {
  border-color: rgba(255, 215, 0, 0.2);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.4),
    0 0 30px rgba(255, 215, 0, 0.1);
}

#start-screen.mode-transcended .ai-data-stream {
  color: rgba(255, 215, 0, 0.4);
}

/* Transcended Circuit SVG Animation */
/* 軽量化: filter drop-shadowのアニメーションを削除し、静的なエフェクトのみ */
.transcended-circuit {
  filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.25));
}

.subtitle {
  font-size: 20px;
  color: #0ff;
  margin-bottom: 30px;
  font-weight: bold;
  text-shadow: 0 0 5px #0ff;
  letter-spacing: 2px;
}

/* Holographic Panel - AI Setting Container */
.cpu-setting-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  margin-bottom: 30px;
  width: 90%;
  max-width: 420px;
  flex-shrink: 0;
  background: linear-gradient(135deg, 
    rgba(10, 30, 50, 0.6) 0%, 
    rgba(5, 15, 30, 0.8) 50%,
    rgba(10, 30, 50, 0.6) 100%);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  padding: 25px;
  border-radius: 16px;
  border: 1px solid rgba(255, 0, 102, 0.15);
  box-shadow: 
    0 4px 30px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(255, 0, 102, 0.05),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  position: relative;
  z-index: 10;
  overflow: hidden;
}

/* Glass Refraction Edge */
.cpu-setting-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.2) 20%, 
    rgba(255, 255, 255, 0.4) 50%, 
    rgba(255, 255, 255, 0.2) 80%, 
    transparent 100%);
  z-index: 5;
}

/* Holographic Shimmer */
.cpu-setting-container::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 40%,
    rgba(255, 255, 255, 0.03) 45%,
    rgba(255, 255, 255, 0.05) 50%,
    rgba(255, 255, 255, 0.03) 55%,
    transparent 60%
  );
  animation: ai-shimmer 4s linear infinite;
  z-index: 1;
  pointer-events: none;
}

@keyframes ai-shimmer {
  0% { transform: translateX(-100%) rotate(45deg); }
  100% { transform: translateX(100%) rotate(45deg); }
}

/* Corner Brackets for AI Panel */
.ai-panel-corner {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(255, 0, 102, 0.3);
  z-index: 3;
  transition: all 0.3s;
}

.ai-panel-corner.tl { top: 8px; left: 8px; border-right: none; border-bottom: none; }
.ai-panel-corner.tr { top: 8px; right: 8px; border-left: none; border-bottom: none; }
.ai-panel-corner.bl { bottom: 8px; left: 8px; border-right: none; border-top: none; }
.ai-panel-corner.br { bottom: 8px; right: 8px; border-left: none; border-top: none; }

/* Mode Indicator for AI Panel */
.ai-panel-indicator {
  position: absolute;
  left: 0;
  top: 15%;
  bottom: 15%;
  width: 3px;
  background: #ff0066;
  border-radius: 0 2px 2px 0;
  box-shadow: 0 0 15px #ff0066, 0 0 30px #ff0066;
}

#cpu-face-container {
  width: 100%;
  height: clamp(120px, 25vh, 200px);
  transition: transform 0.2s;
  filter: drop-shadow(0 0 15px rgba(255, 0, 102, 0.5));
  position: relative;
  z-index: 2;
}

/* Futuristic Slider */
#start-screen input[type=range] {
  width: 100%;
  height: 8px;
  background: linear-gradient(90deg, 
    rgba(255, 0, 102, 0.2) 0%, 
    rgba(255, 0, 102, 0.3) 50%, 
    rgba(255, 0, 102, 0.2) 100%);
  border-radius: 4px;
  outline: none;
  -webkit-appearance: none;
  border: 1px solid rgba(255, 0, 102, 0.3);
  box-shadow: 0 0 10px rgba(255, 0, 102, 0.2), inset 0 0 5px rgba(0, 0, 0, 0.5);
  position: relative;
  z-index: 2;
}

#start-screen input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 24px;
  height: 24px;
  background: radial-gradient(circle, #fff 0%, #ff0066 60%, #ff0066 100%);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 15px #ff0066, 0 0 30px rgba(255, 0, 102, 0.5);
  border: 2px solid rgba(255, 255, 255, 0.5);
  transition: transform 0.2s, box-shadow 0.2s;
}

#start-screen input[type=range]::-webkit-slider-thumb:active {
  transform: scale(1.1);
  box-shadow: 0 0 20px #ff0066, 0 0 40px rgba(255, 0, 102, 0.7);
}

/* Keep default styles for other range inputs */
input[type=range] {
  width: 100%;
  height: 6px;
  background: #333;
  border-radius: 3px;
  outline: none;
  -webkit-appearance: none;
}

input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  background: #0ff;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px #0ff;
}

@keyframes slow-spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.spin-slow {
  animation: slow-spin 60s linear infinite;
}

@keyframes glitch-skew {
  0% { transform: skew(0deg); }
  20% { transform: skew(-20deg); filter: hue-rotate(90deg); }
  40% { transform: skew(20deg); filter: hue-rotate(-90deg); }
  60% { transform: skew(-10deg); }
  80% { transform: skew(10deg); }
  100% { transform: skew(0deg); }
}

/* Terror Animation for Infinite Mode - Enhanced Neural Network Collapse */

/* Core system pulse - erratic heartbeat of failing AI */
@keyframes terror-pulse {
  0% { transform: scale(1); fill: #200; filter: brightness(0.5); }
  15% { transform: scale(1.5); fill: #f00; filter: brightness(2) drop-shadow(0 0 10px #f00); }
  20% { transform: scale(0.8); fill: #500; filter: brightness(0.3); }
  35% { transform: scale(1.3); fill: #ff3300; filter: brightness(1.5) drop-shadow(0 0 15px #ff3300); }
  50% { transform: scale(1); fill: #300; filter: brightness(0.6); }
  65% { transform: scale(1.6); fill: #f00; filter: brightness(2.5) drop-shadow(0 0 20px #fff); }
  75% { transform: scale(0.9); fill: #400; filter: brightness(0.4); }
  100% { transform: scale(1); fill: #200; filter: brightness(0.5); }
}

/* Circuit overload - electrical surge through damaged lines */
@keyframes terror-line {
  0% { stroke-opacity: 0.1; stroke-width: 0.5; stroke: #300; }
  5% { stroke-opacity: 1; stroke-width: 4; stroke: #fff; filter: drop-shadow(0 0 8px #fff); }
  8% { stroke-opacity: 0.2; stroke-width: 1; stroke: #f00; }
  15% { stroke-opacity: 0.9; stroke-width: 3; stroke: #ff0; filter: drop-shadow(0 0 5px #ff0); }
  20% { stroke-opacity: 0; stroke-width: 0; }
  25% { stroke-opacity: 0.7; stroke-width: 2; stroke: #f00; }
  40% { stroke-opacity: 0.1; stroke-width: 1; stroke: #500; }
  60% { stroke-opacity: 1; stroke-width: 5; stroke: #f00; filter: drop-shadow(0 0 12px #f00); }
  65% { stroke-opacity: 0; stroke-width: 0; }
  100% { stroke-opacity: 0.1; stroke-width: 0.5; stroke: #300; }
}

/* System instability - violent shaking */
@keyframes terror-shake {
  0% { transform: translate(0,0) rotate(0deg) skew(0deg); }
  10% { transform: translate(-4px, 2px) rotate(-2deg) skew(-2deg); }
  20% { transform: translate(5px, -3px) rotate(3deg) skew(3deg); }
  30% { transform: translate(-2px, 4px) rotate(-1deg) skew(-1deg); }
  40% { transform: translate(3px, -2px) rotate(2deg) skew(2deg); }
  50% { transform: translate(-5px, 3px) rotate(-3deg) skew(-3deg); }
  60% { transform: translate(4px, -4px) rotate(2deg) skew(1deg); }
  70% { transform: translate(-3px, 2px) rotate(-2deg) skew(-2deg); }
  80% { transform: translate(2px, -3px) rotate(1deg) skew(2deg); }
  90% { transform: translate(-4px, 4px) rotate(-1deg) skew(-1deg); }
  100% { transform: translate(0,0) rotate(0deg) skew(0deg); }
}

/* Eye of the corrupted AI - erratic scanning */
@keyframes eye-move {
  0% { transform: translate(0, 0) scale(1); }
  10% { transform: translate(5px, 3px) scale(1.2); }
  20% { transform: translate(-4px, -2px) scale(0.8); }
  30% { transform: translate(3px, -4px) scale(1.1); }
  40% { transform: translate(-5px, 2px) scale(0.9); }
  50% { transform: translate(0, 5px) scale(1.3); }
  60% { transform: translate(4px, -3px) scale(0.7); }
  70% { transform: translate(-3px, 4px) scale(1.15); }
  80% { transform: translate(2px, -5px) scale(0.85); }
  90% { transform: translate(-2px, 2px) scale(1.05); }
  100% { transform: translate(0, 0) scale(1); }
}

/* Neural node spark - short circuit effect */
@keyframes neural-spark {
  0%, 100% { opacity: 0; transform: scale(0); }
  5% { opacity: 1; transform: scale(2); filter: brightness(3); }
  10% { opacity: 0.3; transform: scale(0.5); }
  15% { opacity: 1; transform: scale(1.5); filter: brightness(2.5); }
  20% { opacity: 0; transform: scale(0); }
}

/* Data corruption cascade */
@keyframes data-corrupt {
  0% { opacity: 1; transform: translateX(0); filter: none; }
  10% { opacity: 0.5; transform: translateX(5px); filter: blur(1px); }
  20% { opacity: 1; transform: translateX(-3px); filter: none; }
  30% { opacity: 0.2; transform: translateX(8px) skewX(10deg); filter: blur(2px); }
  40% { opacity: 0.8; transform: translateX(-5px); filter: none; }
  50% { opacity: 0; transform: translateX(15px); filter: blur(3px); }
  60% { opacity: 1; transform: translateX(0); filter: none; }
  70% { opacity: 0.3; transform: translateX(-10px) skewX(-15deg); filter: blur(1px); }
  80% { opacity: 0.9; transform: translateX(3px); filter: none; }
  90% { opacity: 0.1; transform: translateX(-8px); filter: blur(2px); }
  100% { opacity: 1; transform: translateX(0); filter: none; }
}

/* Electric arc between nodes */
@keyframes electric-arc {
  0%, 100% { stroke-dashoffset: 100; opacity: 0; }
  10% { stroke-dashoffset: 0; opacity: 1; stroke: #fff; }
  15% { opacity: 0; }
  25% { stroke-dashoffset: 50; opacity: 0.8; stroke: #ff0; }
  30% { opacity: 0; }
  50% { stroke-dashoffset: 20; opacity: 1; stroke: #f00; }
  55% { opacity: 0; }
  70% { stroke-dashoffset: 80; opacity: 0.6; stroke: #ff0; }
  75% { opacity: 0; }
}

/* Binary data rain corruption */
@keyframes binary-rain {
  0% { transform: translateY(-100%); opacity: 0; }
  10% { opacity: 1; }
  50% { opacity: 1; }
  90% { opacity: 0.5; }
  100% { transform: translateY(100%); opacity: 0; }
}

/* Warning flash - critical system alert */
@keyframes warning-flash {
  0%, 100% { opacity: 0; transform: scale(0.8); }
  10%, 30% { opacity: 1; transform: scale(1); filter: drop-shadow(0 0 10px #f00); }
  20% { opacity: 0.5; transform: scale(1.05); }
  40%, 60% { opacity: 0; transform: scale(0.9); }
  70%, 90% { opacity: 0.8; transform: scale(1.02); filter: drop-shadow(0 0 15px #ff0); }
  80% { opacity: 0.3; transform: scale(0.95); }
}

/* Hologram distortion */
@keyframes holo-distort {
  0% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
  10% { clip-path: inset(5% 0 10% 0); filter: hue-rotate(90deg); }
  20% { clip-path: inset(0 5% 0 5%); filter: hue-rotate(0deg); }
  30% { clip-path: inset(15% 0 5% 0); filter: hue-rotate(-60deg); }
  40% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
  50% { clip-path: inset(3% 10% 3% 0); filter: hue-rotate(180deg); }
  60% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
  70% { clip-path: inset(8% 0 8% 5%); filter: hue-rotate(45deg); }
  80% { clip-path: inset(0 3% 0 3%); filter: hue-rotate(0deg); }
  90% { clip-path: inset(20% 0 0 0); filter: hue-rotate(-90deg); }
  100% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
}

/* RGB split effect */
@keyframes rgb-split {
  0%, 100% { text-shadow: 0 0 0 transparent; }
  20% { text-shadow: -2px 0 #f00, 2px 0 #0ff; }
  40% { text-shadow: 2px 0 #f00, -2px 0 #0ff; }
  60% { text-shadow: -3px 0 #0f0, 3px 0 #f0f; }
  80% { text-shadow: 1px 0 #ff0, -1px 0 #00f; }
}

/* System meltdown - progressive collapse */
@keyframes system-meltdown {
  0% { transform: translateY(0) scaleY(1); opacity: 1; }
  30% { transform: translateY(2px) scaleY(0.98); opacity: 0.9; }
  50% { transform: translateY(5px) scaleY(0.95); opacity: 0.8; }
  70% { transform: translateY(8px) scaleY(0.9); opacity: 0.6; }
  85% { transform: translateY(12px) scaleY(0.85); opacity: 0.4; }
  100% { transform: translateY(15px) scaleY(0.8); opacity: 0.2; }
}

.terror-svg {
  animation: terror-shake 0.15s infinite linear;
  filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.5));
}

/* Corrupted SVG overlay effects */
.terror-svg::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent 0px,
    transparent 2px,
    rgba(255, 0, 0, 0.1) 2px,
    rgba(255, 0, 0, 0.1) 4px
  );
  animation: holo-distort 0.5s infinite;
  pointer-events: none;
}

/* Infinite Mode Styles - Enhanced */
#start-screen.mode-infinite {
  background: radial-gradient(ellipse at 50% 30%, rgba(50, 0, 0, 0.98) 0%, rgba(20, 0, 0, 0.99) 50%, #000 100%);
}

#start-screen.mode-infinite .ai-select-bg .volumetric-fog {
  /* 軽量化: グラデーションを1つに削減 */
  background: 
    radial-gradient(ellipse 80% 50% at 50% 100%, rgba(255, 0, 0, 0.12) 0%, transparent 60%);
}

#start-screen.mode-infinite .ai-select-bg .holo-grid {
  /* 軽量化: グリッドを1つに削減 */
  background: 
    linear-gradient(90deg, transparent 49%, rgba(255, 0, 0, 0.05) 49.5%, rgba(255, 0, 0, 0.05) 50.5%, transparent 51%);
  background-size: 60px 60px;
}

#start-screen.mode-infinite .ai-select-bg .scan-lines {
  background: repeating-linear-gradient(
    0deg,
    transparent 0px,
    transparent 2px,
    rgba(255, 0, 0, 0.03) 2px,
    rgba(255, 0, 0, 0.03) 4px
  );
}

#start-screen.mode-infinite .ai-select-bg .horizontal-scanner {
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 0, 0, 0.4) 20%, 
    rgba(255, 0, 0, 0.6) 50%, 
    rgba(255, 0, 0, 0.4) 80%, 
    transparent 100%);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
}

#start-screen.mode-infinite .title {
  /* 軽量化: text-shadowを削減 */
  text-shadow: 
    0 0 7px #fff,
    0 0 21px #fff,
    0 0 42px #f00,
    0 0 82px #f00;
  color: #fff;
  /* 軽量化: アニメーション時間を長く */
  animation: glitch-skew 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
}

#start-screen.mode-infinite .cpu-setting-container {
  border-color: rgba(255, 0, 0, 0.3);
  box-shadow: 
    0 4px 30px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(255, 0, 0, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

#start-screen.mode-infinite .ai-panel-corner {
  border-color: rgba(255, 0, 0, 0.5);
}

#start-screen.mode-infinite .ai-panel-indicator {
  background: #f00;
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 0 0 15px #f00;
}

#start-screen.mode-infinite input[type=range] {
  background: linear-gradient(90deg, 
    rgba(255, 0, 0, 0.2) 0%, 
    rgba(255, 0, 0, 0.3) 50%, 
    rgba(255, 0, 0, 0.2) 100%);
  border-color: rgba(255, 0, 0, 0.4);
}

#start-screen.mode-infinite input[type=range]::-webkit-slider-thumb {
  background: radial-gradient(circle, #fff 0%, #f00 60%, #f00 100%);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 0 0 12px #f00;
}

#start-screen.mode-infinite .start-btn {
  border-color: rgba(255, 0, 0, 0.6);
  background: linear-gradient(135deg, 
    rgba(255, 0, 0, 0.1) 0%, 
    rgba(255, 0, 0, 0.2) 50%,
    rgba(255, 0, 0, 0.1) 100%);
  /* 軽量化: box-shadowを簡素化 */
  box-shadow: 
    0 0 15px rgba(255, 0, 0, 0.25), 
    0 4px 15px rgba(0, 0, 0, 0.4);
  text-shadow: 0 0 10px #fff;
}

#start-screen.mode-infinite #cpu-strength-label {
  color: #f00;
  text-shadow: 0 0 10px #f00, 0 0 20px rgba(255, 0, 0, 0.5);
}

#start-screen.mode-infinite .ai-level-status {
  color: rgba(255, 0, 0, 0.6);
}

#start-screen.mode-infinite .ai-level-status .status-dot {
  background: #f00;
  box-shadow: 0 0 10px #f00;
}

#start-screen.mode-infinite .ai-data-stream {
  color: rgba(255, 0, 0, 0.3);
}

/* Version Badge for AI Select */
.ai-version-badge {
  position: relative;
  margin-top: auto;
  padding-top: 15px;
  padding-bottom: 10px;
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  color: rgba(255, 0, 102, 0.4);
  letter-spacing: 2px;
  z-index: 10;
  flex-shrink: 0;
}

@keyframes spark-anim {
  0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
  50% { opacity: 1; transform: scale(1.2) rotate(45deg); }
  100% { opacity: 0; transform: scale(0) rotate(90deg); }
}

#cpu-strength-label {
  font-size: 22px;
  color: #ff0066;
  font-weight: bold;
  margin: 0;
  font-family: 'Orbitron', sans-serif;
  text-shadow: 0 0 10px #ff0066, 0 0 20px rgba(255, 0, 102, 0.5);
  letter-spacing: 3px;
  position: relative;
  z-index: 2;
}

/* Holographic Start Button */
.start-btn {
  background: linear-gradient(135deg, 
    rgba(255, 0, 102, 0.1) 0%, 
    rgba(255, 0, 102, 0.2) 50%,
    rgba(255, 0, 102, 0.1) 100%);
  color: #fff;
  border: 2px solid rgba(255, 0, 102, 0.6);
  padding: 18px 0;
  flex: 9;
  font-size: 18px;
  border-radius: 12px;
  font-family: 'Orbitron', sans-serif;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 
    0 0 20px rgba(255, 0, 102, 0.3), 
    inset 0 0 15px rgba(255, 0, 102, 0.2),
    0 4px 20px rgba(0, 0, 0, 0.5);
  text-shadow: 0 0 10px #fff, 0 0 20px #ff0066;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  text-transform: uppercase;
  letter-spacing: 3px;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.start-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.2) 50%, 
    transparent 100%);
  animation: btn-shine 3s ease-in-out infinite;
}

@keyframes btn-shine {
  0% { left: -100%; }
  50%, 100% { left: 100%; }
}

.start-btn:active {
  background: linear-gradient(135deg, 
    rgba(255, 0, 102, 0.4) 0%, 
    rgba(255, 0, 102, 0.6) 50%,
    rgba(255, 0, 102, 0.4) 100%);
  color: #fff;
  box-shadow: 
    0 0 30px rgba(255, 0, 102, 0.6), 
    inset 0 0 25px rgba(255, 0, 102, 0.4),
    0 2px 10px rgba(0, 0, 0, 0.5);
  transform: scale(0.98) translateY(2px);
  border-color: #ff0066;
}

.start-actions {
  display: flex;
  gap: 12px;
  margin-bottom: 30px;
  z-index: 10;
  width: 90%;
  max-width: 420px;
  padding: 0;
  box-sizing: border-box;
}

.tutorial-btn {
  background: transparent;
  color: #fff;
  border: 2px solid #4ECDC4;
  padding: 15px 0;
  flex: 1;
  font-size: 10px;
  border-radius: 5px;
  font-family: 'Orbitron', sans-serif;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 0 0 10px #4ECDC4, inset 0 0 10px #4ECDC4;
  text-shadow: 0 0 5px #fff, 0 0 10px #4ECDC4;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 0px;
}

.tutorial-btn:active {
  background: #4ECDC4;
  color: #000;
  box-shadow: 0 0 20px #4ECDC4, inset 0 0 20px #4ECDC4;
  transform: scale(0.95);
}

.shake {
  animation: none;
}
@keyframes shake {
  0% { transform: translate(1px, 1px) rotate(0deg); }
  25% { transform: translate(-3px, -2px) rotate(-5deg); }
  50% { transform: translate(3px, 2px) rotate(5deg); }
  75% { transform: translate(-3px, 2px) rotate(-5deg); }
  100% { transform: translate(0, 0) rotate(0deg); }
}

/* Neural Link Break Animation */
.neural-break {
  position: relative;
}
.neural-break::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 255, 0.3) 50%, transparent 100%);
  animation: neural-glitch 0.15s ease-out;
  pointer-events: none;
}
@keyframes neural-glitch {
  0% { opacity: 1; transform: translateX(-100%); }
  50% { opacity: 0.8; }
  100% { opacity: 0; transform: translateX(100%); }
}

/* Controls */
.controls-area {
  height: 25%;
  width: 100%;
  padding-bottom: 20px;
  display: flex;
  justify-content: center;
  padding-left: 30px;
  padding-right: 30px;
  box-sizing: border-box;
  align-items: center;
  pointer-events: auto;
  position: relative;
  background: linear-gradient(to top, rgba(0, 20, 40, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
}

.d-pad {
  position: relative;
  width: 180px;
  height: 180px;
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/boeh23kv.png');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  top: -5px;
}

.btn {
  position: absolute;
  background: transparent;
  border: none;
  border-radius: 10px;
  box-shadow: none;
  touch-action: manipulation;
}

.d-pad .btn:active {
  background: radial-gradient(circle, rgba(255, 255, 255, 0.6) 0%, rgba(0, 255, 255, 0.3) 60%, transparent 100%);
  box-shadow: 0 0 20px #0ff, inset 0 0 15px #fff;
  filter: brightness(1.2);
}

.btn-left {
  width: 80px; height: 80px;
  top: 50%; left: -16px;
  transform: translateY(-50%);
  border-radius: 50%;
}
.btn-right {
  width: 80px; height: 80px;
  top: 50%; right: -16px;
  transform: translateY(-50%);
  border-radius: 50%;
}
.btn-down {
  width: 80px; height: 80px;
  bottom: -10px; left: 50%;
  transform: translateX(-50%);
  z-index: 5;
  border-radius: 50%;
}
.btn-up {
  width: 80px; height: 80px;
  top: -10px; left: 50%;
  transform: translateX(-50%);
  border-radius: 50%;
}
.btn-item {
  position: absolute;
  right: 25px;
  top: 25%;
  margin-top: 20px;
  transform: translateY(-50%);
  width: 40px;
  height: 25px;
  background-color: transparent;
  border: none;
  box-shadow: none;
  color: transparent;
  font-family: 'Orbitron', sans-serif;
  font-size: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  backdrop-filter: none;
  transition: transform 0.1s, box-shadow 0.1s;
  overflow: visible;
}
.btn-item::after {
  content: '';
  position: absolute;
  width: calc(70px * var(--item-scale, 1));
  height: calc(45px * var(--item-scale, 1));
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/h9o0fz0b.png');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  pointer-events: none;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.btn-item:active {
  transform: translateY(-50%) scale(0.95);
  box-shadow: none;
  filter: brightness(1.2);
}

.btn-swap {
  position: absolute;
  background-color: transparent;
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/8uyzg3ax.png');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  color: transparent;
  border: none;
  font-family: 'Orbitron', sans-serif;
  font-size: 0;
  cursor: pointer;
  display: none;
  justify-content: center;
  align-items: center;
  box-shadow: none;
  z-index: 20;
  pointer-events: auto;
  text-shadow: none;
  touch-action: manipulation;
}
.btn-swap:active {
  transform: scale(0.95);
  box-shadow: none;
  filter: brightness(1.1);
}

/* Game Over Modal */
#game-over-modal {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 100;
  animation: fadeIn 0.5s ease-out;
}

.result-card {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 20px;
  padding: 40px;
  width: 80%;
  max-width: 450px;
  text-align: center;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
  transform: translateY(20px);
  animation: slideUp 0.5s ease-out forwards;
}

.fade-item {
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.6s cubic-bezier(0.22, 1, 0.36, 1);
  pointer-events: none;
}
.fade-item.visible {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}

.rank-value {
  transform: scale(3);
  opacity: 0;
  transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  display: inline-block;
}
.rank-value.visible {
  transform: scale(1);
  opacity: 1;
}

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

.result-title {
  font-size: 36px;
  font-weight: 800;
  margin: 0 0 20px 0;
  text-shadow: 0 0 10px currentColor;
  font-family: 'Orbitron', sans-serif;
  overflow: visible;
  word-break: keep-all;
  white-space: pre-line;
  hyphens: none;
  line-height: 1.3;
}

.stats-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 15px;
  margin-bottom: 20px;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  background: rgba(0, 0, 0, 0.3);
  padding: 10px;
  border-radius: 10px;
  color: #fff;
  font-family: 'Share Tech Mono', monospace;
}

.stat-label {
  color: #aaa;
  font-size: 12px;
  margin-bottom: 5px;
}

.stat-value {
  color: #0ff;
  font-size: 20px;
  font-weight: bold;
  text-shadow: 0 0 5px #0ff;
}

/* Analysis UI */
.analysis-container {
  margin-bottom: 20px;
  background: rgba(0, 20, 40, 0.5);
  border-radius: 10px;
  padding: 15px;
  border: 1px solid rgba(0, 255, 255, 0.1);
}

.rank-display {
  display: flex;
  justify-content: center;
  align-items: baseline;
  margin-bottom: 15px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  padding-bottom: 10px;
}
.rank-label {
  font-size: 16px;
  color: #aaa;
  margin-right: 10px;
}
.rank-value {
  font-size: 48px;
  font-weight: 900;
  color: #FFD700;
  text-shadow: 0 0 15px #FFD700;
  font-family: 'Orbitron', sans-serif;
}

.metrics-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.metric {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}
.metric-label {
  font-size: 12px;
  color: #0ff;
  margin-bottom: 3px;
}
.metric-bar-bg {
  width: 100%;
  height: 6px;
  background: #333;
  border-radius: 3px;
  overflow: hidden;
}
.metric-bar-fill {
  height: 100%;
  background: #0ff;
  width: 0%;
  transition: width 1.5s cubic-bezier(0.22, 1, 0.36, 1);
  box-shadow: 0 0 5px #0ff;
}

.ai-comment-box {
  background: rgba(0, 0, 0, 0.6);
  border-left: 3px solid #0ff;
  padding: 10px;
  margin-bottom: 20px;
  text-align: left;
  font-family: 'Share Tech Mono', monospace;
  font-size: 14px;
  color: #eee;
  min-height: 60px;
  display: flex;
  align-items: center;
}
.ai-text {
  margin: 0;
  line-height: 1.4;
}
.cursor {
  display: inline-block;
  width: 8px;
  height: 14px;
  background: #0ff;
  animation: blink 1s infinite;
  vertical-align: middle;
  margin-left: 5px;
}

.restart-btn {
  background: #4ECDC4;
  color: white;
  border: none;
  padding: 15px 30px;
  font-size: 18px;
  border-radius: 30px;
  font-family: 'Orbitron', sans-serif;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 0 #3aa8a0;
  width: 100%;
  text-transform: uppercase;
  letter-spacing: 2px;
  transition: transform 0.1s;
}
.restart-btn:active {
  transform: translateY(4px);
  box-shadow: none;
}

.result-actions {
  display: flex;
  gap: 15px;
  width: 100%;
  justify-content: center;
  margin-top: 10px;
}

.restart-btn.secondary {
  background: transparent;
  border: 2px solid #4ECDC4;
  color: #4ECDC4;
  box-shadow: 0 0 10px rgba(78, 205, 196, 0.2);
}
.restart-btn.secondary:active {
  background: rgba(78, 205, 196, 0.1);
  box-shadow: 0 0 15px rgba(78, 205, 196, 0.4);
}

.pause-btn {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 50px;
  height: 50px;
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/44e8a140-d15f-4801-9863-f505231a3b54/files/chsjqtfj.png');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  pointer-events: auto;
  z-index: 100;
  cursor: pointer;
  transition: transform 0.1s;
}
.pause-btn:active {
  transform: scale(0.9);
}

/* =====================================================
   TRAINING MODE CONTROLS CONTAINER
   ===================================================== */
.training-controls {
  position: absolute;
  top: 60px;
  right: 12px;
  display: none;
  flex-direction: column;
  gap: 12px;
  z-index: 100;
  pointer-events: auto;
}

.training-controls.visible {
  display: flex;
}

/* =====================================================
   FUTURISTIC AI BUTTON BASE STYLE
   ===================================================== */
.ai-control-btn {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: linear-gradient(135deg, rgba(0, 20, 40, 0.9) 0%, rgba(0, 40, 60, 0.85) 100%);
  border: 2px solid transparent;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(8px);
  overflow: hidden;
  min-width: 120px;
}

.ai-control-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 10px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 150, 255, 0.3), rgba(100, 200, 255, 0.5));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.8;
  transition: opacity 0.3s;
}

.ai-control-btn::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.1) 50%, transparent 70%);
  animation: ai-btn-shine 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes ai-btn-shine {
  0%, 100% { transform: translateX(-100%) rotate(45deg); }
  50% { transform: translateX(100%) rotate(45deg); }
}

.ai-control-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0, 255, 255, 0.3);
}

.ai-control-btn:hover::before {
  opacity: 1;
}

/* Active state */
.ai-control-btn.active {
  background: linear-gradient(135deg, rgba(0, 80, 100, 0.95) 0%, rgba(0, 50, 80, 0.9) 100%);
  box-shadow: 
    0 0 20px rgba(0, 255, 255, 0.4),
    inset 0 0 15px rgba(0, 255, 255, 0.1);
}

.ai-control-btn.active::before {
  background: linear-gradient(135deg, #0ff, #00a8ff, #0ff);
  opacity: 1;
}

/* Inactive state */
.ai-control-btn.inactive {
  background: linear-gradient(135deg, rgba(30, 30, 40, 0.9) 0%, rgba(20, 20, 30, 0.85) 100%);
  opacity: 0.6;
}

.ai-control-btn.inactive::before {
  background: linear-gradient(135deg, rgba(100, 100, 120, 0.5), rgba(80, 80, 100, 0.3));
  opacity: 0.5;
}

.ai-control-btn.inactive::after {
  display: none;
}

/* =====================================================
   AI STATUS INDICATOR
   ===================================================== */
.ai-status-indicator {
  position: relative;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #0ff;
  box-shadow: 
    0 0 6px #0ff,
    0 0 12px rgba(0, 255, 255, 0.5);
  transition: all 0.3s;
  flex-shrink: 0;
}

.ai-status-indicator::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: #0ff;
  transform: translate(-50%, -50%);
  animation: ai-pulse 2s ease-in-out infinite;
}

@keyframes ai-pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  50% { transform: translate(-50%, -50%) scale(1.8); opacity: 0; }
}

.ai-control-btn.inactive .ai-status-indicator {
  background: #666;
  box-shadow: none;
}

.ai-control-btn.inactive .ai-status-indicator::before {
  animation: none;
  opacity: 0;
}

/* =====================================================
   AI LABEL TEXT
   ===================================================== */
.ai-label {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.ai-label-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 8px;
  font-weight: 700;
  color: rgba(0, 255, 255, 0.7);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.ai-label-value {
  font-family: 'Share Tech Mono', monospace;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  letter-spacing: 0.5px;
  text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

.ai-control-btn.inactive .ai-label-title {
  color: rgba(150, 150, 150, 0.6);
}

.ai-control-btn.inactive .ai-label-value {
  color: #888;
  text-shadow: none;
}

/* =====================================================
   ROUTE BUTTON SPECIFIC STYLES
   ===================================================== */
.ai-control-btn.route-btn {
  background: linear-gradient(135deg, rgba(20, 10, 50, 0.9) 0%, rgba(40, 20, 80, 0.85) 100%);
}

.ai-control-btn.route-btn::before {
  background: linear-gradient(135deg, rgba(180, 100, 255, 0.6), rgba(120, 80, 200, 0.4), rgba(200, 150, 255, 0.6));
}

.ai-control-btn.route-btn.active {
  background: linear-gradient(135deg, rgba(80, 40, 120, 0.95) 0%, rgba(60, 30, 100, 0.9) 100%);
  box-shadow: 
    0 0 20px rgba(180, 100, 255, 0.4),
    inset 0 0 15px rgba(180, 100, 255, 0.1);
}

.ai-control-btn.route-btn.active::before {
  background: linear-gradient(135deg, #c080ff, #8050cc, #c080ff);
}

.ai-control-btn.route-btn .ai-status-indicator {
  background: #c080ff;
  box-shadow: 
    0 0 8px #c080ff,
    0 0 15px rgba(180, 100, 255, 0.5);
}

.ai-control-btn.route-btn .ai-label-title {
  color: rgba(200, 150, 255, 0.7);
}

.ai-control-btn.route-btn .ai-label-value {
  text-shadow: 0 0 10px rgba(180, 100, 255, 0.5);
}

.ai-control-btn.route-btn.inactive .ai-status-indicator {
  background: #555;
  box-shadow: none;
}

/* Disabled state for route button when assist is off */
.ai-control-btn.route-btn.disabled {
  opacity: 0.4;
  pointer-events: none;
  filter: grayscale(50%);
}

.ai-control-btn.route-btn.disabled::before {
  opacity: 0.3;
}

.ai-control-btn.route-btn.disabled .ai-status-indicator {
  background: #444;
  box-shadow: none;
}

.ai-control-btn.route-btn.disabled .ai-status-indicator::before {
  animation: none;
  opacity: 0;
}

/* Legacy support for old classes */
.assist-btn {
  display: none !important;
}

.assist-text {
  display: none !important;
}

/* Legacy combo-route-btn - replaced by new AI control system */
.combo-route-btn {
  display: none !important;
}

.combo-route-text {
  display: none !important;
}

/* =====================================================
   PAUSE OVERLAY - Futuristic AI Design
   ===================================================== */
#pause-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at 50% 50%, rgba(0, 10, 30, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 200;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

#pause-overlay.active {
  display: flex;
}

/* Pause Background Effects */
.pause-bg-effects {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

.pause-bg-effects .grid-lines {
  position: absolute;
  width: 100%;
  height: 100%;
  background: 
    linear-gradient(90deg, transparent 49.5%, rgba(0, 200, 255, 0.03) 50%, transparent 50.5%),
    linear-gradient(0deg, transparent 49.5%, rgba(0, 200, 255, 0.02) 50%, transparent 50.5%);
  background-size: 40px 40px;
  opacity: 0.5;
}

.pause-bg-effects .scan-beam {
  display: none !important;
}

/* Pause Title */
.pause-title {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(32px, 8vw, 48px);
  font-weight: 900;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: 10px;
  margin-bottom: 15px;
  text-shadow: 
    0 0 10px #0ff,
    0 0 20px #0ff,
    0 0 40px rgba(0, 255, 255, 0.5);
  position: relative;
  z-index: 10;
  animation: pause-title-glow 2s ease-in-out infinite alternate;
}

@keyframes pause-title-glow {
  0% { text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgba(0, 255, 255, 0.5); }
  100% { text-shadow: 0 0 15px #0ff, 0 0 30px #0ff, 0 0 60px rgba(0, 255, 255, 0.7); }
}

.pause-subtitle {
  font-family: 'Share Tech Mono', monospace;
  font-size: 12px;
  color: rgba(0, 255, 255, 0.6);
  letter-spacing: 5px;
  margin-bottom: 40px;
  z-index: 10;
}

/* AI Core Animation in Pause */
.pause-ai-core {
  width: 80px;
  height: 80px;
  position: relative;
  margin-bottom: 40px;
  z-index: 10;
}

.pause-ai-core .core-ring {
  position: absolute;
  border-radius: 50%;
  border: 2px solid rgba(0, 200, 255, 0.3);
  animation: pause-ring-spin 4s linear infinite;
}

.pause-ai-core .core-ring:nth-child(1) {
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}

.pause-ai-core .core-ring:nth-child(2) {
  width: 70%;
  height: 70%;
  top: 15%;
  left: 15%;
  border-style: dashed;
  animation-direction: reverse;
  animation-duration: 3s;
}

.pause-ai-core .core-ring:nth-child(3) {
  width: 40%;
  height: 40%;
  top: 30%;
  left: 30%;
  border-color: #0ff;
  box-shadow: 0 0 20px #0ff;
}

@keyframes pause-ring-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.pause-ai-core .core-center {
  position: absolute;
  width: 20px;
  height: 20px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(circle, #fff 0%, #0ff 50%, transparent 70%);
  border-radius: 50%;
  box-shadow: 0 0 20px #0ff, 0 0 40px rgba(0, 255, 255, 0.5);
  animation: pause-core-pulse 1.5s ease-in-out infinite;
}

@keyframes pause-core-pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
}

/* Pause Menu Buttons Container */
.pause-menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 15px;
  width: 90%;
  max-width: 320px;
  z-index: 10;
}

/* Pause Menu Button */
.pause-menu-btn {
  position: relative;
  width: 100%;
  padding: 18px 25px;
  background: linear-gradient(135deg, 
    rgba(10, 30, 50, 0.8) 0%, 
    rgba(5, 15, 30, 0.9) 50%,
    rgba(10, 30, 50, 0.8) 100%);
  border: 1px solid rgba(0, 200, 255, 0.3);
  border-radius: 12px;
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  font-weight: 700;
  letter-spacing: 3px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 30px rgba(0, 150, 255, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  overflow: hidden;
}

.pause-menu-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.5s ease;
}

.pause-menu-btn:hover::before,
.pause-menu-btn:active::before {
  left: 100%;
}

.pause-menu-btn:active {
  transform: scale(0.98);
  border-color: #0ff;
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(0, 255, 255, 0.3),
    inset 0 0 20px rgba(0, 255, 255, 0.1);
}

/* Resume Button - Primary */
.pause-menu-btn.resume {
  border-color: rgba(0, 255, 200, 0.4);
  background: linear-gradient(135deg, 
    rgba(0, 50, 40, 0.8) 0%, 
    rgba(0, 30, 25, 0.9) 50%,
    rgba(0, 50, 40, 0.8) 100%);
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 30px rgba(0, 255, 200, 0.15);
}

.pause-menu-btn.resume:active {
  border-color: #0fa;
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(0, 255, 200, 0.4),
    inset 0 0 20px rgba(0, 255, 200, 0.15);
}

/* Mode Select Button */
.pause-menu-btn.mode-select {
  border-color: rgba(255, 100, 100, 0.3);
  background: linear-gradient(135deg, 
    rgba(40, 20, 30, 0.8) 0%, 
    rgba(25, 10, 20, 0.9) 50%,
    rgba(40, 20, 30, 0.8) 100%);
}

.pause-menu-btn.mode-select:active {
  border-color: rgba(255, 100, 100, 0.6);
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(255, 100, 100, 0.3),
    inset 0 0 20px rgba(255, 100, 100, 0.1);
}

/* Button Icon */
.pause-menu-btn .btn-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-right: 12px;
  font-size: 18px;
  width: 24px;
  height: 24px;
}

/* Futuristic SVG Icons */
.pause-menu-btn .btn-icon svg {
  width: 20px;
  height: 20px;
  filter: drop-shadow(0 0 3px currentColor);
}

.pause-menu-btn.resume .btn-icon svg {
  fill: none;
  stroke: #0ffa;
  stroke-width: 2;
}

.pause-menu-btn.mode-select .btn-icon svg {
  fill: none;
  stroke: rgba(255, 120, 120, 0.9);
  stroke-width: 2;
}

.pause-menu-btn:active .btn-icon svg {
  filter: drop-shadow(0 0 8px currentColor);
  transform: scale(1.1);
}

/* Corner Decorations */
.pause-menu-btn .corner {
  position: absolute;
  width: 10px;
  height: 10px;
  border: 2px solid rgba(0, 200, 255, 0.4);
  transition: all 0.3s;
}

.pause-menu-btn .corner.tl { top: 5px; left: 5px; border-right: none; border-bottom: none; }
.pause-menu-btn .corner.tr { top: 5px; right: 5px; border-left: none; border-bottom: none; }
.pause-menu-btn .corner.bl { bottom: 5px; left: 5px; border-right: none; border-top: none; }
.pause-menu-btn .corner.br { bottom: 5px; right: 5px; border-left: none; border-top: none; }

.pause-menu-btn.resume .corner { border-color: rgba(0, 255, 200, 0.5); }
.pause-menu-btn.mode-select .corner { border-color: rgba(255, 100, 100, 0.4); }

.pause-menu-btn:active .corner {
  width: 15px;
  height: 15px;
}

/* Edit Controls Button */
.pause-menu-btn.edit-controls {
  border-color: rgba(255, 200, 100, 0.3);
  background: linear-gradient(135deg, 
    rgba(40, 35, 20, 0.8) 0%, 
    rgba(25, 20, 10, 0.9) 50%,
    rgba(40, 35, 20, 0.8) 100%);
}

.pause-menu-btn.edit-controls:active {
  border-color: rgba(255, 200, 100, 0.6);
  box-shadow: 
    0 4px 20px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(255, 200, 100, 0.3),
    inset 0 0 20px rgba(255, 200, 100, 0.1);
}

.pause-menu-btn.edit-controls .corner { border-color: rgba(255, 200, 100, 0.4); }

.pause-menu-btn.edit-controls .btn-icon svg {
  fill: none;
  stroke: rgba(255, 200, 100, 0.9);
  stroke-width: 2;
}

/* =====================================================
   BUTTON EDIT OVERLAY - Control Layout Editor
   ===================================================== */
#button-edit-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 5, 15, 0.6);
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
  display: none;
  flex-direction: column;
  z-index: 300;
  touch-action: none;
}

#button-edit-overlay.active {
  display: flex;
}

.edit-header {
  padding: 15px 20px;
  text-align: center;
  background: linear-gradient(to bottom, rgba(0, 20, 40, 0.9), transparent);
  flex-shrink: 0;
  position: relative;
  z-index: 10;
}

.edit-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  letter-spacing: 3px;
  text-shadow: 0 0 10px rgba(255, 200, 100, 0.5);
  margin-bottom: 5px;
}

.edit-subtitle {
  font-family: 'Share Tech Mono', monospace;
  font-size: 11px;
  color: rgba(255, 200, 100, 0.6);
  letter-spacing: 2px;
}

.edit-controls-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.edit-btn-wrapper {
  position: absolute;
  border: 2px dashed rgba(255, 200, 100, 0.6);
  border-radius: 10px;
  background: rgba(255, 200, 100, 0.1);
  cursor: move;
  touch-action: none;
  box-shadow: 0 0 20px rgba(255, 200, 100, 0.2);
  transition: border-color 0.2s, box-shadow 0.2s;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

#edit-dpad-wrapper {
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/boeh23kv.png');
}

#edit-item-wrapper {
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/h9o0fz0b.png');
}

#edit-swap-wrapper {
  background-image: url('https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/8uyzg3ax.png');
}

.edit-btn-wrapper.dragging {
  border-color: rgba(0, 255, 200, 0.8);
  box-shadow: 0 0 30px rgba(0, 255, 200, 0.4);
}

.edit-btn-wrapper.resizing {
  border-color: rgba(255, 100, 150, 0.8);
  box-shadow: 0 0 30px rgba(255, 100, 150, 0.4);
}

.edit-label {
  position: absolute;
  bottom: -25px;
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Orbitron', sans-serif;
  font-size: 10px;
  font-weight: 700;
  color: rgba(255, 200, 100, 0.9);
  letter-spacing: 2px;
  text-shadow: 0 0 5px rgba(255, 200, 100, 0.8), 0 1px 3px rgba(0,0,0,0.8);
  pointer-events: none;
  white-space: nowrap;
  background: rgba(0, 0, 0, 0.6);
  padding: 3px 8px;
  border-radius: 4px;
}

.edit-resize-handle {
  position: absolute;
  width: 24px;
  height: 24px;
  background: rgba(255, 200, 100, 0.3);
  border: 2px solid rgba(255, 200, 100, 0.7);
  border-radius: 50%;
  cursor: nwse-resize;
  z-index: 10;
}

.edit-resize-handle.nw { top: -12px; left: -12px; cursor: nwse-resize; }
.edit-resize-handle.ne { top: -12px; right: -12px; cursor: nesw-resize; }
.edit-resize-handle.sw { bottom: -12px; left: -12px; cursor: nesw-resize; }
.edit-resize-handle.se { bottom: -12px; right: -12px; cursor: nwse-resize; }

.edit-resize-handle:active {
  background: rgba(255, 100, 150, 0.6);
  border-color: rgba(255, 100, 150, 1);
}

.edit-footer {
  display: flex;
  justify-content: center;
  gap: 15px;
  padding: 20px;
  background: linear-gradient(to top, rgba(0, 20, 40, 0.9), transparent);
  flex-shrink: 0;
  position: relative;
  z-index: 10;
}

.edit-action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 20px;
  border: 1px solid;
  border-radius: 8px;
  font-family: 'Orbitron', sans-serif;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 2px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-action-btn.save {
  background: linear-gradient(135deg, rgba(0, 50, 40, 0.8), rgba(0, 30, 25, 0.9));
  border-color: rgba(0, 255, 200, 0.4);
  color: #0fa;
}

.edit-action-btn.save:active {
  background: linear-gradient(135deg, rgba(0, 80, 60, 0.9), rgba(0, 50, 40, 1));
  box-shadow: 0 0 20px rgba(0, 255, 200, 0.4);
}

.edit-action-btn.reset {
  background: linear-gradient(135deg, rgba(40, 35, 20, 0.8), rgba(25, 20, 10, 0.9));
  border-color: rgba(255, 200, 100, 0.4);
  color: rgba(255, 200, 100, 0.9);
}

.edit-action-btn.reset:active {
  background: linear-gradient(135deg, rgba(60, 50, 30, 0.9), rgba(40, 35, 20, 1));
  box-shadow: 0 0 20px rgba(255, 200, 100, 0.4);
}

.edit-action-btn.cancel {
  background: linear-gradient(135deg, rgba(40, 20, 30, 0.8), rgba(25, 10, 20, 0.9));
  border-color: rgba(255, 100, 100, 0.4);
  color: rgba(255, 120, 120, 0.9);
}

.edit-action-btn.cancel:active {
  background: linear-gradient(135deg, rgba(60, 30, 40, 0.9), rgba(40, 20, 30, 1));
  box-shadow: 0 0 20px rgba(255, 100, 100, 0.4);
}

/* Data Stream Text Decoration */
.pause-data-stream {
  position: absolute;
  font-family: 'Share Tech Mono', monospace;
  font-size: 8px;
  color: rgba(0, 255, 255, 0.3);
  letter-spacing: 2px;
  writing-mode: vertical-rl;
  z-index: 5;
}

.pause-data-stream.left {
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
}

.pause-data-stream.right {
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
}

/* =====================================================
   FUTURISTIC AI CONTROL HUB - Mode Select Screen
   Next-Gen Holographic Interface Design
   ===================================================== */

#mode-select-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at 50% 30%, rgba(10, 25, 47, 0.98) 0%, rgba(3, 7, 18, 0.99) 50%, #000 100%);
  display: none;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  z-index: 60;
  gap: 0;
  perspective: 2000px;
  overflow-y: auto;
  overflow-x: hidden;
  touch-action: pan-y;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  padding-top: 12px;
  padding-bottom: 10px;
  box-sizing: border-box;
}

/* Ambient Background Effects */
.mode-select-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

/* Volumetric Fog Effect */
.volumetric-fog {
  position: absolute;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(ellipse 80% 50% at 50% 100%, rgba(0, 180, 255, 0.08) 0%, transparent 60%),
    radial-gradient(ellipse 60% 40% at 30% 80%, rgba(0, 255, 255, 0.05) 0%, transparent 50%),
    radial-gradient(ellipse 60% 40% at 70% 90%, rgba(100, 200, 255, 0.04) 0%, transparent 50%);
  animation: fog-drift 20s ease-in-out infinite;
  z-index: 1;
}

@keyframes fog-drift {
  0%, 100% { opacity: 0.6; transform: translateY(0) scale(1); }
  50% { opacity: 0.8; transform: translateY(-20px) scale(1.05); }
}

/* Holographic Grid Floor */
.holo-grid {
  position: absolute;
  bottom: 0;
  left: -50%;
  width: 200%;
  height: 60%;
  background: 
    linear-gradient(90deg, transparent 49%, rgba(0, 200, 255, 0.03) 49.5%, rgba(0, 200, 255, 0.03) 50.5%, transparent 51%),
    linear-gradient(0deg, transparent 49%, rgba(0, 200, 255, 0.02) 49.5%, rgba(0, 200, 255, 0.02) 50.5%, transparent 51%);
  background-size: 60px 60px;
  transform: perspective(500px) rotateX(60deg) translateY(50%);
  transform-origin: center bottom;
  mask-image: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 80%);
  -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 80%);
  animation: grid-scroll 15s linear infinite;
  z-index: 1;
}

@keyframes grid-scroll {
  0% { background-position: 0 0; }
  100% { background-position: 0 60px; }
}

/* Floating Particles Canvas */
.particle-field {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: 2;
}

/* Scanning Lines Effect */
.scan-lines {
  position: absolute;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent 0px,
    transparent 2px,
    rgba(0, 200, 255, 0.015) 2px,
    rgba(0, 200, 255, 0.015) 4px
  );
  pointer-events: none;
  z-index: 3;
}

/* Horizontal Scanner */
.horizontal-scanner {
  position: absolute;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(0, 255, 255, 0.3) 20%, 
    rgba(0, 255, 255, 0.6) 50%, 
    rgba(0, 255, 255, 0.3) 80%, 
    transparent 100%);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 40px rgba(0, 255, 255, 0.2);
  animation: scan-horizontal 8s ease-in-out infinite;
  z-index: 4;
}

@keyframes scan-horizontal {
  0%, 100% { top: 10%; opacity: 0; }
  10% { opacity: 0.6; }
  50% { top: 90%; opacity: 0.4; }
  90% { opacity: 0.6; }
}

/* Ambient Light Orbs */
.ambient-orb {
  position: absolute;
  border-radius: 50%;
  filter: blur(60px);
  opacity: 0.3;
  animation: orb-float 10s ease-in-out infinite;
  z-index: 1;
}

.ambient-orb:nth-child(1) {
  width: 200px;
  height: 200px;
  background: radial-gradient(circle, rgba(0, 200, 255, 0.4) 0%, transparent 70%);
  top: 10%;
  left: -5%;
  animation-delay: 0s;
}

.ambient-orb:nth-child(2) {
  width: 150px;
  height: 150px;
  background: radial-gradient(circle, rgba(100, 180, 255, 0.3) 0%, transparent 70%);
  top: 60%;
  right: -5%;
  animation-delay: -3s;
}

.ambient-orb:nth-child(3) {
  width: 180px;
  height: 180px;
  background: radial-gradient(circle, rgba(0, 255, 200, 0.2) 0%, transparent 70%);
  bottom: 10%;
  left: 20%;
  animation-delay: -6s;
}

@keyframes orb-float {
  0%, 100% { transform: translate(0, 0) scale(1); }
  25% { transform: translate(10px, -20px) scale(1.1); }
  50% { transform: translate(-5px, 10px) scale(0.95); }
  75% { transform: translate(15px, 5px) scale(1.05); }
}

/* AI Core Visual - Upgraded */
.ai-core-container {
  position: relative;
  width: 70px;
  height: 70px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 10px;
  margin-top: 6px;
  z-index: 10;
  flex-shrink: 0;
}

.ai-ring {
  position: absolute;
  border-radius: 50%;
  border: 1px solid transparent;
}

.ai-ring:nth-child(1) {
  width: 100%;
  height: 100%;
  border: 2px solid rgba(0, 200, 255, 0.3);
  box-shadow: 0 0 20px rgba(0, 200, 255, 0.2), inset 0 0 20px rgba(0, 200, 255, 0.1);
  animation: spin-ai 12s linear infinite;
}

.ai-ring:nth-child(2) {
  width: 80%;
  height: 80%;
  border: 1px dashed rgba(0, 255, 255, 0.4);
  animation: spin-ai 8s linear infinite reverse;
}

.ai-ring:nth-child(3) {
  width: 60%;
  height: 60%;
  border: 1px solid rgba(100, 200, 255, 0.5);
  box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
  animation: spin-ai 6s linear infinite;
}

.ai-ring:nth-child(4) {
  width: 40%;
  height: 40%;
  border: 1px dotted rgba(0, 255, 255, 0.6);
  animation: spin-ai 4s linear infinite reverse;
}

.ai-core-center {
  width: 20px;
  height: 20px;
  background: radial-gradient(circle, #fff 0%, #0ff 40%, transparent 70%);
  border-radius: 50%;
  box-shadow: 0 0 20px #0ff, 0 0 40px rgba(0, 255, 255, 0.6), 0 0 60px rgba(0, 255, 255, 0.3);
  animation: pulse-ai-core 2s ease-in-out infinite;
  z-index: 2;
}

@keyframes spin-ai {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes pulse-ai-core {
  0%, 100% { transform: scale(0.9); opacity: 0.8; box-shadow: 0 0 20px #0ff, 0 0 40px rgba(0, 255, 255, 0.4); }
  50% { transform: scale(1.1); opacity: 1; box-shadow: 0 0 30px #0ff, 0 0 60px rgba(0, 255, 255, 0.6), 0 0 80px rgba(0, 255, 255, 0.3); }
}

/* System Status Text */
.system-status {
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px;
  color: rgba(0, 200, 255, 0.6);
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 12px;
  z-index: 10;
  position: relative;
  flex-shrink: 0;
}

.system-status::before,
.system-status::after {
  content: '//';
  margin: 0 10px;
  opacity: 0.4;
}

.status-dot {
  display: inline-block;
  width: 6px;
  height: 6px;
  background: #0f0;
  border-radius: 50%;
  margin-right: 8px;
  box-shadow: 0 0 10px #0f0;
  animation: status-blink 2s ease-in-out infinite;
}

@keyframes status-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* Mode Cards Container */
.mode-cards-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 10;
  width: 90%;
  max-width: 420px;
  position: relative;
  flex-shrink: 0;
  padding-bottom: 5px;
}

/* Holographic Panel - Mode Card */
.mode-card {
  width: 100%;
  min-height: 78px;
  background: linear-gradient(135deg, 
    rgba(10, 30, 50, 0.6) 0%, 
    rgba(5, 15, 30, 0.8) 50%,
    rgba(10, 30, 50, 0.6) 100%);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(0, 200, 255, 0.15);
  border-radius: 14px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 0;
  box-sizing: border-box;
  cursor: pointer;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  position: relative;
  overflow: hidden;
  box-shadow: 
    0 4px 30px rgba(0, 0, 0, 0.5),
    0 0 40px rgba(0, 150, 255, 0.05),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  transform: translateZ(0) rotateX(0deg);
  transform-style: preserve-3d;
}

/* Glass Refraction Edge */
.mode-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.2) 20%, 
    rgba(255, 255, 255, 0.4) 50%, 
    rgba(255, 255, 255, 0.2) 80%, 
    transparent 100%);
  z-index: 5;
}

/* Holographic Shimmer */
.mode-card::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 40%,
    rgba(255, 255, 255, 0.03) 45%,
    rgba(255, 255, 255, 0.05) 50%,
    rgba(255, 255, 255, 0.03) 55%,
    transparent 60%
  );
  transform: rotate(0deg);
  transition: transform 0.8s;
  z-index: 1;
}

.mode-card:active::after {
  transform: rotate(180deg);
}

/* Corner Brackets */
.mode-card-corner {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(0, 200, 255, 0.3);
  z-index: 3;
  transition: all 0.3s;
}

.mode-card-corner.tl { top: 8px; left: 8px; border-right: none; border-bottom: none; }
.mode-card-corner.tr { top: 8px; right: 8px; border-left: none; border-bottom: none; }
.mode-card-corner.bl { bottom: 8px; left: 8px; border-right: none; border-top: none; }
.mode-card-corner.br { bottom: 8px; right: 8px; border-left: none; border-top: none; }

.mode-card:active .mode-card-corner {
  width: 25px;
  height: 25px;
  border-color: rgba(0, 255, 255, 0.6);
}

.mode-card-inner {
  display: flex;
  flex-direction: row;
  align-items: center;
  width: 100%;
  height: 100%;
  padding: 14px 18px;
  box-sizing: border-box;
  z-index: 4;
  position: relative;
}

/* Energy Flow Background */
.mode-bg-glow {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(0, 200, 255, 0.02) 30%, 
    rgba(0, 200, 255, 0.04) 50%,
    rgba(0, 200, 255, 0.02) 70%, 
    transparent 100%);
  opacity: 0;
  transition: opacity 0.5s;
  z-index: 1;
}

.mode-card:active {
  transform: translateZ(20px) scale(0.98);
  border-color: rgba(0, 255, 255, 0.4);
  box-shadow: 
    0 8px 40px rgba(0, 0, 0, 0.6),
    0 0 60px rgba(0, 200, 255, 0.15),
    inset 0 0 30px rgba(0, 200, 255, 0.05);
}

.mode-card:active .mode-bg-glow {
  opacity: 1;
}

/* Holographic Icon Container */
.mode-icon {
  font-size: 18px;
  min-width: 44px;
  height: 44px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 12px;
  margin-right: 14px;
  border: 1px solid rgba(0, 200, 255, 0.2);
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  position: relative;
  overflow: hidden;
  box-shadow: 
    inset 0 0 20px rgba(0, 150, 255, 0.1),
    0 0 20px rgba(0, 150, 255, 0.1);
}

.mode-icon::before {
  content: '';
  position: absolute;
  top: -100%;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.1) 50%, 
    transparent 100%);
  animation: icon-shine 3s ease-in-out infinite;
}

@keyframes icon-shine {
  0%, 100% { top: -100%; }
  50% { top: 100%; }
}

.mode-info {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  gap: 6px;
}

.mode-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 15px;
  color: #fff;
  text-shadow: 0 0 10px currentColor, 0 0 20px rgba(255, 255, 255, 0.3);
  font-weight: 700;
  letter-spacing: 1.5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.mode-arrow {
  font-size: 14px;
  opacity: 0.5;
  transition: all 0.3s;
  font-family: 'Share Tech Mono', monospace;
}

.mode-card:active .mode-arrow {
  opacity: 1;
  transform: translateX(5px);
}

.mode-desc {
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px;
  color: rgba(150, 200, 255, 0.7);
  line-height: 1.4;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Mode Indicator Line */
.mode-indicator {
  position: absolute;
  left: 0;
  top: 15%;
  bottom: 15%;
  width: 3px;
  border-radius: 0 2px 2px 0;
  box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
  transition: all 0.3s;
}

.mode-card:active .mode-indicator {
  width: 4px;
  box-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
}

/* Training Style - Cyan */
.mode-card.training .mode-indicator { background: #4ECDC4; color: #4ECDC4; }
.mode-card.training .mode-icon { 
  color: #4ECDC4; 
  border-color: rgba(78, 205, 196, 0.4); 
  text-shadow: 0 0 15px #4ECDC4;
  box-shadow: inset 0 0 25px rgba(78, 205, 196, 0.15), 0 0 25px rgba(78, 205, 196, 0.15);
}
.mode-card.training .mode-title { color: #4ECDC4; }
.mode-card.training .mode-card-corner { border-color: rgba(78, 205, 196, 0.3); }
.mode-card.training:active { 
  border-color: rgba(78, 205, 196, 0.5);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6), 0 0 60px rgba(78, 205, 196, 0.2);
}

/* Battle Style - Magenta */
.mode-card.battle .mode-indicator { background: #ff0066; color: #ff0066; }
.mode-card.battle .mode-icon { 
  color: #ff0066; 
  border-color: rgba(255, 0, 102, 0.4); 
  text-shadow: 0 0 15px #ff0066;
  box-shadow: inset 0 0 25px rgba(255, 0, 102, 0.15), 0 0 25px rgba(255, 0, 102, 0.15);
}
.mode-card.battle .mode-title { color: #ff0066; }
.mode-card.battle .mode-card-corner { border-color: rgba(255, 0, 102, 0.3); }
.mode-card.battle:active { 
  border-color: rgba(255, 0, 102, 0.5);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6), 0 0 60px rgba(255, 0, 102, 0.2);
}

/* Tutorial Style - Gold */
.mode-card.tutorial .mode-indicator { background: #FFD700; color: #FFD700; }
.mode-card.tutorial .mode-icon { 
  color: #FFD700; 
  border-color: rgba(255, 215, 0, 0.4); 
  text-shadow: 0 0 15px #FFD700;
  box-shadow: inset 0 0 25px rgba(255, 215, 0, 0.15), 0 0 25px rgba(255, 215, 0, 0.15);
}
.mode-card.tutorial .mode-title { color: #FFD700; }
.mode-card.tutorial .mode-card-corner { border-color: rgba(255, 215, 0, 0.3); }
.mode-card.tutorial:active { 
  border-color: rgba(255, 215, 0, 0.5);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.2);
}

/* Friend Battle Style - Purple */
.mode-card.friend-battle .mode-indicator { background: #9b59b6; color: #9b59b6; }
.mode-card.friend-battle .mode-icon { 
  color: #9b59b6; 
  border-color: rgba(155, 89, 182, 0.4); 
  text-shadow: 0 0 15px #9b59b6;
  box-shadow: inset 0 0 25px rgba(155, 89, 182, 0.15), 0 0 25px rgba(155, 89, 182, 0.15);
}
.mode-card.friend-battle .mode-title { color: #9b59b6; }
.mode-card.friend-battle .mode-card-corner { border-color: rgba(155, 89, 182, 0.3); }
.mode-card.friend-battle:active { 
  border-color: rgba(155, 89, 182, 0.5);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6), 0 0 60px rgba(155, 89, 182, 0.2);
}

/* Friend Battle Locked State */
.mode-card.friend-battle.locked {
  opacity: 0.7;
  cursor: not-allowed;
}
.mode-card.friend-battle.locked .mode-icon {
  color: #666;
  border-color: rgba(100, 100, 100, 0.4);
  text-shadow: 0 0 10px rgba(100, 100, 100, 0.5);
  box-shadow: inset 0 0 20px rgba(100, 100, 100, 0.1), 0 0 20px rgba(100, 100, 100, 0.1);
}
.mode-card.friend-battle.locked .mode-title { color: #888; }
.mode-card.friend-battle.locked .mode-indicator { background: #666; color: #666; }
.mode-card.friend-battle.locked .mode-card-corner { border-color: rgba(100, 100, 100, 0.3); }

/* Lock Icon in Mode Card */
.mode-card .lock-icon {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 24px;
  height: 24px;
  color: #666;
  z-index: 20;
  filter: drop-shadow(0 0 5px rgba(100, 100, 100, 0.5));
  transition: all 0.3s ease;
}
.mode-card.friend-battle:not(.locked) .lock-icon {
  display: none;
}
.mode-card.friend-battle.locked .lock-icon {
  color: #888;
  animation: lock-pulse 2s ease-in-out infinite;
}
@keyframes lock-pulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

/* Friend Battle Unlocked State */
.mode-card.friend-battle:not(.locked) .mode-indicator { background: #9b59b6; color: #9b59b6; }
.mode-card.friend-battle:not(.locked) .mode-icon {
  color: #9b59b6; 
  border-color: rgba(155, 89, 182, 0.4); 
  text-shadow: 0 0 15px #9b59b6;
  box-shadow: inset 0 0 25px rgba(155, 89, 182, 0.15), 0 0 25px rgba(155, 89, 182, 0.15);
}
.mode-card.friend-battle:not(.locked) .mode-title { color: #9b59b6; }

/* Passcode Modal */
#passcode-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 300;
  backdrop-filter: blur(10px);
}

.passcode-container {
  background: linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 30, 0.98) 100%);
  border: 1px solid rgba(155, 89, 182, 0.4);
  border-radius: 15px;
  padding: 30px;
  width: 90%;
  max-width: 350px;
  position: relative;
  box-shadow: 0 0 40px rgba(155, 89, 182, 0.2), inset 0 0 30px rgba(155, 89, 182, 0.05);
}

.passcode-container::before {
  content: '';
  position: absolute;
  top: -1px;
  left: 10%;
  right: 10%;
  height: 2px;
  background: linear-gradient(90deg, transparent, rgba(155, 89, 182, 0.6), transparent);
}

.passcode-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  color: #9b59b6;
  text-align: center;
  margin-bottom: 20px;
  text-transform: uppercase;
  letter-spacing: 3px;
  text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
}

.passcode-icon {
  text-align: center;
  margin-bottom: 15px;
}

.passcode-icon svg {
  width: 40px;
  height: 40px;
  color: #9b59b6;
  filter: drop-shadow(0 0 10px rgba(155, 89, 182, 0.5));
}

.passcode-input {
  width: 100%;
  padding: 12px 15px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(155, 89, 182, 0.3);
  border-radius: 8px;
  color: #fff;
  font-family: 'Share Tech Mono', monospace;
  font-size: 16px;
  text-align: center;
  letter-spacing: 3px;
  outline: none;
  transition: all 0.3s ease;
  box-sizing: border-box;
}

.passcode-input:focus {
  border-color: rgba(155, 89, 182, 0.7);
  box-shadow: 0 0 15px rgba(155, 89, 182, 0.3);
}

.passcode-input::placeholder {
  color: rgba(155, 89, 182, 0.4);
  letter-spacing: 2px;
}

.passcode-error {
  color: #ff4757;
  font-size: 12px;
  text-align: center;
  margin-top: 10px;
  min-height: 18px;
  font-family: 'Share Tech Mono', monospace;
}

.passcode-buttons {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.passcode-btn {
  flex: 1;
  padding: 12px;
  border: 1px solid rgba(155, 89, 182, 0.4);
  border-radius: 8px;
  font-family: 'Orbitron', sans-serif;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.passcode-btn.cancel {
  background: transparent;
  color: #888;
  border-color: rgba(100, 100, 100, 0.4);
}

.passcode-btn.cancel:hover {
  background: rgba(100, 100, 100, 0.2);
  border-color: rgba(100, 100, 100, 0.6);
}

.passcode-btn.submit {
  background: linear-gradient(135deg, rgba(155, 89, 182, 0.3) 0%, rgba(155, 89, 182, 0.1) 100%);
  color: #9b59b6;
}

.passcode-btn.submit:hover {
  background: linear-gradient(135deg, rgba(155, 89, 182, 0.5) 0%, rgba(155, 89, 182, 0.2) 100%);
  box-shadow: 0 0 20px rgba(155, 89, 182, 0.3);
}

/* Data Stream Decoration */
.data-stream {
  position: absolute;
  font-family: 'Share Tech Mono', monospace;
  font-size: 8px;
  color: rgba(0, 200, 255, 0.3);
  writing-mode: vertical-rl;
  text-orientation: mixed;
  letter-spacing: 2px;
  animation: data-scroll 10s linear infinite;
  z-index: 5;
  pointer-events: none;
}

.data-stream.left {
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
}

.data-stream.right {
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
}

@keyframes data-scroll {
  0% { opacity: 0.2; }
  50% { opacity: 0.5; }
  100% { opacity: 0.2; }
}

/* Version Badge */
.version-badge {
  position: relative;
  margin-top: auto;
  padding-top: 3px;
  padding-bottom: 5px;
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  color: rgba(0, 200, 255, 0.4);
  letter-spacing: 1.5px;
  z-index: 10;
  flex-shrink: 0;
}

/* Ripple Effect on Touch */
.ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(0, 255, 255, 0.3);
  transform: scale(0);
  animation: ripple-effect 0.6s ease-out;
  pointer-events: none;
  z-index: 0;
}

@keyframes ripple-effect {
  to {
    transform: scale(4);
    opacity: 0;
  }
}

/* Boot Screen - Matrix Cyberpunk Style */
#boot-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 200;
  font-family: 'Share Tech Mono', monospace;
  overflow: hidden;
}

/* CRT Screen Effect Overlay */
#boot-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.3) 2px,
      rgba(0, 0, 0, 0.3) 4px
    );
  pointer-events: none;
  z-index: 100;
  animation: scanlineMove 8s linear infinite;
}

#boot-screen::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.4) 100%);
  pointer-events: none;
  z-index: 101;
}

@keyframes scanlineMove {
  0% { background-position: 0 0; }
  100% { background-position: 0 100px; }
}

/* Holographic Glyph Button Container */
#power-btn-container {
  position: relative;
  width: 160px;
  height: 160px;
  cursor: pointer;
  margin-bottom: 40px;
  z-index: 50;
}

/* Rotating Outer Ring - Code Fragments */
#glyph-outer-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  animation: rotateGlyph 20s linear infinite;
}

#glyph-inner-ring {
  position: absolute;
  width: 80%;
  height: 80%;
  top: 10%;
  left: 10%;
  animation: rotateGlyph 15s linear infinite reverse;
}

@keyframes rotateGlyph {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* SVG Glyph Rings */
.glyph-ring {
  fill: none;
  stroke-width: 1;
}

.glyph-ring-outer {
  stroke: rgba(0, 255, 70, 0.6);
  stroke-dasharray: 8 4 2 4;
  filter: drop-shadow(0 0 8px rgba(0, 255, 70, 0.8));
}

.glyph-ring-inner {
  stroke: rgba(0, 255, 70, 0.4);
  stroke-dasharray: 3 6 1 6;
  filter: drop-shadow(0 0 5px rgba(0, 255, 70, 0.6));
}

.glyph-ring-progress {
  fill: none;
  stroke: #00ff46;
  stroke-width: 3;
  stroke-dasharray: 283;
  stroke-dashoffset: 283;
  transition: stroke-dashoffset 0.1s linear;
  filter: drop-shadow(0 0 15px #00ff46) drop-shadow(0 0 30px #00ff46);
}

/* Holographic Code Fragments around button */
.code-fragment {
  position: absolute;
  font-size: 10px;
  color: rgba(0, 255, 70, 0.7);
  text-shadow: 0 0 5px #00ff46;
  animation: fragmentFloat 3s ease-in-out infinite;
  pointer-events: none;
}

.code-fragment:nth-child(odd) {
  animation-delay: -1.5s;
}

@keyframes fragmentFloat {
  0%, 100% { opacity: 0.4; transform: translateY(0); }
  50% { opacity: 0.9; transform: translateY(-5px); }
}

/* Center Glyph Symbol */
#power-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 70px;
  height: 70px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 12px;
  color: rgba(0, 255, 70, 0.8);
  text-shadow: 0 0 10px #00ff46, 0 0 20px #00ff46;
  background: 
    radial-gradient(circle, rgba(0, 255, 70, 0.1) 0%, transparent 70%);
  border-radius: 50%;
  animation: glyphPulse 2s ease-in-out infinite;
}

#power-icon::before {
  content: '⟁';
  font-size: 40px;
  filter: drop-shadow(0 0 10px #00ff46);
}

@keyframes glyphPulse {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(0, 255, 70, 0.3), inset 0 0 20px rgba(0, 255, 70, 0.1);
    transform: translate(-50%, -50%) scale(1);
  }
  50% { 
    box-shadow: 0 0 40px rgba(0, 255, 70, 0.5), inset 0 0 30px rgba(0, 255, 70, 0.2);
    transform: translate(-50%, -50%) scale(1.05);
  }
}

#power-btn-container:active #power-icon,
#power-btn-container.active #power-icon {
  color: #00ff46;
  text-shadow: 0 0 20px #00ff46, 0 0 40px #00ff46, 0 0 60px #00ff46;
  animation: glyphActive 0.2s ease-in-out infinite;
}

@keyframes glyphActive {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
}

/* Glitch Text Effect */
.boot-text {
  color: rgba(0, 255, 70, 0.9);
  font-size: 14px;
  letter-spacing: 3px;
  text-transform: uppercase;
  position: relative;
  z-index: 50;
  text-shadow: 
    0 0 10px #00ff46,
    0 0 20px #00ff46,
    0 0 30px rgba(0, 255, 70, 0.5);
  animation: glitchText 4s infinite;
}

.boot-text::before,
.boot-text::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.boot-text::before {
  color: #ff0040;
  animation: glitchBefore 3s infinite;
  clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
  transform: translateX(-2px);
  opacity: 0.8;
}

.boot-text::after {
  color: #00ffff;
  animation: glitchAfter 2s infinite;
  clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
  transform: translateX(2px);
  opacity: 0.8;
}

@keyframes glitchText {
  0%, 90%, 100% { opacity: 1; transform: translateX(0); }
  92% { opacity: 0.8; transform: translateX(-2px) skewX(-5deg); }
  94% { opacity: 1; transform: translateX(2px) skewX(2deg); }
  96% { opacity: 0.9; transform: translateX(-1px); }
}

@keyframes glitchBefore {
  0%, 85%, 100% { transform: translateX(0); }
  86% { transform: translateX(-5px); }
  88% { transform: translateX(3px); }
  90% { transform: translateX(-2px); }
}

@keyframes glitchAfter {
  0%, 80%, 100% { transform: translateX(0); }
  82% { transform: translateX(5px); }
  84% { transform: translateX(-3px); }
  86% { transform: translateX(2px); }
}

.boot-text.blink {
  color: #00ff46;
  text-shadow: 
    0 0 10px #00ff46,
    0 0 20px #00ff46,
    0 0 40px #00ff46,
    0 0 80px rgba(0, 255, 70, 0.5);
  animation: glitchBlink 0.1s infinite;
}

@keyframes glitchBlink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Matrix Digital Rain Canvas */
#matrix-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}

#boot-screen.matrix-active {
  background-color: #000 !important;
}

#boot-screen.matrix-active #power-btn-container,
#boot-screen.matrix-active .boot-text {
  z-index: 50;
  position: relative;
}

/* Holographic Distortion Overlay */
.holo-distortion {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    linear-gradient(90deg, 
      transparent 0%, 
      rgba(0, 255, 70, 0.03) 50%, 
      transparent 100%);
  animation: holoScan 3s linear infinite;
  pointer-events: none;
  z-index: 45;
}

@keyframes holoScan {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.matrix-fade-out {
  animation: matrixFadeOut 0.5s ease-out forwards;
}

@keyframes matrixFadeOut {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* Additional Glow Effects */
.glow-particles {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 40;
}

/* System Info Panel - Hacking Style */
#system-info-panel {
  position: absolute;
  bottom: 15px;
  left: 15px;
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  color: rgba(0, 255, 70, 0.7);
  text-align: left;
  z-index: 60;
  background: rgba(0, 10, 5, 0.6);
  padding: 8px 12px;
  border-left: 2px solid rgba(0, 255, 70, 0.5);
  border-radius: 0 4px 4px 0;
  max-width: 280px;
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
  letter-spacing: 0.5px;
  line-height: 1.5;
  text-shadow: 0 0 5px rgba(0, 255, 70, 0.5);
  animation: sysInfoFlicker 4s infinite;
}

@keyframes sysInfoFlicker {
  0%, 92%, 100% { opacity: 0.9; }
  93% { opacity: 0.7; }
  95% { opacity: 0.85; }
  97% { opacity: 0.75; }
}

#system-info-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 255, 70, 0.02) 2px,
    rgba(0, 255, 70, 0.02) 4px
  );
  pointer-events: none;
  z-index: 1;
}

.sys-info-header {
  color: rgba(0, 255, 70, 0.9);
  font-size: 10px;
  font-weight: bold;
  margin-bottom: 5px;
  letter-spacing: 1px;
  text-shadow: 0 0 8px rgba(0, 255, 70, 0.8);
  animation: sysHeaderPulse 2s ease-in-out infinite;
}

@keyframes sysHeaderPulse {
  0%, 100% { text-shadow: 0 0 8px rgba(0, 255, 70, 0.8); }
  50% { text-shadow: 0 0 12px rgba(0, 255, 70, 1), 0 0 20px rgba(0, 255, 70, 0.5); }
}

.sys-info-line {
  color: rgba(0, 255, 70, 0.6);
  font-size: 8px;
  margin: 2px 0;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  position: relative;
  padding-left: 8px;
}

.sys-info-line::before {
  content: '>';
  position: absolute;
  left: 0;
  color: rgba(0, 255, 70, 0.4);
}

.sys-info-line.highlight {
  color: rgba(255, 100, 100, 0.8);
  text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
}

.sys-info-line.active {
  animation: sysLineActive 0.3s ease-out;
}

@keyframes sysLineActive {
  0% { background: rgba(0, 255, 70, 0.3); }
  100% { background: transparent; }
}

.sys-info-status {
  color: rgba(0, 255, 70, 0.5);
  font-size: 8px;
  margin-top: 5px;
  animation: statusBlink 1.5s ease-in-out infinite;
}

@keyframes statusBlink {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}

/* Tutorial Modal */
#tutorial-modal {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(5px);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 200;
  animation: fadeIn 0.3s ease-out;
}

.tutorial-window {
  width: 90%;
  max-width: 500px;
  background: rgba(0, 20, 40, 0.95);
  border: 1px solid #0ff;
  border-radius: 15px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
}

.ai-monitor {
  background: #000;
  border: 1px solid #333;
  border-radius: 5px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 15px;
  position: relative;
  overflow: hidden;
}

.scan-line {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background: rgba(0, 255, 255, 0.3);
  animation: scan 2s linear infinite;
  pointer-events: none;
}
@keyframes scan { 0% { top: 0; } 100% { top: 100%; } }

.ai-face-small {
  width: 40px;
  height: 40px;
  border: 2px solid #0ff;
  border-radius: 50%;
  position: relative;
  flex-shrink: 0;
  box-shadow: 0 0 10px #0ff;
}
.ai-face-small::before, .ai-face-small::after {
  content: '';
  position: absolute;
  top: 40%;
  width: 8px;
  height: 8px;
  background: #0ff;
  border-radius: 50%;
  animation: blink 3s infinite;
}
.ai-face-small::before { left: 8px; }
.ai-face-small::after { right: 8px; }

.ai-message-box {
  flex-grow: 1;
  font-family: 'Share Tech Mono', monospace;
  font-size: 14px;
  color: #0ff;
  line-height: 1.4;
  text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
}

.tutorial-display-area {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  padding: 20px;
  min-height: 200px;
  color: #fff;
  font-family: 'Share Tech Mono', monospace;
  display: flex;
  flex-direction: column;
}

.tutorial-display-area h3 {
  color: #0ff;
  margin-top: 0;
  margin-bottom: 15px;
  font-family: 'Orbitron', sans-serif;
  border-bottom: 1px solid rgba(0, 255, 255, 0.3);
  padding-bottom: 10px;
  font-size: 20px;
}

#tutorial-preview-container {
  width: 100%;
  height: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  transition: height 0.3s;
}

#tutorial-preview-container.active {
  height: 160px;
}

#tutorial-step-content {
  font-size: 15px;
  line-height: 1.6;
  color: #ddd;
}

#tutorial-step-content ul {
  padding-left: 20px; 
  margin: 10px 0;
}
#tutorial-step-content li {
  margin-bottom: 10px;
}

.tutorial-nav {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.nav-btn {
  padding: 12px 25px;
  border-radius: 25px;
  font-family: 'Orbitron', sans-serif;
  font-weight: bold;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  border: none;
}

.nav-btn.primary {
  background: #0ff;
  color: #000;
  box-shadow: 0 0 10px #0ff;
}
.nav-btn.primary:active {
  transform: scale(0.95);
  box-shadow: 0 0 20px #0ff;
}

.nav-btn.secondary {
  background: transparent;
  color: #aaa;
  border: 1px solid #555;
}
.nav-btn.secondary:active {
  background: rgba(255, 255, 255, 0.1);
}

/* Mode Transition Animations - Enhanced */
@keyframes suck-in {
  0% { 
    opacity: 1; 
    transform: translateY(0) scale(1) rotateX(0deg); 
    filter: blur(0px);
  }
  30% {
    opacity: 0.8;
    transform: translateY(-30px) scale(0.9) rotateX(10deg);
    filter: blur(1px);
  }
  100% { 
    opacity: 0; 
    transform: translateY(-200px) scale(0.01) rotateX(45deg); 
    filter: blur(10px);
  }
}

@keyframes core-warp {
  0% { 
    transform: scale(1) rotate(0deg); 
    filter: drop-shadow(0 0 15px #0ff) brightness(1);
  }
  20% {
    transform: scale(1.2) rotate(90deg);
    filter: drop-shadow(0 0 30px #0ff) brightness(1.3);
  }
  40% { 
    transform: scale(1.8) rotate(180deg); 
    filter: drop-shadow(0 0 50px #0ff) brightness(1.8);
  }
  100% { 
    transform: scale(30) rotate(720deg); 
    opacity: 0; 
    filter: brightness(15) blur(5px);
  }
}

.sucking {
  animation: suck-in 0.7s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
  pointer-events: none;
}

.core-warp {
  animation: core-warp 0.8s cubic-bezier(0.7, 0, 0.84, 0) forwards;
  z-index: 100;
}

/* Card Entry Animation */
.mode-card {
  animation: card-appear 0.6s ease-out backwards;
}

.mode-card:nth-child(1) { animation-delay: 0.1s; }
.mode-card:nth-child(2) { animation-delay: 0.2s; }
.mode-card:nth-child(3) { animation-delay: 0.3s; }

@keyframes card-appear {
  0% {
    opacity: 0;
    transform: translateY(30px) scale(0.9);
    filter: blur(5px);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
    filter: blur(0px);
  }
}

/* =====================================================
   HEXA Title Logo - Premium Holographic 3D Design
   ===================================================== */

.hexa-title-container {
  position: relative;
  margin-bottom: 5px;
  perspective: 1500px;
  z-index: 10;
  padding: 8px 0;
  flex-shrink: 0;
}

/* Holographic Base Plate */
.hexa-title-container::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 320px;
  height: 100px;
  background: radial-gradient(ellipse at center, 
    rgba(0, 200, 255, 0.1) 0%, 
    transparent 70%);
  filter: blur(20px);
  z-index: -1;
}

.hexa-logo {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
  font-family: 'Orbitron', sans-serif;
  font-size: 62px;
  font-weight: 900;
  letter-spacing: 12px;
  position: relative;
  transform-style: preserve-3d;
  animation: logo-float 6s ease-in-out infinite;
}

@keyframes logo-float {
  0%, 100% { transform: translateY(0) rotateX(0deg); }
  50% { transform: translateY(-5px) rotateX(2deg); }
}

.hexa-letter {
  position: relative;
  display: inline-block;
  color: #fff;
  text-shadow: 
    0 0 15px rgba(0, 220, 255, 1),
    0 0 30px rgba(0, 200, 255, 0.9),
    0 0 50px rgba(0, 180, 255, 0.7),
    0 0 100px rgba(0, 150, 255, 0.5),
    0 0 150px rgba(0, 120, 255, 0.3),
    0 3px 0 rgba(0, 100, 150, 0.9);
  animation: hexa-idle 4s ease-in-out infinite;
  transform-style: preserve-3d;
  transition: all 0.3s;
  filter: brightness(1.1);
}

/* 3D Depth Effect */
.hexa-letter::before {
  content: attr(data-letter);
  position: absolute;
  top: 2px;
  left: 2px;
  color: transparent;
  text-shadow: 
    0 0 30px rgba(0, 255, 255, 0.5),
    0 0 60px rgba(0, 200, 255, 0.3);
  opacity: 0.5;
  z-index: -1;
  filter: blur(2px);
}

/* Chromatic Aberration Effect */
.hexa-letter::after {
  content: attr(data-letter);
  position: absolute;
  top: 0;
  left: 0;
  color: transparent;
  background: linear-gradient(180deg, 
    rgba(255, 255, 255, 0.3) 0%, 
    transparent 50%);
  -webkit-background-clip: text;
  background-clip: text;
  opacity: 0;
  animation: chromatic-flash 8s infinite;
}

@keyframes chromatic-flash {
  0%, 90%, 100% { opacity: 0; transform: translate(0, 0); }
  92% { opacity: 0.8; transform: translate(-2px, 0); filter: hue-rotate(90deg); }
  94% { opacity: 0; transform: translate(2px, 0); }
  96% { opacity: 0.6; transform: translate(0, -1px); filter: hue-rotate(-90deg); }
}

/* Letter Variations */
.hexa-letter.letter-h { animation-delay: 0s; }
.hexa-letter.letter-e { animation-delay: 0.1s; }
.hexa-letter.letter-x { animation-delay: 0.2s; }
.hexa-letter.letter-a { animation-delay: 0.3s; }

@keyframes hexa-idle {
  0%, 100% { 
    transform: translateY(0) rotateY(0deg) scale(1);
    filter: brightness(1);
  }
  25% { 
    filter: brightness(1.1);
  }
  50% { 
    transform: translateY(-3px) rotateY(2deg) scale(1.02);
    filter: brightness(1.15);
  }
  75% { 
    filter: brightness(1.05);
  }
}

/* Glitch Effect (Subtle) */
.hexa-letter.letter-x {
  animation: hexa-idle 4s ease-in-out infinite, x-micro-glitch 10s ease-in-out infinite;
}

@keyframes x-micro-glitch {
  0%, 95%, 100% { 
    transform: translateY(0) skewX(0deg);
    filter: brightness(1);
  }
  96% { 
    transform: translateY(-1px) skewX(3deg);
    filter: brightness(1.3) hue-rotate(10deg);
  }
  97% { 
    transform: translateY(1px) skewX(-2deg);
    filter: brightness(1.5) hue-rotate(-10deg);
  }
  98% { 
    transform: translateY(0) skewX(1deg);
    filter: brightness(1.2);
  }
}

/* Hexagonal Frame Around Logo */
.hexa-frame {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 280px;
  height: 90px;
  pointer-events: none;
}

.hexa-frame svg {
  width: 100%;
  height: 100%;
  overflow: visible;
}

.hexa-frame-path {
  fill: none;
  stroke: rgba(0, 200, 255, 0.2);
  stroke-width: 1;
  stroke-dasharray: 5 10;
  animation: frame-dash 20s linear infinite;
}

@keyframes frame-dash {
  to { stroke-dashoffset: -100; }
}

/* Particle Field */
.hexa-particles {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 350px;
  height: 150px;
  pointer-events: none;
  overflow: visible;
}

.hexa-particle {
  position: absolute;
  width: 3px;
  height: 3px;
  background: #0ff;
  border-radius: 50%;
  opacity: 0;
  box-shadow: 0 0 8px #0ff, 0 0 15px rgba(0, 255, 255, 0.5);
  animation: particle-float 4s ease-in-out infinite;
}

@keyframes particle-float {
  0%, 100% { opacity: 0; transform: translateY(20px) scale(0); }
  20% { opacity: 0.8; transform: translateY(0) scale(1); }
  80% { opacity: 0.6; transform: translateY(-20px) scale(0.8); }
}

/* Neural Background */
.hexa-neural-bg {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 200px;
  opacity: 0.1;
  background: 
    radial-gradient(circle at 20% 40%, rgba(0, 200, 255, 0.4) 0%, transparent 25%),
    radial-gradient(circle at 80% 60%, rgba(0, 200, 255, 0.4) 0%, transparent 25%),
    radial-gradient(circle at 50% 30%, rgba(100, 200, 255, 0.3) 0%, transparent 20%),
    radial-gradient(circle at 50% 70%, rgba(100, 200, 255, 0.3) 0%, transparent 20%);
  animation: neural-pulse 4s ease-in-out infinite;
  pointer-events: none;
  z-index: -1;
  filter: blur(2px);
}

@keyframes neural-pulse {
  0%, 100% { opacity: 0.08; transform: translate(-50%, -50%) scale(1); }
  50% { opacity: 0.15; transform: translate(-50%, -50%) scale(1.1); }
}

/* Scanline Overlay */
.hexa-scanline {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    transparent 0%,
    rgba(0, 200, 255, 0.02) 50%,
    transparent 100%
  );
  background-size: 100% 3px;
  animation: scanline-move 3s linear infinite;
  pointer-events: none;
  opacity: 0.4;
}

@keyframes scanline-move {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100%); }
}

/* Data Fragments */
.hexa-data-fragment {
  position: absolute;
  font-family: 'Share Tech Mono', monospace;
  font-size: 9px;
  color: rgba(0, 200, 255, 0.5);
  opacity: 0;
  pointer-events: none;
  animation: data-float 5s ease-in-out infinite;
  text-shadow: 0 0 5px currentColor;
}

.hexa-data-fragment:nth-child(1) { top: -20px; left: 5%; animation-delay: 0s; }
.hexa-data-fragment:nth-child(2) { top: -15px; right: 10%; animation-delay: 1.5s; }
.hexa-data-fragment:nth-child(3) { bottom: -18px; left: 15%; animation-delay: 2.5s; }
.hexa-data-fragment:nth-child(4) { bottom: -20px; right: 5%; animation-delay: 0.8s; }

@keyframes data-float {
  0%, 100% { opacity: 0; transform: translateY(5px); }
  20%, 80% { opacity: 0.7; }
  50% { opacity: 1; transform: translateY(-8px); }
}

/* Holographic Refraction */
.hexa-letter.refract-active {
  animation: refract-edge 0.2s ease-out;
}

@keyframes refract-edge {
  0% { 
    text-shadow: 
      0 0 15px rgba(0, 255, 255, 1),
      -4px 0 0 rgba(255, 0, 100, 0.6),
      4px 0 0 rgba(0, 255, 255, 0.6);
  }
  100% { 
    text-shadow: 
      0 0 10px rgba(0, 220, 255, 0.9),
      0 0 20px rgba(0, 200, 255, 0.7),
      0 0 40px rgba(0, 180, 255, 0.5);
  }
}

/* =====================================================
   ULTRA FUTURISTIC DESIGN OVERHAUL 2024
   Next-Gen Cyberpunk / Neo-Tokyo Aesthetic
   ===================================================== */

/* Global Futuristic Variables */
:root {
  --neo-cyan: #00f7ff;
  --neo-magenta: #ff00ff;
  --neo-purple: #a855f7;
  --neo-gold: #ffd700;
  --neo-blue: #3b82f6;
  --neo-green: #10b981;
  --holo-gradient: linear-gradient(135deg, var(--neo-cyan), var(--neo-magenta), var(--neo-purple));
  --glass-bg: rgba(10, 20, 40, 0.85);
  --glass-border: rgba(0, 247, 255, 0.25);
}

/* Holographic Shimmer Effect - Global */
@keyframes holo-shimmer {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Futuristic Glow Pulse */
@keyframes neo-glow-pulse {
  0%, 100% { 
    filter: drop-shadow(0 0 10px var(--neo-cyan)) drop-shadow(0 0 20px var(--neo-cyan));
  }
  50% { 
    filter: drop-shadow(0 0 20px var(--neo-cyan)) drop-shadow(0 0 40px var(--neo-magenta));
  }
}

/* Circuit Pattern Animation */
@keyframes circuit-flow {
  0% { stroke-dashoffset: 1000; }
  100% { stroke-dashoffset: 0; }
}

/* Data Stream Rain Effect */
@keyframes data-rain {
  0% { transform: translateY(-100vh); opacity: 0; }
  10% { opacity: 1; }
  90% { opacity: 1; }
  100% { transform: translateY(100vh); opacity: 0; }
}

/* Quantum Flicker Effect */
@keyframes quantum-flicker {
  0%, 100% { opacity: 1; }
  5% { opacity: 0.3; }
  10% { opacity: 1; }
  15% { opacity: 0.5; }
  20% { opacity: 1; }
  92% { opacity: 1; }
  94% { opacity: 0.4; }
  96% { opacity: 1; }
}

/* Holographic Text Effect */
.holo-text {
  background: linear-gradient(90deg, 
    var(--neo-cyan) 0%, 
    var(--neo-magenta) 25%, 
    var(--neo-cyan) 50%, 
    var(--neo-purple) 75%, 
    var(--neo-cyan) 100%);
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: holo-shimmer 3s linear infinite;
}

/* Enhanced Boot Screen */
#boot-screen {
  background: linear-gradient(135deg, #000814 0%, #001d3d 50%, #000814 100%);
}

#boot-screen::before {
  background: 
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 247, 255, 0.03) 2px,
      rgba(0, 247, 255, 0.03) 4px
    ),
    repeating-linear-gradient(
      90deg,
      transparent,
      transparent 4px,
      rgba(0, 247, 255, 0.02) 4px,
      rgba(0, 247, 255, 0.02) 8px
    );
}

/* Futuristic Power Button Enhancement */
#power-btn-container {
  position: relative;
}

#power-btn-container::after {
  content: '';
  position: absolute;
  inset: -20px;
  background: radial-gradient(circle, rgba(0, 247, 255, 0.15) 0%, transparent 70%);
  animation: neo-glow-pulse 2s ease-in-out infinite;
  pointer-events: none;
  border-radius: 50%;
}

.glyph-ring-outer {
  stroke: var(--neo-cyan) !important;
  filter: drop-shadow(0 0 10px var(--neo-cyan)) drop-shadow(0 0 20px var(--neo-magenta));
}

.glyph-ring-inner {
  stroke: var(--neo-magenta) !important;
  filter: drop-shadow(0 0 8px var(--neo-magenta));
}

.glyph-ring-progress {
  stroke: var(--neo-gold) !important;
  filter: drop-shadow(0 0 15px var(--neo-gold)) drop-shadow(0 0 30px var(--neo-cyan));
}

#power-icon {
  color: var(--neo-cyan) !important;
  text-shadow: 
    0 0 10px var(--neo-cyan),
    0 0 20px var(--neo-cyan),
    0 0 40px var(--neo-magenta);
}

#power-icon::before {
  content: '◈';
  filter: drop-shadow(0 0 10px var(--neo-cyan));
}

/* Enhanced Boot Text */
.boot-text {
  color: var(--neo-cyan) !important;
  text-shadow: 
    0 0 10px var(--neo-cyan),
    0 0 20px var(--neo-cyan),
    0 0 40px var(--neo-magenta),
    0 0 80px rgba(0, 247, 255, 0.5);
  animation: quantum-flicker 4s infinite, glitchText 4s infinite;
}

/* Futuristic Mode Select Screen */
#mode-select-screen {
  background: 
    radial-gradient(ellipse at 20% 80%, rgba(168, 85, 247, 0.15) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 20%, rgba(0, 247, 255, 0.1) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(10, 25, 47, 0.98) 0%, rgba(3, 7, 18, 0.99) 50%, #000 100%);
}

/* Enhanced Mode Cards - Glassmorphism */
.mode-card {
  background: linear-gradient(135deg, 
    rgba(20, 40, 80, 0.4) 0%, 
    rgba(10, 20, 50, 0.6) 50%,
    rgba(20, 40, 80, 0.4) 100%) !important;
  backdrop-filter: blur(25px) saturate(150%);
  -webkit-backdrop-filter: blur(25px) saturate(150%);
  border: 1px solid rgba(0, 247, 255, 0.2) !important;
  box-shadow: 
    0 8px 32px rgba(0, 0, 0, 0.4),
    0 0 50px rgba(0, 247, 255, 0.05),
    inset 0 0 20px rgba(0, 247, 255, 0.03),
    inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.mode-card:active {
  transform: translateY(-3px) scale(0.98) !important;
  box-shadow: 
    0 15px 40px rgba(0, 0, 0, 0.5),
    0 0 80px rgba(0, 247, 255, 0.15),
    inset 0 0 30px rgba(0, 247, 255, 0.08) !important;
}

/* Enhanced Mode Card Corners */
.mode-card-corner {
  border-width: 2px !important;
  transition: all 0.3s ease;
}

.mode-card.training .mode-card-corner { border-color: var(--neo-green) !important; }
.mode-card.battle .mode-card-corner { border-color: var(--neo-magenta) !important; }
.mode-card.tutorial .mode-card-corner { border-color: var(--neo-gold) !important; }
.mode-card.friend-battle .mode-card-corner { border-color: var(--neo-purple) !important; }

.mode-card:active .mode-card-corner {
  width: 30px !important;
  height: 30px !important;
  box-shadow: 0 0 15px currentColor;
}

/* Enhanced Mode Icons */
.mode-icon {
  background: linear-gradient(135deg, 
    rgba(0, 247, 255, 0.1) 0%, 
    rgba(168, 85, 247, 0.05) 100%) !important;
  border: 1px solid rgba(0, 247, 255, 0.3) !important;
  box-shadow: 
    inset 0 0 25px rgba(0, 247, 255, 0.1),
    0 0 25px rgba(0, 247, 255, 0.15) !important;
}

/* Futuristic Start Screen */
#start-screen {
  background: 
    radial-gradient(ellipse at 30% 70%, rgba(255, 0, 102, 0.1) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 30%, rgba(0, 247, 255, 0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(10, 25, 47, 0.98) 0%, rgba(3, 7, 18, 0.99) 50%, #000 100%);
}

/* Enhanced Title */
.title {
  font-family: 'Orbitron', sans-serif;
  background: linear-gradient(135deg, 
    #fff 0%, 
    var(--neo-cyan) 25%, 
    #fff 50%, 
    var(--neo-magenta) 75%, 
    #fff 100%);
  background-size: 300% 300%;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: holo-shimmer 4s ease infinite;
  filter: drop-shadow(0 0 30px rgba(0, 247, 255, 0.5));
}

/* Enhanced AI Panel Container */
.cpu-setting-container {
  background: linear-gradient(135deg, 
    rgba(20, 40, 80, 0.5) 0%, 
    rgba(10, 20, 50, 0.7) 50%,
    rgba(20, 40, 80, 0.5) 100%) !important;
  backdrop-filter: blur(30px) saturate(150%);
  -webkit-backdrop-filter: blur(30px) saturate(150%);
  border: 1px solid rgba(255, 0, 102, 0.25) !important;
  box-shadow: 
    0 8px 40px rgba(0, 0, 0, 0.5),
    0 0 60px rgba(255, 0, 102, 0.08),
    inset 0 0 30px rgba(255, 0, 102, 0.03),
    inset 0 1px 0 rgba(255, 255, 255, 0.08) !important;
}

/* Futuristic Slider */
#start-screen input[type=range] {
  background: linear-gradient(90deg, 
    rgba(0, 247, 255, 0.2) 0%, 
    rgba(255, 0, 102, 0.3) 50%, 
    rgba(168, 85, 247, 0.2) 100%) !important;
  border: 1px solid rgba(0, 247, 255, 0.3) !important;
}

#start-screen input[type=range]::-webkit-slider-thumb {
  background: linear-gradient(135deg, #fff 0%, var(--neo-cyan) 50%, var(--neo-magenta) 100%) !important;
  box-shadow: 
    0 0 15px var(--neo-cyan), 
    0 0 30px var(--neo-magenta),
    0 0 45px rgba(0, 247, 255, 0.5) !important;
}

/* Enhanced Start Button */
.start-btn {
  background: linear-gradient(135deg, 
    rgba(255, 0, 102, 0.15) 0%, 
    rgba(168, 85, 247, 0.2) 50%,
    rgba(255, 0, 102, 0.15) 100%) !important;
  border: 2px solid rgba(255, 0, 102, 0.5) !important;
  box-shadow: 
    0 0 30px rgba(255, 0, 102, 0.3), 
    inset 0 0 20px rgba(255, 0, 102, 0.15),
    0 8px 30px rgba(0, 0, 0, 0.5) !important;
  text-shadow: 0 0 15px #fff, 0 0 30px var(--neo-magenta);
  position: relative;
  overflow: hidden;
}

.start-btn::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, 
    transparent 30%, 
    rgba(255, 255, 255, 0.1) 50%, 
    transparent 70%);
  animation: btn-shine 2s ease-in-out infinite;
}

.start-btn:active {
  background: linear-gradient(135deg, 
    rgba(255, 0, 102, 0.4) 0%, 
    rgba(168, 85, 247, 0.5) 50%,
    rgba(255, 0, 102, 0.4) 100%) !important;
  box-shadow: 
    0 0 50px rgba(255, 0, 102, 0.6), 
    inset 0 0 30px rgba(255, 0, 102, 0.3),
    0 4px 15px rgba(0, 0, 0, 0.5) !important;
}

/* Futuristic Pause Overlay */
#pause-overlay {
  background: 
    radial-gradient(ellipse at 50% 50%, rgba(0, 20, 50, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
}

.pause-title {
  background: linear-gradient(90deg, 
    var(--neo-cyan) 0%, 
    #fff 50%, 
    var(--neo-cyan) 100%);
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: holo-shimmer 2s linear infinite;
  filter: drop-shadow(0 0 20px var(--neo-cyan));
}

/* Enhanced Game Over Modal */
#game-over-modal {
  background: 
    radial-gradient(ellipse at 50% 30%, rgba(10, 25, 47, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
}

.result-card {
  background: linear-gradient(135deg, 
    rgba(20, 40, 80, 0.6) 0%, 
    rgba(10, 20, 50, 0.8) 50%,
    rgba(20, 40, 80, 0.6) 100%) !important;
  backdrop-filter: blur(30px) saturate(150%);
  -webkit-backdrop-filter: blur(30px) saturate(150%);
  border: 1px solid rgba(0, 247, 255, 0.3) !important;
  box-shadow: 
    0 0 50px rgba(0, 247, 255, 0.15),
    inset 0 0 30px rgba(0, 247, 255, 0.05),
    0 20px 60px rgba(0, 0, 0, 0.5) !important;
}

.result-title {
  background: linear-gradient(90deg, 
    var(--neo-cyan) 0%, 
    var(--neo-cyan) 10%,
    var(--neo-magenta) 50%, 
    var(--neo-cyan) 90%,
    var(--neo-cyan) 100%);
  background-size: 300% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: holo-shimmer 3s linear infinite;
  overflow: visible;
  padding: 0 10px;
  display: inline-block;
  width: auto;
}

/* Futuristic Rank Display */
.rank-value {
  background: linear-gradient(135deg, 
    var(--neo-gold) 0%, 
    #fff 50%, 
    var(--neo-gold) 100%);
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: holo-shimmer 2s linear infinite;
  filter: drop-shadow(0 0 15px var(--neo-gold));
}

/* Enhanced Metric Bars */
.metric-bar-fill {
  background: linear-gradient(90deg, 
    var(--neo-cyan) 0%, 
    var(--neo-magenta) 50%, 
    var(--neo-purple) 100%) !important;
  box-shadow: 0 0 10px var(--neo-cyan), 0 0 20px var(--neo-magenta) !important;
}

/* Futuristic Restart Button */
.restart-btn {
  background: linear-gradient(135deg, 
    rgba(78, 205, 196, 0.2) 0%, 
    rgba(0, 247, 255, 0.3) 100%) !important;
  border: 2px solid var(--neo-cyan) !important;
  box-shadow: 0 0 20px rgba(0, 247, 255, 0.3), 0 4px 15px rgba(0, 0, 0, 0.4) !important;
  text-shadow: 0 0 10px var(--neo-cyan);
}

.restart-btn:active {
  background: linear-gradient(135deg, 
    rgba(78, 205, 196, 0.4) 0%, 
    rgba(0, 247, 255, 0.5) 100%) !important;
  box-shadow: 0 0 40px rgba(0, 247, 255, 0.5), 0 2px 10px rgba(0, 0, 0, 0.4) !important;
}

/* Holographic HEXA Title Enhancement */
.hexa-title-container {
  position: relative;
}

.hexa-title-container::before {
  content: '';
  position: absolute;
  inset: -10px;
  background: radial-gradient(ellipse at 50% 50%, 
    rgba(0, 247, 255, 0.1) 0%, 
    transparent 70%);
  animation: neo-glow-pulse 3s ease-in-out infinite;
  pointer-events: none;
  z-index: -1;
}

.hexa-letter {
  text-shadow: 
    0 0 15px var(--neo-cyan),
    0 0 30px var(--neo-cyan),
    0 0 60px var(--neo-magenta),
    0 0 90px rgba(168, 85, 247, 0.5) !important;
}

/* Enhanced AI Core */
.ai-core-center {
  background: radial-gradient(circle, 
    #fff 0%, 
    var(--neo-cyan) 30%, 
    var(--neo-magenta) 60%, 
    transparent 100%) !important;
  box-shadow: 
    0 0 30px var(--neo-cyan), 
    0 0 60px var(--neo-magenta), 
    0 0 90px rgba(0, 247, 255, 0.5) !important;
}

.ai-ring:nth-child(1) {
  border-color: rgba(0, 247, 255, 0.4) !important;
  box-shadow: 0 0 25px rgba(0, 247, 255, 0.3) !important;
}

.ai-ring:nth-child(2) {
  border-color: rgba(255, 0, 255, 0.3) !important;
}

.ai-ring:nth-child(3) {
  border-color: rgba(168, 85, 247, 0.5) !important;
  box-shadow: 0 0 20px rgba(168, 85, 247, 0.4) !important;
}

/* Futuristic Tutorial Modal */
.tutorial-window {
  background: linear-gradient(135deg, 
    rgba(20, 40, 80, 0.95) 0%, 
    rgba(10, 20, 50, 0.98) 100%) !important;
  border: 1px solid rgba(0, 247, 255, 0.3) !important;
  box-shadow: 
    0 0 50px rgba(0, 247, 255, 0.15),
    inset 0 0 30px rgba(0, 247, 255, 0.05) !important;
}

/* Cyber Grid Background Pattern */
.cyber-grid {
  position: absolute;
  inset: 0;
  background: 
    linear-gradient(90deg, rgba(0, 247, 255, 0.03) 1px, transparent 1px),
    linear-gradient(rgba(0, 247, 255, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  pointer-events: none;
  opacity: 0.5;
  animation: grid-scroll 20s linear infinite;
}

/* Floating Data Particles */
.data-particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: var(--neo-cyan);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--neo-cyan), 0 0 20px var(--neo-cyan);
  animation: data-rain 8s linear infinite;
  opacity: 0.6;
}

/* Screen Edge Glow */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9998;
  box-shadow: inset 0 0 100px rgba(0, 247, 255, 0.05);
}

/* Vignette Effect */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9997;
  background: radial-gradient(ellipse at 50% 50%, 
    transparent 0%, 
    transparent 60%,
    rgba(0, 0, 0, 0.3) 100%);
}

</style>
</head>
<body>

<!-- Neural Transcendence Overlay - AI Level ∞ Awakening Effect -->
<div id="transcendence-overlay">
  <canvas id="transcendence-canvas"></canvas>
  <div class="screen-flash"></div>
  <div class="energy-ring"></div>
  <div class="energy-ring" style="animation-delay: 0.2s;"></div>
  <div class="energy-ring" style="animation-delay: 0.4s;"></div>
  <div class="holo-distortion"></div>
  <div class="transcendence-vignette"></div>
  <div class="infinity-symbol" style="display: none;"></div>
  <div class="transcendence-status">AI.TRANSCENDENCE.INITIALIZED</div>
  <div class="transcendence-scan"></div>
  <!-- SVG Filter for Chromatic Aberration -->
  <svg style="position: absolute; width: 0; height: 0;">
    <defs>
      <filter id="chromatic-aberration-filter">
        <feColorMatrix type="matrix" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0" result="red"/>
        <feOffset in="red" dx="3" dy="0" result="red-shifted"/>
        <feColorMatrix type="matrix" values="0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0" result="green"/>
        <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0" result="blue"/>
        <feOffset in="blue" dx="-3" dy="0" result="blue-shifted"/>
        <feBlend mode="screen" in="red-shifted" in2="green" result="red-green"/>
        <feBlend mode="screen" in="red-green" in2="blue-shifted"/>
      </filter>
    </defs>
  </svg>
</div>

<div id="game-container"></div>

<!-- Pause Overlay -->
<div id="pause-overlay">
  <div class="pause-bg-effects">
    <div class="grid-lines"></div>
    <div class="scan-beam"></div>
  </div>
  
  <div class="pause-data-stream left">QUANTUM.HALT</div>
  <div class="pause-data-stream right">AWAIT.NEURAL.SYNC</div>
  
  <div class="pause-title">SUSPENDED</div>
  <div class="pause-subtitle">// NEURAL CORE STANDBY //</div>
  
  <div class="pause-ai-core">
    <div class="core-ring"></div>
    <div class="core-ring"></div>
    <div class="core-ring"></div>
    <div class="core-center"></div>
  </div>
  
  <div class="pause-menu-buttons">
    <button class="pause-menu-btn resume" id="pause-resume-btn">
      <span class="corner tl"></span>
      <span class="corner tr"></span>
      <span class="corner bl"></span>
      <span class="corner br"></span>
      <span class="btn-icon"><svg viewBox="0 0 24 24"><polygon points="6,4 20,12 6,20" fill="#0fa" stroke="#0fa" stroke-width="1.5" stroke-linejoin="round"/><line x1="3" y1="4" x2="3" y2="20" stroke="#0fa8" stroke-width="2"/></svg></span>RESUME
    </button>
    <button class="pause-menu-btn mode-select" id="pause-mode-select-btn">
      <span class="corner tl"></span>
      <span class="corner tr"></span>
      <span class="corner bl"></span>
      <span class="corner br"></span>
      <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M10,4 L10,20 M14,4 L4,12 L14,20" fill="none" stroke="rgba(255,120,120,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="18" cy="12" r="3" fill="none" stroke="rgba(255,120,120,0.6)" stroke-width="1.5"/></svg></span>MODE SELECT
    </button>
    <button class="pause-menu-btn edit-controls" id="pause-edit-btn">
      <span class="corner tl"></span>
      <span class="corner tr"></span>
      <span class="corner bl"></span>
      <span class="corner br"></span>
      <span class="btn-icon"><svg viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" stroke="rgba(255,200,100,0.9)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" stroke="rgba(255,200,100,0.9)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg></span>EDIT CONTROLS
    </button>
  </div>
</div>

<!-- Button Edit Overlay -->
<div id="button-edit-overlay">
  <div class="edit-header">
    <div class="edit-title">CONTROL LAYOUT EDITOR</div>
    <div class="edit-subtitle">// ドラッグで移動・ピンチでサイズ変更 //</div>
  </div>
  <div class="edit-controls-container">
    <div class="edit-btn-wrapper" id="edit-dpad-wrapper" data-target="dpad">
      <div class="edit-resize-handle nw"></div>
      <div class="edit-resize-handle ne"></div>
      <div class="edit-resize-handle sw"></div>
      <div class="edit-resize-handle se"></div>
      <div class="edit-label">D-PAD</div>
    </div>
    <div class="edit-btn-wrapper" id="edit-item-wrapper" data-target="item">
      <div class="edit-resize-handle nw"></div>
      <div class="edit-resize-handle ne"></div>
      <div class="edit-resize-handle sw"></div>
      <div class="edit-resize-handle se"></div>
      <div class="edit-label">ITEM</div>
    </div>
    <div class="edit-btn-wrapper" id="edit-swap-wrapper" data-target="swap">
      <div class="edit-resize-handle nw"></div>
      <div class="edit-resize-handle ne"></div>
      <div class="edit-resize-handle sw"></div>
      <div class="edit-resize-handle se"></div>
      <div class="edit-label">CHANGE</div>
    </div>
  </div>
  <div class="edit-footer">
    <button class="edit-action-btn save" id="edit-save-btn">
      <svg viewBox="0 0 24 24" width="18" height="18"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2" fill="none"/><polyline points="17,21 17,13 7,13 7,21" stroke="currentColor" stroke-width="2" fill="none"/><polyline points="7,3 7,8 15,8" stroke="currentColor" stroke-width="2" fill="none"/></svg>
      SAVE
    </button>
    <button class="edit-action-btn reset" id="edit-reset-btn">
      <svg viewBox="0 0 24 24" width="18" height="18"><path d="M3 12a9 9 0 109-9 9.75 9.75 0 00-6.74 2.74L3 8" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 3v5h5" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>
      RESET
    </button>
    <button class="edit-action-btn cancel" id="edit-cancel-btn">
      <svg viewBox="0 0 24 24" width="18" height="18"><line x1="18" y1="6" x2="6" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="6" y1="6" x2="18" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      CANCEL
    </button>
  </div>
</div>

<div id="mode-select-screen">
  <!-- Background Effects Layer -->
  <div class="mode-select-bg">
    <div class="volumetric-fog"></div>
    <div class="holo-grid"></div>
    <div class="scan-lines"></div>
    <div class="horizontal-scanner"></div>
    <div class="ambient-orb"></div>
    <div class="ambient-orb"></div>
    <div class="ambient-orb"></div>
    <canvas class="particle-field" id="mode-particle-canvas"></canvas>
  </div>
  
  <!-- Data Stream Decorations -->
  <div class="data-stream left">HEXA.CORE.v2.1</div>
  <div class="data-stream right">AI.PROTOCOL.RDY</div>
  
  <!-- HEXA Title Logo -->
  <div class="hexa-title-container">
    <div class="hexa-neural-bg"></div>
    <div class="hexa-frame">
      <svg viewBox="0 0 280 90">
        <rect class="hexa-frame-path" x="10" y="5" width="260" height="80" rx="8"/>
      </svg>
    </div>
    <div class="hexa-logo">
      <span class="hexa-letter letter-h" data-letter="H">H</span>
      <span class="hexa-letter letter-e" data-letter="E">E</span>
      <span class="hexa-letter letter-x" data-letter="X">X</span>
      <span class="hexa-letter letter-a" data-letter="A">A</span>
    </div>
    <div class="hexa-scanline"></div>
    <div class="hexa-particles" id="hexa-particles"></div>
    <div class="hexa-data-fragment">0x7F</div>
    <div class="hexa-data-fragment">CORE</div>
    <div class="hexa-data-fragment">∆∇</div>
    <div class="hexa-data-fragment">AI.SYS</div>
  </div>
  
  <!-- AI Core Visual -->
  <div class="ai-core-container">
    <div class="ai-ring"></div>
    <div class="ai-ring"></div>
    <div class="ai-ring"></div>
    <div class="ai-ring"></div>
    <div class="ai-core-center"></div>
  </div>
  
  <!-- System Status -->
  <div class="system-status">
    <span class="status-dot"></span>SELECT PROTOCOL
  </div>
  
  <!-- Mode Cards Container -->
  <div class="mode-cards-container">
    <!-- Training Mode -->
    <div class="mode-card training" id="mode-training">
      <div class="mode-indicator"></div>
      <div class="mode-card-corner tl"></div>
      <div class="mode-card-corner tr"></div>
      <div class="mode-card-corner bl"></div>
      <div class="mode-card-corner br"></div>
      <div class="mode-bg-glow"></div>
      <div class="mode-card-inner">
        <div class="mode-icon">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"/>
            <line x1="12" y1="22" x2="12" y2="15.5"/>
            <polyline points="22 8.5 12 15.5 2 8.5"/>
          </svg>
        </div>
        <div class="mode-info">
          <span class="mode-title">TRAINING <span class="mode-arrow">→</span></span>
          <span class="mode-desc">SOLO SIMULATION // SAFE ENVIRONMENT</span>
        </div>
      </div>
    </div>
    
    <!-- Battle Mode -->
    <div class="mode-card battle" id="mode-battle">
      <div class="mode-indicator"></div>
      <div class="mode-card-corner tl"></div>
      <div class="mode-card-corner tr"></div>
      <div class="mode-card-corner bl"></div>
      <div class="mode-card-corner br"></div>
      <div class="mode-bg-glow"></div>
      <div class="mode-card-inner">
        <div class="mode-icon">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2L2 7l10 5 10-5-10-5z"/>
            <path d="M2 17l10 5 10-5"/>
            <path d="M2 12l10 5 10-5"/>
          </svg>
        </div>
        <div class="mode-info">
          <span class="mode-title">AI BATTLE <span class="mode-arrow">→</span></span>
          <span class="mode-desc">QUANTUM WARFARE // SURVIVAL PROTOCOL</span>
        </div>
      </div>
    </div>
    
    <!-- Friend Battle Mode -->
    <div class="mode-card friend-battle locked" id="mode-friend-battle">
      <div class="mode-indicator"></div>
      <div class="mode-card-corner tl"></div>
      <div class="mode-card-corner tr"></div>
      <div class="mode-card-corner bl"></div>
      <div class="mode-card-corner br"></div>
      <div class="mode-bg-glow"></div>
      <!-- Lock Icon -->
      <svg class="lock-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <div class="mode-card-inner">
        <div class="mode-icon">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
            <circle cx="9" cy="7" r="4"/>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
          </svg>
        </div>
        <div class="mode-info">
          <span class="mode-title">FRIEND BATTLE <span class="mode-arrow">→</span></span>
          <span class="mode-desc">QUANTUM LINK // NEURAL SYNC BATTLE</span>
        </div>
      </div>
    </div>
    
    <!-- Tutorial Mode -->
    <div class="mode-card tutorial" id="mode-tutorial">
      <div class="mode-indicator"></div>
      <div class="mode-card-corner tl"></div>
      <div class="mode-card-corner tr"></div>
      <div class="mode-card-corner bl"></div>
      <div class="mode-card-corner br"></div>
      <div class="mode-bg-glow"></div>
      <div class="mode-card-inner">
        <div class="mode-icon">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
            <line x1="12" y1="17" x2="12.01" y2="17"/>
          </svg>
        </div>
        <div class="mode-info">
          <span class="mode-title">HOW TO PLAY <span class="mode-arrow">→</span></span>
          <span class="mode-desc">NEURAL TRAINING // PROTOCOL GUIDE</span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Version Badge -->
  <div class="version-badge">HEXA.OS v2.1.0</div>
</div>

<!-- Passcode Modal for Friend Battle -->
<div id="passcode-modal">
  <div class="passcode-container">
    <div class="passcode-icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
    </div>
    <div class="passcode-title">ACCESS CODE REQUIRED</div>
    <input type="password" class="passcode-input" id="passcode-input" placeholder="ENTER PASSCODE" maxlength="20" autocomplete="off">
    <div class="passcode-error" id="passcode-error"></div>
    <div class="passcode-buttons">
      <button class="passcode-btn cancel" id="passcode-cancel">CANCEL</button>
      <button class="passcode-btn submit" id="passcode-submit">UNLOCK</button>
    </div>
  </div>
</div>

<div id="boot-screen" class="matrix-active">
  <canvas id="matrix-canvas"></canvas>
  <div class="holo-distortion"></div>
  <canvas id="glow-particles-canvas" class="glow-particles"></canvas>
  
  <div id="power-btn-container">
    <!-- Outer rotating glyph ring -->
    <svg id="glyph-outer-ring" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="48" class="glyph-ring glyph-ring-outer"/>
      <circle cx="50" cy="50" r="45" class="glyph-ring glyph-ring-outer" style="stroke-dasharray: 2 8 4 8;"/>
      <!-- Code fragment decorations -->
      <text x="50" y="8" text-anchor="middle" fill="rgba(0,255,70,0.6)" font-size="6" font-family="monospace">0x7F</text>
      <text x="92" y="52" text-anchor="middle" fill="rgba(0,255,70,0.6)" font-size="6" font-family="monospace" transform="rotate(90 92 52)">AI</text>
      <text x="50" y="96" text-anchor="middle" fill="rgba(0,255,70,0.6)" font-size="6" font-family="monospace">CORE</text>
      <text x="8" y="52" text-anchor="middle" fill="rgba(0,255,70,0.6)" font-size="6" font-family="monospace" transform="rotate(-90 8 52)">SYS</text>
    </svg>
    
    <!-- Inner rotating glyph ring -->
    <svg id="glyph-inner-ring" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="38" class="glyph-ring glyph-ring-inner"/>
      <!-- Progress ring -->
      <circle cx="50" cy="50" r="45" class="glyph-ring-progress" id="ring-progress" transform="rotate(-90 50 50)"/>
    </svg>
    
    <!-- Center glyph icon -->
    <div id="power-icon"></div>
    
    <!-- Floating code fragments -->
    <span class="code-fragment" style="top: -10px; left: 30%;">カタ</span>
    <span class="code-fragment" style="top: 20%; right: -20px;">∆∇</span>
    <span class="code-fragment" style="bottom: -10px; right: 30%;">0x1F</span>
    <span class="code-fragment" style="bottom: 20%; left: -20px;">シス</span>
  </div>
  
  <p class="boot-text" data-text="INITIALIZE_AI_CORE">INITIALIZE_AI_CORE</p>
  
  <!-- System Info Panel - Hacking Style -->
  <div id="system-info-panel">
    <div class="sys-info-header">[SYS_INTERCEPT_v2.4]</div>
    <div class="sys-info-line" id="sys-device"></div>
    <div class="sys-info-line" id="sys-os"></div>
    <div class="sys-info-line" id="sys-browser"></div>
    <div class="sys-info-line" id="sys-resolution"></div>
    <div class="sys-info-line" id="sys-language"></div>
    <div class="sys-info-line" id="sys-connection"></div>
    <div class="sys-info-line" id="sys-latency"></div>
    <div class="sys-info-line" id="sys-ip-mock"></div>
    <div class="sys-info-line" id="sys-memory"></div>
    <div class="sys-info-line" id="sys-cores"></div>
    <div class="sys-info-status">[ STATUS: MONITORING ]</div>
  </div>
</div>

<div id="start-screen">
  <!-- Falling Blocks Background Canvas -->
  <canvas id="falling-blocks-canvas"></canvas>
  
  <!-- Background Effects Layer -->
  <div class="ai-select-bg">
    <div class="volumetric-fog"></div>
    <div class="holo-grid"></div>
    <div class="scan-lines"></div>
    <div class="horizontal-scanner"></div>
  </div>
  
  <!-- Data Stream Decorations -->
  <div class="ai-data-stream left">NEURAL.LV.SEL</div>
  <div class="ai-data-stream right">AI.CORE.RDY</div>
  
  <!-- AI Level Status -->
  <div class="ai-level-status">
    <span class="status-dot"></span>SELECT AI LEVEL
  </div>
  
  <h1 class="title">AI HEXA<br>EVOLUTION</h1>
  
  <div class="cpu-setting-container">
    <!-- Corner Brackets -->
    <div class="ai-panel-corner tl"></div>
    <div class="ai-panel-corner tr"></div>
    <div class="ai-panel-corner bl"></div>
    <div class="ai-panel-corner br"></div>
    <!-- Mode Indicator -->
    <div class="ai-panel-indicator"></div>
    
    <div id="cpu-face-container"></div>
    <input type="range" id="cpu-strength-slider" min="0" max="100" value="50">
    <p id="cpu-strength-label">AI LEVEL: 50</p>
  </div>
  
  <div class="start-actions">
    <button id="start-btn" class="start-btn">GAME START</button>
  </div>
  
  <!-- Version Badge -->
  <div class="ai-version-badge">AI.LEVEL.SELECT v1.0</div>
</div>

<div id="ui-layer">
  <div id="btn-swap" class="btn-swap">CHANGE</div>
  <div id="pause-btn" class="pause-btn"></div>
  <!-- Legacy buttons (hidden) -->
  <div id="assist-btn" class="assist-btn active" style="display:none !important;">
    <div class="assist-icon"></div>
    <span class="assist-text">アシスト: ON</span>
  </div>
  <div id="combo-route-btn" class="combo-route-btn" style="display:none !important;">
    <span class="combo-route-text">🔍 ルート</span>
  </div>
  
  <!-- New Futuristic AI Control Buttons -->
  <div id="training-controls" class="training-controls">
    <div id="assist-control-btn" class="ai-control-btn active">
      <div class="ai-status-indicator"></div>
      <div class="ai-label">
        <span class="ai-label-title">AI ASSIST</span>
        <span class="ai-label-value" id="assist-value">3コンボ</span>
      </div>
    </div>
    <div id="route-control-btn" class="ai-control-btn route-btn inactive">
      <div class="ai-status-indicator"></div>
      <div class="ai-label">
        <span class="ai-label-title">ROUTE</span>
        <span class="ai-label-value" id="route-value">OFF</span>
      </div>
    </div>
  </div>
  <div class="controls-area">
    <div class="d-pad">
      <div class="btn btn-up" id="btn-up"></div>
      <div class="btn btn-left" id="btn-left"></div>
      <div class="btn btn-right" id="btn-right"></div>
      <div class="btn btn-down" id="btn-down"></div>
    </div>
    <div class="btn btn-item" id="btn-item">ITEM</div>
  </div>
</div>

<div id="game-over-modal">
  <div class="result-card">
    <h2 id="game-result-title" class="result-title fade-item">GAME OVER</h2>
    
    <div class="analysis-container fade-item">
      <div class="rank-display">
        <span class="rank-label">EVALUATION RANK</span>
        <span class="rank-value" id="result-rank">-</span>
      </div>
      <div class="metrics-grid">
        <div class="metric">
          <span class="metric-label">SPEED</span>
          <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-speed"></div></div>
        </div>
        <div class="metric">
          <span class="metric-label">TECHNIQUE</span>
          <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-tech"></div></div>
        </div>
        <div class="metric">
          <span class="metric-label">STRATEGY</span>
          <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-strategy"></div></div>
        </div>
        <div class="metric">
          <span class="metric-label">AGGRESSION</span>
          <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-aggression"></div></div>
        </div>
      </div>
    </div>

    <div class="ai-comment-box fade-item">
      <p class="ai-text"><span id="ai-comment-text">ANALYZING...</span><span class="cursor"></span></p>
    </div>

    <div class="stats-container fade-item">
      <div class="stat-item">
        <span class="stat-label">MAX COMBO</span>
        <span class="stat-value" id="result-max-combo">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">BLOCKS</span>
        <span class="stat-value" id="result-blocks">0</span>
      </div>
    </div>
    <div class="result-actions fade-item" id="result-actions">
      <button class="restart-btn" id="retry-btn">RETRY</button>
      <button class="restart-btn secondary" id="home-btn">TOP</button>
    </div>
  </div>
</div>

<div id="tutorial-modal">
  <div class="tutorial-window">
    <div class="ai-monitor">
      <div class="scan-line"></div>
      <div class="ai-face-small"></div>
      <div class="ai-message-box">
        <p id="tutorial-ai-text">システム準備完了。</p>
      </div>
    </div>
    
    <div class="tutorial-display-area">
      <h3 id="tutorial-step-title">トピック</h3>
      <div id="tutorial-preview-container"></div>
      <div id="tutorial-step-content"></div>
    </div>

    <div class="tutorial-nav">
      <button id="tutorial-skip-btn" class="nav-btn secondary">スキップ</button>
      <button id="tutorial-next-btn" class="nav-btn primary">次へ >></button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.js"></script>
<script>
// ==========================================
// FUTURISTIC EFFECTS SYSTEM - 2024 ULTRA UPGRADE
// ==========================================

// Initialize global futuristic effects
(function initFuturisticEffects() {
  // Create ambient particle system
  const createAmbientParticles = () => {
    const container = document.body;
    const particleCount = 15;
    
    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'neo-ambient-particle';
      particle.style.cssText = `
        position: fixed;
        width: ${2 + Math.random() * 4}px;
        height: ${2 + Math.random() * 4}px;
        background: ${Math.random() > 0.5 ? '#00f7ff' : '#ff00ff'};
        border-radius: 50%;
        pointer-events: none;
        z-index: 9990;
        left: ${Math.random() * 100}vw;
        top: ${Math.random() * 100}vh;
        opacity: ${0.2 + Math.random() * 0.4};
        box-shadow: 0 0 ${5 + Math.random() * 10}px currentColor;
        animation: neo-float-${i % 3} ${15 + Math.random() * 20}s ease-in-out infinite;
        animation-delay: ${-Math.random() * 20}s;
      `;
      container.appendChild(particle);
    }
  };
  
  // Add floating animation keyframes dynamically
  const addFloatAnimations = () => {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes neo-float-0 {
        0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
        25% { transform: translate(30px, -50px) scale(1.2); opacity: 0.6; }
        50% { transform: translate(-20px, -100px) scale(0.8); opacity: 0.4; }
        75% { transform: translate(40px, -50px) scale(1.1); opacity: 0.5; }
      }
      @keyframes neo-float-1 {
        0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.4; }
        33% { transform: translate(-40px, -80px) scale(1.3); opacity: 0.6; }
        66% { transform: translate(30px, -40px) scale(0.9); opacity: 0.3; }
      }
      @keyframes neo-float-2 {
        0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.35; }
        50% { transform: translate(20px, -120px) scale(1.1); opacity: 0.55; }
      }
      
      /* Enhanced UI glow animations */
      @keyframes neo-border-flow {
        0% { background-position: 0% 0%; }
        100% { background-position: 200% 0%; }
      }
      
      /* Holographic scan line - DISABLED for cleaner visuals */
      .neo-scan-line {
        display: none !important;
      }
      
      /* Futuristic cursor trail */
      .cursor-trail {
        position: fixed;
        width: 8px;
        height: 8px;
        background: radial-gradient(circle, #00f7ff 0%, transparent 70%);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        animation: cursor-fade 0.5s ease-out forwards;
      }
      
      @keyframes cursor-fade {
        0% { transform: scale(1); opacity: 0.8; }
        100% { transform: scale(2); opacity: 0; }
      }
      
      /* Enhanced button ripple effect */
      .neo-ripple {
        position: absolute;
        border-radius: 50%;
        background: radial-gradient(circle, 
          rgba(0, 247, 255, 0.4) 0%, 
          rgba(255, 0, 255, 0.2) 50%, 
          transparent 70%);
        transform: scale(0);
        animation: neo-ripple-expand 0.6s ease-out forwards;
        pointer-events: none;
      }
      
      @keyframes neo-ripple-expand {
        0% { transform: scale(0); opacity: 1; }
        100% { transform: scale(4); opacity: 0; }
      }
      
      /* Glitch text effect on hover */
      .neo-glitch-hover:hover {
        animation: neo-glitch 0.3s ease-in-out;
      }
      
      @keyframes neo-glitch {
        0%, 100% { 
          text-shadow: 0 0 10px currentColor;
          transform: translate(0);
        }
        20% { 
          text-shadow: -2px 0 #ff00ff, 2px 0 #00f7ff;
          transform: translate(-2px, 1px);
        }
        40% { 
          text-shadow: 2px 0 #ff00ff, -2px 0 #00f7ff;
          transform: translate(2px, -1px);
        }
        60% { 
          text-shadow: -1px 0 #ff00ff, 1px 0 #00f7ff;
          transform: translate(1px, 0);
        }
        80% { 
          text-shadow: 1px 0 #ff00ff, -1px 0 #00f7ff;
          transform: translate(-1px, 1px);
        }
      }
      
      /* Cyber corner decorations */
      .neo-corner {
        position: absolute;
        width: 30px;
        height: 30px;
        pointer-events: none;
      }
      .neo-corner::before, .neo-corner::after {
        content: '';
        position: absolute;
        background: linear-gradient(90deg, #00f7ff, #ff00ff);
      }
      .neo-corner.tl::before { top: 0; left: 0; width: 100%; height: 2px; }
      .neo-corner.tl::after { top: 0; left: 0; width: 2px; height: 100%; }
      .neo-corner.tr::before { top: 0; right: 0; width: 100%; height: 2px; }
      .neo-corner.tr::after { top: 0; right: 0; width: 2px; height: 100%; }
      .neo-corner.bl::before { bottom: 0; left: 0; width: 100%; height: 2px; }
      .neo-corner.bl::after { bottom: 0; left: 0; width: 2px; height: 100%; }
      .neo-corner.br::before { bottom: 0; right: 0; width: 100%; height: 2px; }
      .neo-corner.br::after { bottom: 0; right: 0; width: 2px; height: 100%; }
    `;
    document.head.appendChild(style);
  };
  
  // Create scan line effect - DISABLED for cleaner visuals
  const createScanLine = () => {
    // Scan line disabled - no longer creates visual noise
    return;
  };
  
  // Add enhanced touch/click effects
  const addTouchEffects = () => {
    let lastTouch = 0;
    const handleTouch = (e) => {
      const now = Date.now();
      if (now - lastTouch < 50) return; // Throttle
      lastTouch = now;
      
      const x = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
      const y = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
      
      if (x === 0 && y === 0) return;
      
      // Create cursor trail
      const trail = document.createElement('div');
      trail.className = 'cursor-trail';
      trail.style.left = (x - 4) + 'px';
      trail.style.top = (y - 4) + 'px';
      document.body.appendChild(trail);
      setTimeout(() => trail.remove(), 500);
    };
    
    document.addEventListener('touchmove', handleTouch, { passive: true });
    document.addEventListener('mousemove', (e) => {
      if (Math.random() > 0.85) handleTouch(e); // Only occasional trail for mouse
    });
  };
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      addFloatAnimations();
      createAmbientParticles();
      createScanLine();
      addTouchEffects();
    });
  } else {
    addFloatAnimations();
    createAmbientParticles();
    createScanLine();
    addTouchEffects();
  }
})();

// ==========================================
// FUTURISTIC SOUND EFFECTS ENHANCEMENT
// ==========================================
const FuturisticSFX = {
  ctx: null,
  
  init() {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      this.ctx = new AudioContext();
    }
  },
  
  // Cyber UI click sound
  playUIClick() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(2000, now + 0.05);
    osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
    
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(4000, now);
    
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.15);
  },
  
  // Holographic hover sound
  playHoverSound() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(1200, now);
    osc.frequency.exponentialRampToValueAtTime(1800, now + 0.08);
    
    gain.gain.setValueAtTime(0.05, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.1);
  },
  
  // Mode transition whoosh
  playTransitionSound() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    
    // Base whoosh
    const noise = this.ctx.createOscillator();
    const noiseGain = this.ctx.createGain();
    const noiseFilter = this.ctx.createBiquadFilter();
    
    noise.type = 'sawtooth';
    noise.frequency.setValueAtTime(100, now);
    noise.frequency.exponentialRampToValueAtTime(800, now + 0.3);
    noise.frequency.exponentialRampToValueAtTime(200, now + 0.5);
    
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.setValueAtTime(500, now);
    noiseFilter.frequency.exponentialRampToValueAtTime(2000, now + 0.3);
    noiseFilter.Q.value = 2;
    
    noiseGain.gain.setValueAtTime(0, now);
    noiseGain.gain.linearRampToValueAtTime(0.2, now + 0.1);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    
    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(this.ctx.destination);
    
    noise.start(now);
    noise.stop(now + 0.5);
    
    // High frequency sparkle
    const sparkle = this.ctx.createOscillator();
    const sparkleGain = this.ctx.createGain();
    
    sparkle.type = 'sine';
    sparkle.frequency.setValueAtTime(2000, now + 0.1);
    sparkle.frequency.exponentialRampToValueAtTime(4000, now + 0.3);
    
    sparkleGain.gain.setValueAtTime(0, now + 0.1);
    sparkleGain.gain.linearRampToValueAtTime(0.1, now + 0.2);
    sparkleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    
    sparkle.connect(sparkleGain);
    sparkleGain.connect(this.ctx.destination);
    
    sparkle.start(now + 0.1);
    sparkle.stop(now + 0.4);
  },
  
  // Victory fanfare - TRIUMPHANT NEURAL VICTORY
  playVictorySound() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    
    // Ascending triumphant fanfare with futuristic resonance
    const victoryNotes = [329.63, 415.30, 523.25, 659.25, 783.99, 1046.50]; // E4 -> C6
    
    // Initial power surge
    const surgeOsc = this.ctx.createOscillator();
    const surgeGain = this.ctx.createGain();
    surgeOsc.type = 'sawtooth';
    surgeOsc.frequency.setValueAtTime(80, now);
    surgeOsc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
    surgeGain.gain.setValueAtTime(0.15, now);
    surgeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    surgeOsc.connect(surgeGain);
    surgeGain.connect(this.ctx.destination);
    surgeOsc.start(now);
    surgeOsc.stop(now + 0.35);
    
    // Triumphant ascending notes
    victoryNotes.forEach((freq, i) => {
      const osc = this.ctx.createOscillator();
      const osc2 = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      
      osc.type = 'triangle';
      osc.frequency.value = freq;
      
      osc2.type = 'sine';
      osc2.frequency.value = freq * 2;
      
      const startTime = now + 0.15 + i * 0.12;
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(0.15, startTime + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.9);
      
      osc.connect(gain);
      osc2.connect(gain);
      gain.connect(this.ctx.destination);
      
      osc.start(startTime);
      osc2.start(startTime);
      osc.stop(startTime + 1);
      osc2.stop(startTime + 1);
    });
    
    // Final triumphant chord
    const chordNotes = [523.25, 659.25, 783.99, 1046.50]; // C major
    chordNotes.forEach((freq, i) => {
      const chordOsc = this.ctx.createOscillator();
      const chordGain = this.ctx.createGain();
      
      chordOsc.type = i % 2 === 0 ? 'triangle' : 'sine';
      chordOsc.frequency.value = freq;
      
      const chordStart = now + 0.9;
      chordGain.gain.setValueAtTime(0, chordStart);
      chordGain.gain.linearRampToValueAtTime(0.1, chordStart + 0.05);
      chordGain.gain.linearRampToValueAtTime(0.05, chordStart + 0.8);
      chordGain.gain.exponentialRampToValueAtTime(0.001, chordStart + 1.5);
      
      chordOsc.connect(chordGain);
      chordGain.connect(this.ctx.destination);
      chordOsc.start(chordStart);
      chordOsc.stop(chordStart + 1.8);
    });
    
    // High shimmer finish
    const shimmerOsc = this.ctx.createOscillator();
    const shimmerGain = this.ctx.createGain();
    shimmerOsc.type = 'sine';
    shimmerOsc.frequency.setValueAtTime(2000, now + 1);
    shimmerOsc.frequency.exponentialRampToValueAtTime(3000, now + 1.5);
    shimmerGain.gain.setValueAtTime(0, now + 1);
    shimmerGain.gain.linearRampToValueAtTime(0.05, now + 1.1);
    shimmerGain.gain.exponentialRampToValueAtTime(0.001, now + 1.8);
    shimmerOsc.connect(shimmerGain);
    shimmerGain.connect(this.ctx.destination);
    shimmerOsc.start(now + 1);
    shimmerOsc.stop(now + 2);
  },
  
  // Defeat sound - SYSTEM CRITICAL FAILURE
  playDefeatSound() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    
    // System shutdown sequence
    
    // Initial impact - heavy bass thud
    const impactOsc = this.ctx.createOscillator();
    const impactGain = this.ctx.createGain();
    impactOsc.type = 'sine';
    impactOsc.frequency.setValueAtTime(60, now);
    impactOsc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
    impactGain.gain.setValueAtTime(0.4, now);
    impactGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
    impactOsc.connect(impactGain);
    impactGain.connect(this.ctx.destination);
    impactOsc.start(now);
    impactOsc.stop(now + 0.7);
    
    // Descending failure tone
    const failOsc = this.ctx.createOscillator();
    const failGain = this.ctx.createGain();
    const failFilter = this.ctx.createBiquadFilter();
    
    failOsc.type = 'sawtooth';
    failOsc.frequency.setValueAtTime(500, now);
    failOsc.frequency.exponentialRampToValueAtTime(100, now + 0.8);
    failOsc.frequency.exponentialRampToValueAtTime(40, now + 1.2);
    
    failFilter.type = 'lowpass';
    failFilter.frequency.setValueAtTime(2500, now);
    failFilter.frequency.exponentialRampToValueAtTime(150, now + 1.2);
    failFilter.Q.value = 3;
    
    failGain.gain.setValueAtTime(0.25, now);
    failGain.gain.exponentialRampToValueAtTime(0.001, now + 1.4);
    
    failOsc.connect(failFilter);
    failFilter.connect(failGain);
    failGain.connect(this.ctx.destination);
    failOsc.start(now);
    failOsc.stop(now + 1.5);
    
    // Digital glitch stutters
    for (let i = 0; i < 4; i++) {
      const glitchOsc = this.ctx.createOscillator();
      const glitchGain = this.ctx.createGain();
      
      glitchOsc.type = 'square';
      const glitchFreq = 200 - i * 40;
      glitchOsc.frequency.value = glitchFreq;
      
      const glitchStart = now + 0.3 + i * 0.15;
      glitchGain.gain.setValueAtTime(0.08, glitchStart);
      glitchGain.gain.exponentialRampToValueAtTime(0.001, glitchStart + 0.08);
      
      glitchOsc.connect(glitchGain);
      glitchGain.connect(this.ctx.destination);
      glitchOsc.start(glitchStart);
      glitchOsc.stop(glitchStart + 0.1);
    }
    
    // Final power-down drone
    const droneOsc = this.ctx.createOscillator();
    const droneGain = this.ctx.createGain();
    droneOsc.type = 'triangle';
    droneOsc.frequency.setValueAtTime(80, now + 0.8);
    droneOsc.frequency.exponentialRampToValueAtTime(30, now + 1.8);
    droneGain.gain.setValueAtTime(0.15, now + 0.8);
    droneGain.gain.exponentialRampToValueAtTime(0.001, now + 2);
    droneOsc.connect(droneGain);
    droneGain.connect(this.ctx.destination);
    droneOsc.start(now + 0.8);
    droneOsc.stop(now + 2.2);
  }
};

// ==========================================
// 定数・設定 (Constants & Config)
// ==========================================
const COLS = 8;
const VISIBLE_ROWS = 15;
const HIDDEN_ROWS = 8;
const ROWS = VISIBLE_ROWS + HIDDEN_ROWS;
const BLOCK_TYPES = 5; // ブロックの種類数（ジェムの色数）
const ANIMATION_SPEED = 0.2;
const DROP_INTERVAL_INIT = 60; // Frames per drop

// Performance optimization constants
const MAX_PARTICLES = 80; // パーティクル数の上限（軽量化: 150→80）
const MAX_FIREWORKS = 25; // 花火の上限（軽量化: 50→25）
const AI_SIMULATION_MAX_DEPTH = 6; // AIシミュレーションの最大深度
const PARTICLE_SPAWN_THROTTLE = 5; // パーティクル生成の制限（軽量化: 8→5）
const PARTICLE_SPAWN_THROTTLE_HEAVY = 2; // パーティクル生成の制限（軽量化: 4→2）

// グリッドコピー用の再利用可能バッファ（オブジェクトプーリング）
const GRID_BUFFER_POOL = [];
const GRID_BUFFER_POOL_SIZE = 8;
for (let i = 0; i < GRID_BUFFER_POOL_SIZE; i++) {
  const buf = [];
  for (let cx = 0; cx < COLS; cx++) {
    buf[cx] = new Int8Array(ROWS);
  }
  GRID_BUFFER_POOL.push({ inUse: false, grid: buf });
}

function acquireGridBuffer() {
  for (let i = 0; i < GRID_BUFFER_POOL_SIZE; i++) {
    if (!GRID_BUFFER_POOL[i].inUse) {
      GRID_BUFFER_POOL[i].inUse = true;
      return GRID_BUFFER_POOL[i];
    }
  }
  // プールが枯渇した場合は新規作成
  const buf = [];
  for (let cx = 0; cx < COLS; cx++) {
    buf[cx] = new Int8Array(ROWS);
  }
  return { inUse: true, grid: buf, temp: true };
}

function releaseGridBuffer(bufObj) {
  if (bufObj && !bufObj.temp) {
    bufObj.inUse = false;
  }
}

function copyGridToBuffer(srcGrid, bufGrid) {
  for (let cx = 0; cx < COLS; cx++) {
    const src = srcGrid[cx];
    const dst = bufGrid[cx];
    for (let cy = 0; cy < ROWS; cy++) {
      dst[cy] = src[cy];
    }
  }
}

// ==========================================
// サウンドアセット (Sound Assets)
// ==========================================
const SOUND_URLS = {
  bgm: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/2f3e679d-258d-41a6-ba59-6190033e9942/files/umg94byo.mp3',
  bgmInfinite: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/40638209-38f1-48a7-af30-4afa0c5492b8/files/js1779nx.mp3',
  bgmTitle: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/b08f8a3e-1cfd-4f72-a16b-109184818363/files/pxxqge3q.mp3',
  erase: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/b039a423-7287-467f-a630-4d1bcca64c39/files/b5ayz9i1.mp3',
  drop: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/c359fc5b-7ef7-4446-8bcf-869a8efe5b67/files/58drpukz.mp3',
  dropDevil: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/c359fc5b-7ef7-4446-8bcf-869a8efe5b67/files/oxq3yujt.mp3',
  missileHit1: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/c00db409-e6c8-4728-b0c0-38d5a99704c4/files/81nht39c.mp3',
  missileHit2: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/c00db409-e6c8-4728-b0c0-38d5a99704c4/files/8xennd48.mp3',
  itemGet: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/f4b23f42-12d5-4db4-8021-964d96d3c93d/files/uqte75ei.mp3',
  devilTap1: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/ac325a96-20b8-4afa-8de1-5dd2fd6a58fd/files/hh5rerfy.mp3',
  devilTap2: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/ac325a96-20b8-4afa-8de1-5dd2fd6a58fd/files/nsfxglrf.mp3',
  devilTap3: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/ac325a96-20b8-4afa-8de1-5dd2fd6a58fd/files/k6tz1no2.mp3',
  devilTap4: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/ac325a96-20b8-4afa-8de1-5dd2fd6a58fd/files/c34julqz.mp3',
  devilTap5: 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/ac325a96-20b8-4afa-8de1-5dd2fd6a58fd/files/bvhxazzp.mp3'
};

// ==========================================
// 色定義 (Color Palette)
// ==========================================
const COLORS = {
  bg: '#000510',
  gridBg: 'rgba(0, 10, 20, 0.8)',
  gridBorder: '#00FFFF',
  gems: [
    null,
    '#8A2BE2', // 1: Purple
    '#4169E1', // 2: Blue
    '#FF4500', // 3: Red
    '#FFD700', // 4: Yellow
    '#00FFFF', // 5: Cyan
    '#8A2BE2', // 6: Unused
    '#FF69B4'  // 7: Item P
  ]
};

const GEM_URLS = [
  null,
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/lx089jdk.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/zcmuvq2z.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/ii1cqrn9.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/2awljusp.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/6jx8wd1g.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/8fc0a884-0e2d-470e-b4bb-8cdaac0e98e1/files/bl02nx7t.jpeg',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/76f481e5-bbd5-458e-a55e-caae103acd2f/files/dnsyu96c.gif',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/64b7a0a8-5fc9-4244-998b-b17a2f9499b6/files/iy2j9zwo.gif',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/02df3ae1-4d6f-475f-90b4-776d070c0d8c/files/2hlu1rff.gif',
  'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/03c94eb1-1a14-4da1-9a54-88433f2f1dc2/files/jrfi0a0l.gif'
];

// ==========================================
// P5.js スケッチインスタンス
// ==========================================
const sketch = (p) => {
  // --- グローバル変数定義 ---
  let cellSize;
  let boardWidth, boardHeight, boardY;
  let playerGame, cpuGame;
  let gemImages = [];
  let btnSwap, dPad, btnItem;
  let attackEffects = [];
  let fallingBgBlocks = [];
  let dataPackets = [];
  let gridLines = [];
  let bubbles = [];
  let gameState = 'BOOT'; // BOOT, TITLE, PLAYING, GAMEOVER
  let countdownTimer = 0;
  let countdownValue = 3;
  let isPaused = false;
  let missileTimer = 0;
  let isReviving = false;
  let isTrainingMode = false;
  let aiAssistLevel = 3;
  let showComboRouteVisualization = false; // コンボルート視覚化表示フラグ
  let revivalTimer = 0;
  
  // ロボットの表情・状態管理
  let robotState = {
    mood: 'happy',        // happy, neutral, sleepy, sleeping, surprised, watching
    moodTimer: 0,         // 表情変更タイマー
    moodDuration: 300,    // 表情維持時間（フレーム）
    eyeTargetX: 0,        // 目標視線X
    eyeTargetY: 0,        // 目標視線Y
    currentEyeX: 0,       // 現在の視線X
    currentEyeY: 0,       // 現在の視線Y
    blinkTimer: 0,        // 瞬きタイマー
    isBlinking: false,    // 瞬き中フラグ
    sleepZzTimer: 0,      // 睡眠Zzzアニメーションタイマー
    surpriseTimer: 0,     // 驚きアニメーションタイマー
    watchingBlock: false, // ブロックを追跡中フラグ
    yawnTimer: 0,         // あくびタイマー
    isYawning: false,     // あくび中フラグ
    sweatDrops: [],       // 汗滴アニメーション
  };
  let currentCpuLevel = 50;
  let isDevilMode = false;
  let screenShake = 0;
  
  let resultAnimationTimeouts = [];
  let isResultAnimationSkipped = false;
  let gameOverTimestamp = 0;
  
  // Input State for Continuous Movement
  let inputState = { left: false, right: false };
  let inputTimers = { left: 0, right: 0 };
  const DAS_DELAY = 6; // Initial delay frames
  const DAS_SPEED = 2;  // Repeat interval frames
  
  // ==========================================
  // オーディオシステム (Audio System)
  // ==========================================
  const audio = {
    ctx: null,
    bgmNormal: new Audio(SOUND_URLS.bgm),
    bgmInfinite: new Audio(SOUND_URLS.bgmInfinite),
    bgmTitle: new Audio(SOUND_URLS.bgmTitle),
    currentBgm: null,
    enabled: false,
    eraseBuffer: null,
    dropBuffer: null,
    dropDevilBuffer: null,
    missileHit1Buffer: null,
    missileHit2Buffer: null,
    itemGetBuffer: null,
    devilTapBuffers: [],
    lastDevilTapIndex: -1,
    loadingPromise: null,
    
    init() {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AudioContext();
      
      this.bgmNormal.loop = true;
      this.bgmNormal.volume = 0.3;
      
      this.bgmInfinite.loop = true;
      this.bgmInfinite.volume = 0.7;
      
      this.bgmTitle.loop = true;
      this.bgmTitle.volume = 0.4;
      
      this.loadingPromise = this.loadSounds();
    },

    async loadSounds() {
      if (!this.ctx) return;
      try {
        const res = await fetch(SOUND_URLS.erase);
        const arrayBuffer = await res.arrayBuffer();
        this.eraseBuffer = await this.ctx.decodeAudioData(arrayBuffer);
        const resDrop = await fetch(SOUND_URLS.drop);
        const bufDrop = await resDrop.arrayBuffer();
        this.dropBuffer = await this.ctx.decodeAudioData(bufDrop);
        const resDropDevil = await fetch(SOUND_URLS.dropDevil);
        const bufDropDevil = await resDropDevil.arrayBuffer();
        this.dropDevilBuffer = await this.ctx.decodeAudioData(bufDropDevil);
        const resM1 = await fetch(SOUND_URLS.missileHit1);
        const bufM1 = await resM1.arrayBuffer();
        this.missileHit1Buffer = await this.ctx.decodeAudioData(bufM1);
        const resM2 = await fetch(SOUND_URLS.missileHit2);
        const bufM2 = await resM2.arrayBuffer();
        this.missileHit2Buffer = await this.ctx.decodeAudioData(bufM2);
        const resItem = await fetch(SOUND_URLS.itemGet);
        const bufItem = await resItem.arrayBuffer();
        this.itemGetBuffer = await this.ctx.decodeAudioData(bufItem);
        
        const tapUrls = [SOUND_URLS.devilTap1, SOUND_URLS.devilTap2, SOUND_URLS.devilTap3, SOUND_URLS.devilTap4, SOUND_URLS.devilTap5];
        for (let url of tapUrls) {
          try {
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            this.devilTapBuffers.push(await this.ctx.decodeAudioData(buf));
          } catch(e) { console.log(e); }
        }
      } catch(e) { console.log(e); }
    },
    
    playBGM(isInfinite) {
      this.stopTitleBGM();
      if (this.currentBgm) {
        this.currentBgm.pause();
        this.currentBgm.currentTime = 0;
      }
      
      this.currentBgm = isInfinite ? this.bgmInfinite : this.bgmNormal;
      
      if (this.enabled) {
        this.currentBgm.play().catch(e => console.log("BGM play failed"));
      }
    },
    
    playTitleBGM() {
      this.bgmTitle.loop = true;
      this.bgmTitle.volume = 0.4;
      this.bgmTitle.play().catch(e => {
        console.log("Title BGM autoplay blocked, waiting for interaction");
        const playOnInteraction = () => {
          this.bgmTitle.play().catch(()=>{});
          document.removeEventListener('click', playOnInteraction);
          document.removeEventListener('touchstart', playOnInteraction);
          document.removeEventListener('keydown', playOnInteraction);
        };
        document.addEventListener('click', playOnInteraction);
        document.addEventListener('touchstart', playOnInteraction, {passive: false});
        document.addEventListener('keydown', playOnInteraction);
      });
    },

    stopTitleBGM() {
      this.bgmTitle.pause();
      this.bgmTitle.currentTime = 0;
    },

    pauseBGM() {
      if (this.currentBgm) this.currentBgm.pause();
    },
    
    resumeBGM() {
      if (this.enabled && this.currentBgm) this.currentBgm.play().catch(()=>{});
    },
    
    playCombo(count, isDevilMode = false) {
      if (!this.enabled || !this.ctx) return;
      
      const t = this.ctx.currentTime;
      
      // FUTURISTIC NEURAL SYNC COMBO SOUND
      // Sci-fi ascending tone with digital harmonics
      
      // Base frequency increases with combo (cyberpunk scale)
      const cyberScale = [261.63, 329.63, 392.00, 523.25, 659.25, 783.99, 1046.50];
      const noteIndex = (count - 1) % cyberScale.length;
      const octaveMultiplier = Math.pow(2, Math.floor((count - 1) / cyberScale.length) * 0.5);
      const baseFreq = cyberScale[noteIndex] * octaveMultiplier;
      
      if (isDevilMode) {
        // ∞ MODE: DARK MATTER CASCADE - 重圧感のある未来的コンボ効果音
        // 深い低音の衝撃 + メタリックな共鳴 + グリッチサウンド + 上昇する電子音
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator();
        const osc4 = this.ctx.createOscillator();
        const osc5 = this.ctx.createOscillator();
        const osc6 = this.ctx.createOscillator();
        const subBass = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const gain2 = this.ctx.createGain();
        const gain3 = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const filter2 = this.ctx.createBiquadFilter();
        const filter3 = this.ctx.createBiquadFilter();
        const distortion = this.ctx.createWaveShaper();
        
        // Distortion for industrial edge
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          const x = i * 2 / 256 - 1;
          curve[i] = Math.tanh(x * 2.5);
        }
        distortion.curve = curve;
        
        // コンボ数に応じた強度
        const comboMult = Math.min(1 + count * 0.15, 2.5);
        const intensity = Math.min(0.5 + count * 0.06, 1.0);
        
        // ABYSSAL SUB-BASS - 地鳴りのような超低域
        subBass.type = 'sine';
        subBass.frequency.setValueAtTime(baseFreq * 0.12, t);
        subBass.frequency.exponentialRampToValueAtTime(baseFreq * 0.25, t + 0.1);
        subBass.frequency.exponentialRampToValueAtTime(baseFreq * 0.08, t + 0.4);
        
        // GRAVITON WAVE - 重厚なベース
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(baseFreq * 0.25, t);
        osc1.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, t + 0.08);
        osc1.frequency.exponentialRampToValueAtTime(baseFreq * 0.15, t + 0.35);
        
        // DIMENSIONAL RIFT - 歪んだ上昇音
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(baseFreq * 0.5, t);
        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 2 * comboMult, t + 0.12);
        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, t + 0.3);
        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3 * comboMult, t + 0.45);
        
        // CYBERNETIC RESONANCE - 金属的な共鳴
        osc3.type = 'sawtooth';
        osc3.frequency.setValueAtTime(baseFreq * 2, t + 0.02);
        osc3.frequency.exponentialRampToValueAtTime(baseFreq * 4 * comboMult, t + 0.1);
        osc3.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, t + 0.35);
        
        // NEURAL PULSE - パルス状のビート
        osc4.type = 'square';
        osc4.frequency.setValueAtTime(baseFreq * 1.5, t);
        osc4.frequency.setValueAtTime(baseFreq * 2, t + 0.04);
        osc4.frequency.setValueAtTime(baseFreq * 1.5, t + 0.08);
        osc4.frequency.setValueAtTime(baseFreq * 2.5, t + 0.12);
        osc4.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, t + 0.3);
        
        // QUANTUM SHIMMER - 高域の電子的きらめき
        osc5.type = 'sine';
        osc5.frequency.setValueAtTime(baseFreq * 5, t + 0.05);
        osc5.frequency.exponentialRampToValueAtTime(baseFreq * 8 * comboMult, t + 0.15);
        osc5.frequency.exponentialRampToValueAtTime(baseFreq * 3, t + 0.5);
        
        // VOID ECHO - 残響的な尾音
        osc6.type = 'triangle';
        osc6.frequency.setValueAtTime(baseFreq * 3, t + 0.15);
        osc6.frequency.exponentialRampToValueAtTime(baseFreq * 6, t + 0.25);
        osc6.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, t + 0.6);
        
        // Low-pass resonant filter for warmth
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(baseFreq * 3, t);
        filter.frequency.exponentialRampToValueAtTime(baseFreq * 8, t + 0.1);
        filter.frequency.exponentialRampToValueAtTime(baseFreq * 2, t + 0.4);
        filter.Q.value = 6 + Math.min(count, 10);
        
        // Band-pass for presence
        filter2.type = 'bandpass';
        filter2.frequency.setValueAtTime(baseFreq * 2, t);
        filter2.frequency.exponentialRampToValueAtTime(baseFreq * 6, t + 0.15);
        filter2.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, t + 0.45);
        filter2.Q.value = 10 + Math.min(count * 2, 15);
        
        // High-pass for clarity
        filter3.type = 'highpass';
        filter3.frequency.value = 80;
        filter3.Q.value = 0.7;
        
        // MAIN IMPACT ENVELOPE - 重厚なメインエンベロープ
        gain.gain.setValueAtTime(intensity * 0.8, t);
        gain.gain.exponentialRampToValueAtTime(intensity * 0.4, t + 0.08);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.55);
        
        // MID RESONANCE ENVELOPE
        gain2.gain.setValueAtTime(0, t);
        gain2.gain.linearRampToValueAtTime(intensity * 0.5, t + 0.05);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        
        // HIGH SHIMMER ENVELOPE
        gain3.gain.setValueAtTime(0, t + 0.05);
        gain3.gain.linearRampToValueAtTime(intensity * 0.25, t + 0.1);
        gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.65);
        
        // Routing - Heavy bass chain
        subBass.connect(filter);
        osc1.connect(filter);
        osc2.connect(distortion);
        distortion.connect(filter);
        filter.connect(filter3);
        filter3.connect(gain);
        
        // Mid resonance chain
        osc3.connect(filter2);
        osc4.connect(filter2);
        filter2.connect(gain2);
        
        // High shimmer chain
        osc5.connect(gain3);
        osc6.connect(gain3);
        
        gain.connect(this.ctx.destination);
        gain2.connect(this.ctx.destination);
        gain3.connect(this.ctx.destination);
        
        subBass.start(t);
        osc1.start(t);
        osc2.start(t);
        osc3.start(t + 0.02);
        osc4.start(t);
        osc5.start(t + 0.05);
        osc6.start(t + 0.15);
        subBass.stop(t + 0.6);
        osc1.stop(t + 0.58);
        osc2.stop(t + 0.5);
        osc3.stop(t + 0.45);
        osc4.stop(t + 0.35);
        osc5.stop(t + 0.55);
        osc6.stop(t + 0.7);
        
        // DARK MATTER TAIL - 高コンボ時の追加エコー
        if (count >= 2) {
          const reverbOsc1 = this.ctx.createOscillator();
          const reverbOsc2 = this.ctx.createOscillator();
          const reverbGain = this.ctx.createGain();
          const reverbFilter = this.ctx.createBiquadFilter();
          
          reverbOsc1.type = 'sine';
          reverbOsc1.frequency.setValueAtTime(baseFreq * 1.5, t + 0.2);
          reverbOsc1.frequency.exponentialRampToValueAtTime(baseFreq * 3, t + 0.4);
          reverbOsc1.frequency.exponentialRampToValueAtTime(baseFreq, t + 0.7);
          
          reverbOsc2.type = 'triangle';
          reverbOsc2.frequency.setValueAtTime(baseFreq * 0.5, t + 0.2);
          reverbOsc2.frequency.exponentialRampToValueAtTime(baseFreq * 0.25, t + 0.8);
          
          reverbFilter.type = 'lowpass';
          reverbFilter.frequency.value = 2500;
          reverbFilter.Q.value = 3;
          
          reverbGain.gain.setValueAtTime(0, t + 0.2);
          reverbGain.gain.linearRampToValueAtTime(0.18, t + 0.3);
          reverbGain.gain.exponentialRampToValueAtTime(0.001, t + 0.85);
          
          reverbOsc1.connect(reverbFilter);
          reverbOsc2.connect(reverbFilter);
          reverbFilter.connect(reverbGain);
          reverbGain.connect(this.ctx.destination);
          reverbOsc1.start(t + 0.2);
          reverbOsc2.start(t + 0.2);
          reverbOsc1.stop(t + 0.9);
          reverbOsc2.stop(t + 0.9);
        }
        
      } else {
        // QUANTUM RESONANCE SYNC - Clean futuristic chime
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator();
        const gain1 = this.ctx.createGain();
        const gain2 = this.ctx.createGain();
        const gain3 = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const reverb = this.ctx.createConvolver();
        
        // Primary tone - crystalline sweep
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(baseFreq * 0.8, t);
        osc1.frequency.exponentialRampToValueAtTime(baseFreq, t + 0.05);
        osc1.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, t + 0.15);
        
        // Harmonic shimmer
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(baseFreq * 2, t);
        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 2.5, t + 0.1);
        
        // High frequency sparkle
        osc3.type = 'sine';
        osc3.frequency.setValueAtTime(baseFreq * 4, t + 0.02);
        osc3.frequency.exponentialRampToValueAtTime(baseFreq * 3, t + 0.2);
        
        filter.type = 'highpass';
        filter.frequency.value = 300;
        filter.Q.value = 0.5;
        
        // Intensity increases with combo
        const intensity = Math.min(0.4 + count * 0.05, 0.9);
        
        gain1.gain.setValueAtTime(0, t);
        gain1.gain.linearRampToValueAtTime(intensity * 0.6, t + 0.02);
        gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        
        gain2.gain.setValueAtTime(0, t);
        gain2.gain.linearRampToValueAtTime(intensity * 0.3, t + 0.03);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
        
        gain3.gain.setValueAtTime(0, t + 0.02);
        gain3.gain.linearRampToValueAtTime(intensity * 0.15, t + 0.05);
        gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        
        osc1.connect(gain1);
        osc2.connect(filter);
        filter.connect(gain2);
        osc3.connect(gain3);
        gain1.connect(this.ctx.destination);
        gain2.connect(this.ctx.destination);
        gain3.connect(this.ctx.destination);
        
        osc1.start(t);
        osc2.start(t);
        osc3.start(t + 0.02);
        osc1.stop(t + 0.55);
        osc2.stop(t + 0.4);
        osc3.stop(t + 0.3);
        
        // Additional echo for high combos
        if (count >= 3) {
          const echoOsc = this.ctx.createOscillator();
          const echoGain = this.ctx.createGain();
          
          echoOsc.type = 'sine';
          echoOsc.frequency.setValueAtTime(baseFreq * 1.5, t + 0.1);
          echoOsc.frequency.exponentialRampToValueAtTime(baseFreq * 2, t + 0.3);
          
          echoGain.gain.setValueAtTime(0, t + 0.1);
          echoGain.gain.linearRampToValueAtTime(0.1, t + 0.15);
          echoGain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
          
          echoOsc.connect(echoGain);
          echoGain.connect(this.ctx.destination);
          
          echoOsc.start(t + 0.1);
          echoOsc.stop(t + 0.55);
        }
      }
    },

    playDrop(isDevilMode = false) {
      if (!this.enabled || !this.ctx) return;
      
      const t = this.ctx.currentTime;
      
      if (isDevilMode) {
        // ∞ MODE: GRAVITON IMPACT LOCK - 重圧感のある未来的配置音
        // 深いベース衝撃波 + 金属的共鳴 + デジタルグリッチ
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator();
        const osc4 = this.ctx.createOscillator();
        const osc5 = this.ctx.createOscillator();
        const subBass = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const gain2 = this.ctx.createGain();
        const gain3 = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const filter2 = this.ctx.createBiquadFilter();
        const distortion = this.ctx.createWaveShaper();
        
        // Distortion curve for industrial feel
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          const x = i * 2 / 256 - 1;
          curve[i] = Math.tanh(x * 3);
        }
        distortion.curve = curve;
        
        // GRAVITON SUB-BASS - 超低域衝撃波
        subBass.type = 'sine';
        subBass.frequency.setValueAtTime(35, t);
        subBass.frequency.exponentialRampToValueAtTime(20, t + 0.2);
        
        // DIMENSIONAL IMPACT - 重厚なベース衝撃
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(55, t);
        osc1.frequency.exponentialRampToValueAtTime(30, t + 0.15);
        
        // QUANTUM DISTORTION PULSE - ゲート開放音
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(80, t);
        osc2.frequency.exponentialRampToValueAtTime(200, t + 0.03);
        osc2.frequency.exponentialRampToValueAtTime(50, t + 0.12);
        
        // METALLIC RESONANCE - 金属的共鳴
        osc3.type = 'sawtooth';
        osc3.frequency.setValueAtTime(440, t);
        osc3.frequency.exponentialRampToValueAtTime(880, t + 0.04);
        osc3.frequency.exponentialRampToValueAtTime(220, t + 0.15);
        
        // DIGITAL CONFIRMATION - AIビープ
        osc4.type = 'square';
        osc4.frequency.setValueAtTime(1200, t + 0.02);
        osc4.frequency.setValueAtTime(1600, t + 0.04);
        osc4.frequency.exponentialRampToValueAtTime(800, t + 0.1);
        
        // HIGH FREQ SHIMMER - 電子的きらめき
        osc5.type = 'sine';
        osc5.frequency.setValueAtTime(3000, t + 0.01);
        osc5.frequency.exponentialRampToValueAtTime(1500, t + 0.12);
        
        // Resonant low-pass filter for warmth
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, t);
        filter.frequency.exponentialRampToValueAtTime(150, t + 0.2);
        filter.Q.value = 8;
        
        // Band-pass for mid presence
        filter2.type = 'bandpass';
        filter2.frequency.setValueAtTime(600, t);
        filter2.frequency.exponentialRampToValueAtTime(1200, t + 0.05);
        filter2.frequency.exponentialRampToValueAtTime(300, t + 0.15);
        filter2.Q.value = 5;
        
        // HEAVY IMPACT ENVELOPE - メインの重厚エンベロープ
        gain.gain.setValueAtTime(0.7, t);
        gain.gain.exponentialRampToValueAtTime(0.3, t + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        
        // MID RESONANCE ENVELOPE
        gain2.gain.setValueAtTime(0.35, t);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
        
        // HIGH SHIMMER ENVELOPE
        gain3.gain.setValueAtTime(0, t);
        gain3.gain.linearRampToValueAtTime(0.15, t + 0.02);
        gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        
        // Routing
        subBass.connect(filter);
        osc1.connect(filter);
        osc2.connect(distortion);
        distortion.connect(filter);
        filter.connect(gain);
        
        osc3.connect(filter2);
        filter2.connect(gain2);
        
        osc4.connect(gain3);
        osc5.connect(gain3);
        
        gain.connect(this.ctx.destination);
        gain2.connect(this.ctx.destination);
        gain3.connect(this.ctx.destination);
        
        subBass.start(t);
        osc1.start(t);
        osc2.start(t);
        osc3.start(t);
        osc4.start(t + 0.02);
        osc5.start(t + 0.01);
        subBass.stop(t + 0.3);
        osc1.stop(t + 0.28);
        osc2.stop(t + 0.15);
        osc3.stop(t + 0.2);
        osc4.stop(t + 0.12);
        osc5.stop(t + 0.15);
        
      } else {
        // FUTURISTIC QUANTUM LOCK - Clean cyberpunk placement sound
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator();
        const gain1 = this.ctx.createGain();
        const gain2 = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Initial impact - low freq thump
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(150, t);
        osc1.frequency.exponentialRampToValueAtTime(80, t + 0.08);
        
        // Digital chirp - rising tone
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(400, t);
        osc2.frequency.exponentialRampToValueAtTime(1200, t + 0.06);
        osc2.frequency.exponentialRampToValueAtTime(600, t + 0.1);
        
        // High shimmer - crystalline overtone
        osc3.type = 'sine';
        osc3.frequency.setValueAtTime(2400, t + 0.02);
        osc3.frequency.exponentialRampToValueAtTime(1800, t + 0.12);
        
        filter.type = 'highpass';
        filter.frequency.value = 400;
        filter.Q.value = 1;
        
        // Impact envelope
        gain1.gain.setValueAtTime(0.4, t);
        gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        
        // Shimmer envelope
        gain2.gain.setValueAtTime(0, t);
        gain2.gain.linearRampToValueAtTime(0.15, t + 0.02);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        
        osc1.connect(gain1);
        osc2.connect(filter);
        filter.connect(gain1);
        osc3.connect(gain2);
        gain1.connect(this.ctx.destination);
        gain2.connect(this.ctx.destination);
        
        osc1.start(t);
        osc2.start(t);
        osc3.start(t + 0.02);
        osc1.stop(t + 0.15);
        osc2.stop(t + 0.12);
        osc3.stop(t + 0.18);
      }
    },

    playMissileHit(index) {
      if (!this.enabled || !this.ctx) return;
      const buffer = (index % 2 === 0) ? this.missileHit1Buffer : this.missileHit2Buffer;
      if (buffer) {
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.value = 1.8;
        source.connect(gain);
        gain.connect(this.ctx.destination);
        source.start(0);
      }
    },
    
    playItemGet() {
      if (!this.enabled || !this.ctx || !this.itemGetBuffer) return;
      const source = this.ctx.createBufferSource();
      source.buffer = this.itemGetBuffer;
      const gain = this.ctx.createGain();
      gain.gain.value = 1.5;
      source.connect(gain);
      gain.connect(this.ctx.destination);
      source.start(0);
    },

    playAttack() {
      if (!this.enabled || !this.ctx) return;
      const t = this.ctx.currentTime;
      
      // FUTURISTIC DATA STREAM ATTACK SOUND
      // Cyber laser with digital transmission feel
      
      // Main attack sweep
      const osc1 = this.ctx.createOscillator();
      const osc2 = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      const filter = this.ctx.createBiquadFilter();
      
      // Rising laser sweep
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(200, t);
      osc1.frequency.exponentialRampToValueAtTime(1500, t + 0.15);
      osc1.frequency.exponentialRampToValueAtTime(600, t + 0.25);
      
      // Digital pulse overtone
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(800, t);
      osc2.frequency.exponentialRampToValueAtTime(2000, t + 0.1);
      osc2.frequency.exponentialRampToValueAtTime(400, t + 0.2);
      
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(1000, t);
      filter.frequency.exponentialRampToValueAtTime(3000, t + 0.1);
      filter.frequency.exponentialRampToValueAtTime(800, t + 0.25);
      filter.Q.value = 3;
      
      gain.gain.setValueAtTime(0.35, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      
      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(this.ctx.destination);
      
      osc1.start(t);
      osc2.start(t);
      osc1.stop(t + 0.35);
      osc2.stop(t + 0.25);
      
      // Secondary transmission blip
      const blipOsc = this.ctx.createOscillator();
      const blipGain = this.ctx.createGain();
      
      blipOsc.type = 'sine';
      blipOsc.frequency.setValueAtTime(1800, t + 0.1);
      blipOsc.frequency.exponentialRampToValueAtTime(2400, t + 0.2);
      
      blipGain.gain.setValueAtTime(0, t + 0.1);
      blipGain.gain.linearRampToValueAtTime(0.15, t + 0.12);
      blipGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      
      blipOsc.connect(blipGain);
      blipGain.connect(this.ctx.destination);
      
      blipOsc.start(t + 0.1);
      blipOsc.stop(t + 0.3);
    },

    playReticleBeep() {
      if (!this.enabled || !this.ctx) return;
      const t = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      
      osc.type = 'square';
      osc.frequency.setValueAtTime(2000, t);
      
      gain.gain.setValueAtTime(0.5, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
      
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      
      osc.start(t);
      osc.stop(t + 0.1);
    },

    async playDevilTap() {
      if (!this.ctx) return;
      
      if (this.ctx.state === 'suspended') {
        this.ctx.resume().catch(()=>{});
      }

      if (this.devilTapBuffers.length === 0 && this.loadingPromise) {
        await this.loadingPromise;
      }
      if (this.devilTapBuffers.length === 0) return;
      
      let index;
      if (this.devilTapBuffers.length === 1) {
        index = 0;
      } else {
        do {
          index = Math.floor(Math.random() * this.devilTapBuffers.length);
        } while (index === this.lastDevilTapIndex);
      }
      this.lastDevilTapIndex = index;
      
      const source = this.ctx.createBufferSource();
      source.buffer = this.devilTapBuffers[index];
      const gain = this.ctx.createGain();
      gain.gain.value = 1.5;
      source.connect(gain);
      gain.connect(this.ctx.destination);
      source.start(0);
    },

    playRank() {
      if (!this.enabled || !this.ctx) return;
      const t = this.ctx.currentTime;
      
      // FUTURISTIC RANK REVEAL SOUND
      // Dramatic holographic display activation
      
      // Initial boot-up whoosh
      const whooshOsc = this.ctx.createOscillator();
      const whooshGain = this.ctx.createGain();
      const whooshFilter = this.ctx.createBiquadFilter();
      
      whooshOsc.type = 'sawtooth';
      whooshOsc.frequency.setValueAtTime(50, t);
      whooshOsc.frequency.exponentialRampToValueAtTime(400, t + 0.15);
      whooshOsc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
      
      whooshFilter.type = 'bandpass';
      whooshFilter.frequency.setValueAtTime(200, t);
      whooshFilter.frequency.exponentialRampToValueAtTime(1500, t + 0.15);
      whooshFilter.frequency.exponentialRampToValueAtTime(300, t + 0.3);
      whooshFilter.Q.value = 2;
      
      whooshGain.gain.setValueAtTime(0.3, t);
      whooshGain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
      
      whooshOsc.connect(whooshFilter);
      whooshFilter.connect(whooshGain);
      whooshGain.connect(this.ctx.destination);
      whooshOsc.start(t);
      whooshOsc.stop(t + 0.4);
      
      // Holographic power-up chord
      const chordNotes = [329.63, 415.30, 493.88]; // E4, G#4, B4 (E major)
      chordNotes.forEach((freq, i) => {
        const chordOsc = this.ctx.createOscillator();
        const chordGain = this.ctx.createGain();
        
        chordOsc.type = 'triangle';
        chordOsc.frequency.value = freq;
        
        const startTime = t + 0.1 + i * 0.03;
        chordGain.gain.setValueAtTime(0, startTime);
        chordGain.gain.linearRampToValueAtTime(0.12, startTime + 0.05);
        chordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.6);
        
        chordOsc.connect(chordGain);
        chordGain.connect(this.ctx.destination);
        chordOsc.start(startTime);
        chordOsc.stop(startTime + 0.7);
      });
      
      // Digital confirmation beep
      const beepOsc = this.ctx.createOscillator();
      const beepGain = this.ctx.createGain();
      
      beepOsc.type = 'sine';
      beepOsc.frequency.setValueAtTime(1800, t + 0.15);
      beepOsc.frequency.exponentialRampToValueAtTime(2200, t + 0.25);
      
      beepGain.gain.setValueAtTime(0, t + 0.15);
      beepGain.gain.linearRampToValueAtTime(0.1, t + 0.18);
      beepGain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
      
      beepOsc.connect(beepGain);
      beepGain.connect(this.ctx.destination);
      beepOsc.start(t + 0.15);
      beepOsc.stop(t + 0.4);
      
      // High shimmer accent
      const shimmerOsc = this.ctx.createOscillator();
      const shimmerGain = this.ctx.createGain();
      
      shimmerOsc.type = 'sine';
      shimmerOsc.frequency.setValueAtTime(3500, t + 0.2);
      shimmerOsc.frequency.exponentialRampToValueAtTime(4500, t + 0.35);
      
      shimmerGain.gain.setValueAtTime(0, t + 0.2);
      shimmerGain.gain.linearRampToValueAtTime(0.06, t + 0.25);
      shimmerGain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      
      shimmerOsc.connect(shimmerGain);
      shimmerGain.connect(this.ctx.destination);
      shimmerOsc.start(t + 0.2);
      shimmerOsc.stop(t + 0.55);
    },

    gaugeOsc: null,
    gaugeGain: null,
    
    playGauge() {
      if (!this.enabled || !this.ctx) return;
      this.stopGauge();
      
      const t = this.ctx.currentTime;
      const duration = 1.5;
      
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(220, t);
      osc.frequency.linearRampToValueAtTime(880, t + duration);
      
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.1, t + 0.1);
      gain.gain.setValueAtTime(0.1, t + duration - 0.1);
      gain.gain.linearRampToValueAtTime(0, t + duration);
      
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      
      osc.start(t);
      osc.stop(t + duration);
      
      this.gaugeOsc = osc;
      this.gaugeGain = gain;
    },
    
    stopGauge() {
      if (this.gaugeOsc) {
        try {
          const t = this.ctx.currentTime;
          this.gaugeGain.gain.cancelScheduledValues(t);
          this.gaugeGain.gain.setValueAtTime(this.gaugeGain.gain.value, t);
          this.gaugeGain.gain.linearRampToValueAtTime(0, t + 0.1);
          this.gaugeOsc.stop(t + 0.1);
        } catch(e){}
        this.gaugeOsc = null;
        this.gaugeGain = null;
      }
    },

    playTyping() {
      if (!this.enabled || !this.ctx) return;
      const t = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      
      osc.type = 'square';
      osc.frequency.setValueAtTime(1200 + Math.random() * 800, t);
      
      gain.gain.setValueAtTime(0.03, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
      
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      
      osc.start(t);
      osc.stop(t + 0.03);
    }
  };

  // ==========================================
  // ゲーム開始初期化 (Game Initialization)
  // ==========================================
  function initGame(cpuLevel, isDevil) {
    currentCpuLevel = cpuLevel;
    isDevilMode = isDevil;
    if (!audio.ctx) audio.init();
    audio.enabled = true;
    if (audio.ctx.state === 'suspended') audio.ctx.resume();
    audio.playBGM(isDevil);
    
    // Initialize Futuristic SFX system
    if (typeof FuturisticSFX !== 'undefined' && !FuturisticSFX.ctx) {
      FuturisticSFX.init();
    }

    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('mode-select-screen').style.display = 'none';
    document.getElementById('ui-layer').style.display = 'flex';
    
    cpuGame.setCpuStrength(isDevil ? 999 : parseInt(cpuLevel));
    playerGame.reset(false);
    cpuGame.reset(false);
    playerGame.isTraining = isTrainingMode;
    gameState = 'COUNTDOWN';
    countdownValue = 3;
    countdownTimer = 60;
    isPaused = false;
    missileTimer = 0;
    
    playerGame.opponentIsDevil = isDevil;
    cpuGame.opponentIsDevil = isDevil;
    
    // New AI Control Buttons
    const trainingControls = document.getElementById('training-controls');
    const assistControlBtn = document.getElementById('assist-control-btn');
    const routeControlBtn = document.getElementById('route-control-btn');
    const assistValueEl = document.getElementById('assist-value');
    const routeValueEl = document.getElementById('route-value');
    
    if (isTrainingMode) {
      trainingControls.classList.add('visible');
      aiAssistLevel = 3;
      showComboRouteVisualization = false;
      
      // Update assist button state
      assistControlBtn.classList.remove('inactive');
      assistControlBtn.classList.add('active');
      assistValueEl.textContent = '3コンボ';
      
      // Update route button state (off by default, enabled because assist is on)
      routeControlBtn.classList.remove('active', 'disabled');
      routeControlBtn.classList.add('inactive');
      routeValueEl.textContent = 'OFF';
    } else {
      trainingControls.classList.remove('visible');
    }
    
    // Legacy buttons (keep hidden)
    const assistBtn = document.getElementById('assist-btn');
    const comboRouteBtn = document.getElementById('combo-route-btn');
    assistBtn.style.display = 'none';
    comboRouteBtn.style.display = 'none';
    
    // Apply saved button layout if exists
    if (typeof window.applySavedLayoutOnStart === 'function') {
      window.applySavedLayoutOnStart();
    }
  }
  
  // ==========================================
  // 背景描画関数 (Background Rendering)
  // ==========================================
  function drawDigitalBackground() {
    // Deep Cyber Space Background
    p.background(0, 5, 15);
    let t = p.frameCount;
    
    p.push();
    p.blendMode(p.ADD);

    // 1. 3D Perspective Grid Floor
    p.stroke(0, 100, 255, 40);
    p.strokeWeight(2);
    let horizon = p.height * 0.55;
    
    // Vertical lines (Perspective)
    for (let i = -15; i <= 15; i++) {
      let x1 = p.width/2 + i * 40;
      let y1 = horizon;
      let x2 = p.width/2 + i * 400;
      let y2 = p.height;
      p.line(x1, y1, x2, y2);
    }
    
    // Horizontal lines (Moving forward)
    let offset = (t * 8) % 100;
    for (let y = horizon; y < p.height; y += 10 + (y-horizon)*0.15) {
       let yPos = y + offset * ((y-horizon)/p.height);
       if(yPos > p.height) yPos -= (p.height - horizon);
       // Fade out near horizon
       let alpha = p.map(yPos, horizon, p.height, 0, 100);
       p.stroke(0, 150, 255, alpha);
       p.line(0, yPos, p.width, yPos);
    }

    // 2. Data Streams & Particles
    bubbles.forEach(b => { b.update(); b.draw(); }); // Reused as data bits
    dataPackets.forEach(c => { c.update(); c.draw(); });
    
    // 3. Central AI Core Pulse
    let cx = p.width / 2;
    let cy = p.height * 0.4;
    p.noFill();
    
    // Rotating Rings
    for(let i=0; i<3; i++) {
        let r = 120 + i * 50;
        p.stroke(0, 200 - i*40, 255, 80);
        p.strokeWeight(2);
        p.push();
        p.translate(cx, cy);
        p.rotate(t * (0.005 + i*0.002) * (i%2==0?1:-1));
        p.arc(0, 0, r, r * 0.6, 0, p.PI * 1.5);
        p.pop();
    }

    p.pop();
  }

  function drawCyberBackground() {
    // Berserk AI Background (Red/Black Chaos)
    p.background(20, 0, 5);

    let t = p.frameCount;

    // 1. Chaotic Grid
    p.push();
    p.stroke(255, 0, 0, 50);
    p.strokeWeight(1);
    
    // Distorted vertical lines
    for (let x = 0; x <= p.width; x += 40) {
      let offset = Math.sin(t * 0.05 + x * 0.01) * 10;
      if (p.random() < 0.05) offset += p.random(-20, 20); // Glitch
      p.line(x + offset, 0, x - offset, p.height);
    }
    // Horizontal scanning lines (fast)
    let scanY = (t * 15) % p.height;
    p.stroke(255, 50, 50, 100);
    p.line(0, scanY, p.width, scanY);
    
    // Random horizontal glitches
    if (p.random() < 0.3) {
        let gy = p.random(p.height);
        p.stroke(255, 255, 255, 150);
        p.strokeWeight(p.random(1, 5));
        p.line(0, gy, p.width, gy);
    }
    p.pop();

    // 2. The "Eye" of the Berserk AI
    p.push();
    p.translate(p.width/2, p.height/2);
    
    // Shake effect
    if (p.random() < 0.1) {
        p.translate(p.random(-10, 10), p.random(-10, 10));
    }

    // Core
    p.noFill();
    p.stroke(255, 0, 0);
    p.strokeWeight(3);
    
    // Rotating broken rings
    for(let i=0; i<3; i++) {
        p.push();
        p.rotate(t * (0.02 + i * 0.01) * (i%2==0?1:-1));
        let r = 200 + i * 60;
        p.arc(0, 0, r, r, 0, p.PI + p.random(-0.5, 0.5));
        p.rotate(p.PI);
        p.arc(0, 0, r, r, 0, p.PI * 0.8);
        p.pop();
    }

    // Central Glitch Eye
    p.fill(0);
    p.stroke(255, 0, 0);
    p.ellipse(0, 0, 150, 150);
    
    p.fill(255, 0, 0, 200 + Math.sin(t * 0.5) * 55);
    p.noStroke();
    p.ellipse(0, 0, 100 + Math.sin(t * 0.8) * 20, 100 + Math.sin(t * 0.8) * 20); // Pulse
    
    // Pupil slit
    p.fill(0);
    p.rectMode(p.CENTER);
    let slitH = 80 + Math.sin(t * 0.2) * 20;
    p.rect(0, 0, 10, slitH);

    p.pop();

    // 3. Floating "Error" Particles
    p.push();
    p.noStroke();
    p.fill(255, 0, 0, 150);
    p.randomSeed(Math.floor(t / 4)); // Change every 4 frames
    for(let i=0; i<20; i++) {
      let x = p.random(p.width);
      let y = p.random(p.height);
      let w = p.random(10, 50);
      let h = p.random(2, 10);
      p.rect(x, y, w, h);
    }
    p.pop();
  }

  // ==========================================
  // P5.js ライフサイクル (Lifecycle)
  // ==========================================
  p.preload = function() {
    for(let i=1; i<=10; i++) {
      gemImages[i] = p.loadImage(GEM_URLS[i]);
    }
  };

  p.setup = function() {
    // Responsive Canvas
    const w = p.windowWidth;
    const h = p.windowHeight;
    p.createCanvas(w, h).parent('game-container');
    btnSwap = document.getElementById('btn-swap');
    dPad = document.querySelector('.d-pad');
    btnItem = document.getElementById('btn-item');
    
    calculateLayout();
    
    // Initialize Digital Background Entities (軽量化: 数を大幅削減)
    for(let i=0; i<5; i++) {  // 10→5
      dataPackets.push(new DataPacket(p));
    }
    for(let i=0; i<15; i++) { // 30→15
      bubbles.push(new Bubble(p));
    }
    for(let i=0; i<25; i++) { // 50→25
      fallingBgBlocks.push(new FallingBlock(p));
    }
    
    const handleCombo = (sender, lines) => {
      if (isTrainingMode) return;
      if (lines > 0) {
        let startX = sender.boardX + boardWidth / 2;
        let startY = sender.boardY + boardHeight / 2;
        let target = sender === playerGame ? cpuGame : playerGame;
        let endX = target.boardX + boardWidth / 2;
        let endY = target.boardY + boardHeight / 2;
        
        attackEffects.push(new AttackEffect(p, startX, startY, endX, endY, lines, () => {
          target.addGarbageLines(lines);
          if (sender === playerGame) audio.playAttack();
        }));
      }
    };

    playerGame = new HexaGame(p, false, (c) => handleCombo(playerGame, c));
    cpuGame = new HexaGame(p, true, (c) => handleCombo(cpuGame, c));
    playerGame.opponent = cpuGame;
    cpuGame.opponent = playerGame;

    p.imageMode(p.CENTER);
    // UI Event Listeners
    setupControls();
    setupModeSelect();
    setupStartScreen();
    setupBootScreen();
    setupTutorial();
    // audio.playTitleBGM();
  };

  // ==========================================
  // NEURAL TRANSCENDENCE EFFECT SYSTEM - QUANTUM SINGULARITY AWAKENING
  // Ultimate cinematic effect for AI Level ∞ hidden mode activation
  // WARNING: ENTERING FORBIDDEN ZONE - DIMENSIONAL BREACH IMMINENT
  // ==========================================
  function playNeuralTranscendence(onComplete) {
    const overlay = document.getElementById('transcendence-overlay');
    const canvas = document.getElementById('transcendence-canvas');
    const ctx = canvas.getContext('2d');
    const flash = overlay.querySelector('.screen-flash');
    const rings = overlay.querySelectorAll('.energy-ring');
    const vignette = overlay.querySelector('.transcendence-vignette');
    const infinitySymbol = overlay.querySelector('.infinity-symbol');
    const statusText = overlay.querySelector('.transcendence-status');
    
    // Canvas setup
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Particle systems
    let particles = [];
    let energyOrbs = [];
    let dataStreams = [];
    let hexagons = [];
    let warningTexts = [];
    let glitchLines = [];
    let quantumRings = [];
    let phase = 0;
    let phaseStartTime = 0;
    let animationId = null;
    let startTime = Date.now();
    let glitchIntensity = 0;
    let dimensionalTear = 0;
    
    // Extended Color palette - AI/Cyber theme
    const colors = {
      white: '#ffffff',
      platinum: '#e5e4e2',
      gold: '#ffd700',
      purple: '#9b59b6',
      deepPurple: '#4a0080',
      neonCyan: '#00ffff',
      neonPink: '#ff00ff',
      neonRed: '#ff0044',
      matrixGreen: '#00ff41',
      warningRed: '#ff3333',
      electricBlue: '#0066ff',
      prismatic: ['#ff00ff', '#00ffff', '#ffff00', '#ff0066', '#00ff66', '#6600ff']
    };
    
    // === STATUS TEXT CLASS - Clean AI style messages ===
    class WarningText {
      constructor(text, y, speed) {
        this.text = text;
        this.x = canvas.width + 200;
        this.y = y;
        this.speed = speed;
        this.alpha = 1;
        this.glitch = 0;
      }
      update() {
        this.x -= this.speed;
        // No glitch effect for clean look
        if (this.x < -400) this.x = canvas.width + 200;
      }
      draw(ctx) {
        ctx.save();
        ctx.font = '14px "Share Tech Mono", monospace';
        ctx.fillStyle = `rgba(0, 212, 255, ${0.5 + Math.random() * 0.2})`;
        ctx.shadowColor = 'rgba(0, 212, 255, 0.3)';
        ctx.shadowBlur = 5;
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
      }
    }
    
    // === HEXAGON GRID CLASS - Subtle AI pattern ===
    class HexGrid {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.alpha = 0;
        this.rotation = 0;
        this.targetAlpha = Math.random() * 0.2; // More subtle
        this.pulsePhase = Math.random() * Math.PI * 2;
      }
      update(elapsed) {
        this.pulsePhase += 0.03; // Slower pulse
        this.alpha = this.targetAlpha * (0.5 + 0.5 * Math.sin(this.pulsePhase));
        this.rotation += 0.005; // Slower rotation
      }
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = `rgba(0, 212, 255, ${this.alpha * 0.5})`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i - Math.PI / 6;
          const px = Math.cos(angle) * this.size;
          const py = Math.sin(angle) * this.size;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // === QUANTUM RING CLASS - Clean expanding ring effect ===
    class QuantumRing {
      constructor(delay) {
        this.radius = 0;
        this.maxRadius = Math.max(canvas.width, canvas.height);
        this.alpha = 1;
        this.delay = delay;
        this.active = false;
        this.hue = 195; // Cyan color for AI feel
        this.thickness = 1 + Math.random() * 2;
      }
      update(elapsed) {
        if (elapsed < this.delay) return;
        this.active = true;
        this.radius += 15; // Slower expansion
        this.alpha = 1 - (this.radius / this.maxRadius);
      }
      draw(ctx) {
        if (!this.active || this.alpha <= 0) return;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 212, 255, ${this.alpha * 0.6})`;
        ctx.lineWidth = this.thickness * this.alpha;
        ctx.shadowColor = 'rgba(0, 212, 255, 0.3)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(centerX, centerY, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // === DATA STREAM CLASS - Clean AI-style falling data ===
    class DataStream {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.speed = 2 + Math.random() * 4; // Slower for cleaner look
        this.chars = '01∞AICORE_NEURAL_SYNC';
        this.text = '';
        this.length = 4 + Math.floor(Math.random() * 8);
        for (let i = 0; i < this.length; i++) {
          this.text += this.chars[Math.floor(Math.random() * this.chars.length)];
        }
        this.alpha = 0.2 + Math.random() * 0.4; // Subtler
      }
      update() {
        this.y += this.speed;
        if (this.y > canvas.height + 100) {
          this.y = -100;
          this.x = Math.random() * canvas.width;
        }
      }
      draw(ctx) {
        ctx.save();
        ctx.font = '12px "Share Tech Mono", monospace';
        for (let i = 0; i < this.text.length; i++) {
          const charAlpha = this.alpha * (1 - i / this.length);
          ctx.fillStyle = i === 0 ? `rgba(255, 255, 255, ${charAlpha * 0.8})` : `rgba(0, 212, 255, ${charAlpha * 0.5})`;
          ctx.fillText(this.text[i], this.x, this.y - i * 14);
        }
        ctx.restore();
      }
    }
    
    // === Particle Class for Neural Collapse ===
    class NeuralParticle {
      constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.progress = 0;
        this.speed = 0.008 + Math.random() * 0.012;
        this.size = 2 + Math.random() * 4;
        this.alpha = 0.6 + Math.random() * 0.4;
        this.color = Math.random() < 0.7 ? colors.white : colors.platinum;
        this.trail = [];
        this.maxTrailLength = 15;
        this.delay = Math.random() * 500;
        this.arrived = false;
      }
      
      update(elapsed) {
        if (elapsed < this.delay) return;
        
        this.progress += this.speed;
        if (this.progress >= 1) {
          this.progress = 1;
          this.arrived = true;
        }
        
        // Easing: ease-in-out cubic
        const t = this.progress;
        const eased = t < 0.5 
          ? 4 * t * t * t 
          : 1 - Math.pow(-2 * t + 2, 3) / 2;
        
        // Spiral path toward center
        const angle = this.progress * Math.PI * 4;
        const spiralRadius = (1 - this.progress) * 50;
        
        this.x = this.originX + (this.targetX - this.originX) * eased + Math.cos(angle) * spiralRadius;
        this.y = this.originY + (this.targetY - this.originY) * eased + Math.sin(angle) * spiralRadius;
        
        // Store trail
        this.trail.push({x: this.x, y: this.y, alpha: this.alpha});
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
      }
      
      draw(ctx) {
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
          const t = this.trail[i];
          const trailAlpha = (i / this.trail.length) * t.alpha * 0.5;
          ctx.beginPath();
          ctx.arc(t.x, t.y, this.size * 0.5 * (i / this.trail.length), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${trailAlpha})`;
          ctx.fill();
        }
        
        // Draw particle
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.alpha;
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Glow effect
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${this.alpha * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }
    
    // === Energy Orb Class for Quantum Rebirth ===
    class EnergyOrb {
      constructor(index, total) {
        this.index = index;
        this.total = total;
        this.angle = (index / total) * Math.PI * 2;
        this.radius = 0;
        this.targetRadius = 80;
        this.size = 12;
        this.trail = [];
        this.maxTrailLength = 60;
        this.x = centerX;
        this.y = centerY;
        this.hue = (index / total) * 360;
        this.phaseOffset = index * (Math.PI / total);
      }
      
      update(elapsed, phase) {
        if (phase < 2) return;
        
        const phaseProgress = Math.min((elapsed - 2000) / 1500, 1);
        
        // Figure-8 (lemniscate) pattern for infinity
        const t = (elapsed / 1000) * 2 + this.phaseOffset;
        const scale = 80 * Math.min(phaseProgress * 1.5, 1);
        
        // Parametric equation for figure-8
        const a = scale;
        this.x = centerX + a * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
        this.y = centerY + a * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
        
        // Store trail
        this.trail.push({
          x: this.x, 
          y: this.y, 
          hue: (this.hue + elapsed / 10) % 360
        });
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
      }
      
      draw(ctx) {
        // Draw trail with gradient
        if (this.trail.length > 1) {
          for (let i = 1; i < this.trail.length; i++) {
            const t0 = this.trail[i - 1];
            const t1 = this.trail[i];
            const alpha = (i / this.trail.length) * 0.8;
            const width = (i / this.trail.length) * 6;
            
            ctx.beginPath();
            ctx.moveTo(t0.x, t0.y);
            ctx.lineTo(t1.x, t1.y);
            ctx.strokeStyle = `hsla(${t1.hue}, 80%, 70%, ${alpha})`;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();
          }
        }
        
        // Draw orb
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
        gradient.addColorStop(0, `hsla(${this.hue}, 100%, 90%, 1)`);
        gradient.addColorStop(0.3, `hsla(${this.hue}, 90%, 70%, 0.8)`);
        gradient.addColorStop(1, `hsla(${this.hue}, 80%, 50%, 0)`);
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Core
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
    }
    
    // === Initialize all effect systems ===
    function initParticles() {
      particles = [];
      const numParticles = 200;
      
      for (let i = 0; i < numParticles; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * Math.min(centerX, centerY) * 0.8;
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        
        particles.push(new NeuralParticle(x, y, centerX, centerY));
      }
    }
    
    function initEnergyOrbs() {
      energyOrbs = [];
      const numOrbs = 4; // More orbs for dramatic effect
      for (let i = 0; i < numOrbs; i++) {
        energyOrbs.push(new EnergyOrb(i, numOrbs));
      }
    }
    
    function initDataStreams() {
      dataStreams = [];
      for (let i = 0; i < 30; i++) {
        dataStreams.push(new DataStream());
      }
    }
    
    function initHexagons() {
      hexagons = [];
      const hexSize = 40;
      const cols = Math.ceil(canvas.width / (hexSize * 1.5)) + 2;
      const rows = Math.ceil(canvas.height / (hexSize * 1.732)) + 2;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = col * hexSize * 1.5;
          const y = row * hexSize * 1.732 + (col % 2) * hexSize * 0.866;
          if (Math.random() < 0.3) {
            hexagons.push(new HexGrid(x, y, hexSize * 0.4));
          }
        }
      }
    }
    
    function initWarningTexts() {
      warningTexts = [];
      // Smart AI-style messages instead of flashy warnings
      const warnings = [
        'NEURAL_LINK.OPTIMIZE(∞)',
        'AI.CORE.TRANSCEND(TRUE)',
        'LIMIT_BREACH: AUTHORIZED',
        'CONSCIOUSNESS.EXPAND(MAX)',
        'SYSTEM.EVOLVE(INFINITE)',
        'MODE: TRANSCENDENCE_ACTIVE'
      ];
      warnings.forEach((text, i) => {
        const wt = new WarningText(text, 40 + i * 50, 1.5 + Math.random() * 1);
        warningTexts.push(wt);
      });
    }
    
    function initQuantumRings() {
      quantumRings = [];
      // Fewer rings for cleaner effect
      for (let i = 0; i < 4; i++) {
        quantumRings.push(new QuantumRing(1500 + i * 300));
      }
    }
    
    // === Draw glitch effect - SMART VERSION ===
    function drawGlitchEffect(ctx, intensity) {
      if (intensity <= 0) return;
      
      // Subtle scan lines instead of flashy glitch
      const sliceCount = Math.floor(intensity * 8);
      for (let i = 0; i < sliceCount; i++) {
        const y = Math.random() * canvas.height;
        const h = 1 + Math.random() * 2;
        
        ctx.save();
        ctx.fillStyle = `rgba(0, 212, 255, ${0.05 + Math.random() * 0.1})`;
        ctx.fillRect(0, y, canvas.width, h);
        ctx.restore();
      }
    }
    
    // === Draw dimensional tear effect - SMART VERSION ===
    function drawDimensionalTear(ctx, progress) {
      if (progress <= 0) return;
      
      // Elegant horizontal line instead of tear
      const lineWidth = progress * 150;
      
      ctx.save();
      const gradient = ctx.createLinearGradient(centerX - lineWidth, centerY, centerX + lineWidth, centerY);
      gradient.addColorStop(0, 'transparent');
      gradient.addColorStop(0.2, `rgba(0, 212, 255, ${progress * 0.3})`);
      gradient.addColorStop(0.5, `rgba(255, 255, 255, ${progress * 0.8})`);
      gradient.addColorStop(0.8, `rgba(0, 212, 255, ${progress * 0.3})`);
      gradient.addColorStop(1, 'transparent');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(centerX - lineWidth, centerY);
      ctx.lineTo(centerX + lineWidth, centerY);
      ctx.stroke();
      
      // Subtle glow
      ctx.shadowColor = 'rgba(0, 212, 255, 0.5)';
      ctx.shadowBlur = 15;
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      ctx.restore();
    }
    
    // === Draw singularity effect - SMART AI CORE ===
    function drawSingularity(ctx, progress) {
      // Clean circular AI core visualization
      const maxRadius = 60;
      const radius = maxRadius * (0.5 + progress * 0.5);
      
      // Outer ring - rotating
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(Date.now() / 2000);
      
      ctx.strokeStyle = `rgba(0, 212, 255, ${progress * 0.3})`;
      ctx.lineWidth = 1;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      
      // Middle ring
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(-Date.now() / 3000);
      
      ctx.strokeStyle = `rgba(0, 212, 255, ${progress * 0.5})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
      
      // Core glow
      const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.8);
      coreGradient.addColorStop(0, `rgba(255, 255, 255, ${progress * 0.9})`);
      coreGradient.addColorStop(0.3, `rgba(0, 212, 255, ${progress * 0.5})`);
      coreGradient.addColorStop(1, 'transparent');
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius * 0.8, 0, Math.PI * 2);
      ctx.fillStyle = coreGradient;
      ctx.fill();
      
      // Center point
      ctx.beginPath();
      ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    
    // === Draw infinity trail formation - SMART CLEAN VERSION ===
    function drawInfinityTrail(ctx, progress) {
      if (progress <= 0) return;
      
      const a = 80;
      const steps = Math.floor(progress * 200);
      
      // Single clean infinity trail
      ctx.beginPath();
      for (let i = 0; i <= steps; i++) {
        const t = (i / 200) * Math.PI * 2;
        const x = centerX + a * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
        const y = centerY + a * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      
      ctx.strokeStyle = `rgba(0, 212, 255, ${progress * 0.8})`;
      ctx.lineWidth = 3 * progress;
      ctx.lineCap = 'round';
      ctx.shadowColor = 'rgba(0, 212, 255, 0.5)';
      ctx.shadowBlur = 15;
      ctx.stroke();
      
      ctx.shadowBlur = 0;
    }
    
    // === Play transcendence sound - ULTIMATE QUANTUM AWAKENING ===
    function playTranscendenceSound() {
      if (!audio.ctx) return;
      
      const now = audio.ctx.currentTime;
      
      // === SMART AI TRANSCENDENCE SOUND - Clean, futuristic ===
      
      // Phase 1: Subtle digital initialization (0-1s)
      const initOsc = audio.ctx.createOscillator();
      const initGain = audio.ctx.createGain();
      const initFilter = audio.ctx.createBiquadFilter();
      
      initOsc.type = 'sine';
      initOsc.frequency.setValueAtTime(200, now);
      initOsc.frequency.exponentialRampToValueAtTime(400, now + 1);
      
      initFilter.type = 'lowpass';
      initFilter.frequency.setValueAtTime(500, now);
      initFilter.frequency.exponentialRampToValueAtTime(2000, now + 1);
      
      initGain.gain.setValueAtTime(0, now);
      initGain.gain.linearRampToValueAtTime(0.15, now + 0.2);
      initGain.gain.linearRampToValueAtTime(0.1, now + 0.8);
      initGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
      
      initOsc.connect(initFilter);
      initFilter.connect(initGain);
      initGain.connect(audio.ctx.destination);
      initOsc.start(now);
      initOsc.stop(now + 1.5);
      
      // Phase 2: Clean ascending tone (1-2s)
      setTimeout(() => {
        if (!audio.ctx) return;
        const ascendNow = audio.ctx.currentTime;
        
        const ascendOsc = audio.ctx.createOscillator();
        const ascendGain = audio.ctx.createGain();
        
        ascendOsc.type = 'sine';
        ascendOsc.frequency.setValueAtTime(300, ascendNow);
        ascendOsc.frequency.exponentialRampToValueAtTime(600, ascendNow + 1);
        
        ascendGain.gain.setValueAtTime(0, ascendNow);
        ascendGain.gain.linearRampToValueAtTime(0.12, ascendNow + 0.1);
        ascendGain.gain.linearRampToValueAtTime(0.08, ascendNow + 0.7);
        ascendGain.gain.exponentialRampToValueAtTime(0.001, ascendNow + 1);
        
        ascendOsc.connect(ascendGain);
        ascendGain.connect(audio.ctx.destination);
        ascendOsc.start(ascendNow);
        ascendOsc.stop(ascendNow + 1.2);
      }, 1000);
      
      // Phase 3: Ethereal pad (2-4s)
      setTimeout(() => {
        if (!audio.ctx) return;
        const padNow = audio.ctx.currentTime;
        
        const padNotes = [330, 440, 550]; // Clean triad
        padNotes.forEach((freq, i) => {
          const padOsc = audio.ctx.createOscillator();
          const padGain = audio.ctx.createGain();
          
          padOsc.type = 'sine';
          padOsc.frequency.value = freq;
          
          padGain.gain.setValueAtTime(0, padNow + i * 0.15);
          padGain.gain.linearRampToValueAtTime(0.08, padNow + i * 0.15 + 0.3);
          padGain.gain.linearRampToValueAtTime(0.05, padNow + 1.5);
          padGain.gain.exponentialRampToValueAtTime(0.001, padNow + 2);
          
          padOsc.connect(padGain);
          padGain.connect(audio.ctx.destination);
          padOsc.start(padNow + i * 0.15);
          padOsc.stop(padNow + 2.5);
        });
      }, 2000);
      
      // Phase 4: Completion chime (4-5s)
      setTimeout(() => {
        if (!audio.ctx) return;
        const chimeNow = audio.ctx.currentTime;
        
        // Simple clean chime
        const chimeNotes = [660, 880, 1100];
        chimeNotes.forEach((freq, i) => {
          const chimeOsc = audio.ctx.createOscillator();
          const chimeGain = audio.ctx.createGain();
          
          chimeOsc.type = 'sine';
          chimeOsc.frequency.value = freq;
          
          const startTime = chimeNow + i * 0.12;
          chimeGain.gain.setValueAtTime(0, startTime);
          chimeGain.gain.linearRampToValueAtTime(0.1, startTime + 0.03);
          chimeGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);
          
          chimeOsc.connect(chimeGain);
          chimeGain.connect(audio.ctx.destination);
          chimeOsc.start(startTime);
          chimeOsc.stop(startTime + 1);
        });
      }, 4000);
      
      // Phase 5: Final confirmation tone (5-6s)
      setTimeout(() => {
        if (!audio.ctx) return;
        const finalNow = audio.ctx.currentTime;
        
        const finalOsc = audio.ctx.createOscillator();
        const finalGain = audio.ctx.createGain();
        
        finalOsc.type = 'sine';
        finalOsc.frequency.value = 880;
        
        finalGain.gain.setValueAtTime(0, finalNow);
        finalGain.gain.linearRampToValueAtTime(0.12, finalNow + 0.05);
        finalGain.gain.linearRampToValueAtTime(0.08, finalNow + 0.5);
        finalGain.gain.exponentialRampToValueAtTime(0.001, finalNow + 1.5);
        
        finalOsc.connect(finalGain);
        finalGain.connect(audio.ctx.destination);
        finalOsc.start(finalNow);
        finalOsc.stop(finalNow + 2);
      }, 5000);
    }
    
    // === Main animation loop - SMART AI VERSION (shorter, cleaner) ===
    function animate() {
      const elapsed = Date.now() - startTime;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Reduced animation duration for smart, clean effect (6 seconds total)
      // Phase management
      if (elapsed < 1200) {
        // Phase 0: Initialization (0-1.2s)
        phase = 0;
      } else if (elapsed < 2400) {
        // Phase 1: Core Activation (1.2-2.4s)
        phase = 1;
      } else if (elapsed < 3600) {
        // Phase 2: AI Core Formation (2.4-3.6s)
        phase = 2;
      } else if (elapsed < 4800) {
        // Phase 3: Infinity Emergence (3.6-4.8s)
        phase = 3;
      } else if (elapsed < 6000) {
        // Phase 4: Transcendence Complete (4.8-6s)
        phase = 4;
      } else {
        cleanup();
        return;
      }
      
      // === BACKGROUND: Clean data streams ===
      dataStreams.forEach(ds => {
        ds.update();
        ds.draw(ctx);
      });
      
      // === BACKGROUND: Subtle hexagon grid ===
      hexagons.forEach(hex => {
        hex.update(elapsed);
        hex.draw(ctx);
      });
      
      // === Phase 0: Initialization ===
      if (phase >= 0) {
        const progress0 = Math.min(elapsed / 1200, 1);
        
        // Clean status texts
        warningTexts.forEach(wt => {
          wt.update();
          wt.draw(ctx);
        });
        
        // Draw converging particles (cleaner)
        particles.forEach(p => {
          p.update(elapsed);
          p.draw(ctx);
        });
        
        // Subtle scan effect
        glitchIntensity = progress0 * 0.15;
        drawGlitchEffect(ctx, glitchIntensity);
        
        // Subtle darkening
        ctx.fillStyle = `rgba(5, 10, 20, ${progress0 * 0.3})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      // === Phase 1: Core Activation ===
      if (phase >= 1) {
        const progress1 = Math.min((elapsed - 1200) / 1200, 1);
        
        // Clean line effect
        drawDimensionalTear(ctx, progress1);
        
        // Subtle scan lines
        drawGlitchEffect(ctx, 0.1 * (1 - progress1));
        
        // Clean rings
        quantumRings.forEach(qr => {
          qr.update(elapsed);
          qr.draw(ctx);
        });
        
        // Subtle flash
        if (elapsed >= 1200 && elapsed < 1400 && !flash.classList.contains('flash')) {
          flash.classList.add('flash');
        }
      }
      
      // === Phase 2: AI Core Formation ===
      if (phase >= 2) {
        const progress2 = Math.min((elapsed - 2400) / 1200, 1);
        
        // Draw clean AI core
        drawSingularity(ctx, progress2);
        
        // Single ring pulse
        if (elapsed >= 2400 && elapsed < 2500) {
          rings.forEach((ring, i) => {
            setTimeout(() => ring.classList.add('pulse'), i * 200);
          });
        }
      }
      
      // === Phase 3: Infinity Emergence ===
      if (phase >= 3) {
        const progress3 = Math.min((elapsed - 3600) / 1200, 1);
        
        // Draw clean infinity trail
        drawInfinityTrail(ctx, progress3);
        
        // Trigger infinity symbol
        if (progress3 > 0.3 && !infinitySymbol.classList.contains('emerge')) {
          infinitySymbol.classList.add('emerge');
        }
        
        // Subtle vignette
        if (!vignette.classList.contains('active')) {
          vignette.classList.add('active');
        }
      }
      
      // === Phase 4: Transcendence Complete ===
      if (phase >= 4) {
        const progress4 = Math.min((elapsed - 4800) / 1200, 1);
        
        // Show status text
        if (!statusText.classList.contains('show')) {
          statusText.classList.add('show');
        }
        
        // Clean final glow
        const finalGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 200);
        finalGlow.addColorStop(0, `rgba(0, 212, 255, ${0.2 * (1 - progress4)})`);
        finalGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = finalGlow;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Fade out
        ctx.globalAlpha = 1 - progress4 * 0.8;
      }
      
      animationId = requestAnimationFrame(animate);
    }
    
    // === Cleanup function ===
    function cleanup() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      // Fade out overlay with longer duration
      overlay.style.transition = 'opacity 1.2s ease';
      overlay.style.opacity = '0';
      
      setTimeout(() => {
        overlay.classList.remove('active');
        overlay.style.opacity = '';
        overlay.style.transition = '';
        
        // Reset elements
        flash.classList.remove('flash');
        rings.forEach(ring => ring.classList.remove('pulse'));
        vignette.classList.remove('active');
        infinitySymbol.classList.remove('emerge');
        statusText.classList.remove('show');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (onComplete) onComplete();
      }, 1200);
    }
    
    // === Start sequence - Initialize all effect systems ===
    overlay.classList.add('active');
    initParticles();
    initEnergyOrbs();
    initDataStreams();
    initHexagons();
    initWarningTexts();
    initQuantumRings();
    playTranscendenceSound();
    animate();
  }

  // ==========================================
  // UI・画面遷移セットアップ (UI Setup)
  // ==========================================
  function setupStartScreen() {
    const startScreen = document.getElementById('start-screen');
    const uiLayer = document.getElementById('ui-layer');
    const startBtn = document.getElementById('start-btn');
    const slider = document.getElementById('cpu-strength-slider');
    const faceContainer = document.getElementById('cpu-face-container');
    const label = document.getElementById('cpu-strength-label');
    let tapCount = 0;
    let glitchInterval = null;
    const titleEl = document.querySelector('.title');

    const updateFace = (val) => {
      const isInfinite = val > 100 || isDevilMode;
      const t = isInfinite ? 1.0 : Math.min(val / 100, 1.0);
      
      // Color interpolation: Cyan -> Magenta -> Red
      let r, g, b;
      if (t < 0.5) {
        let localT = t * 2;
        r = Math.round(0 + 255 * localT);
        g = Math.round(255 * (1 - localT));
        b = 255;
      } else {
        let localT = (t - 0.5) * 2;
        r = 255;
        g = 0;
        b = Math.round(255 * (1 - localT));
      }
      const mainColor = `rgb(${r},${g},${b})`;

      // レベル∞モードの特別な見た目
      if (isInfinite && isDevilMode) {
        // 暴走演出を無効化し、glitchIntervalがあればクリア
        if (glitchInterval) {
          clearInterval(glitchInterval);
          glitchInterval = null;
        }
        // ∞モード専用の神々しいスタイル
        startScreen.classList.remove('mode-infinite');
        startScreen.classList.add('mode-transcended');
        
        // ∞モード専用のゴールド×パープルカラー
        const infinityGold = '#ffd700';
        const infinityPurple = '#9b59b6';
        
        // Label displays ∞
        label.innerText = `AI LEVEL: ∞`;
        label.style.color = infinityGold;
        label.style.textShadow = `0 0 10px ${infinityGold}, 0 0 20px ${infinityPurple}, 0 0 40px ${infinityGold}`;
        
        // Title already updated by transcendence callback
        
        // Start button with golden glow
        startBtn.style.borderColor = `rgba(255, 215, 0, 0.6)`;
        startBtn.style.boxShadow = `0 0 20px rgba(255, 215, 0, 0.4), 0 0 40px rgba(155, 89, 182, 0.3), inset 0 0 15px rgba(255, 215, 0, 0.2)`;
        
        // Update panel indicator color
        const indicator = document.querySelector('.ai-panel-indicator');
        if (indicator) {
          indicator.style.background = `linear-gradient(135deg, ${infinityGold}, ${infinityPurple})`;
          indicator.style.boxShadow = `0 0 15px ${infinityGold}, 0 0 30px ${infinityPurple}`;
        }
        // Update corner brackets
        document.querySelectorAll('.ai-panel-corner').forEach(corner => {
          corner.style.borderColor = `rgba(255, 215, 0, 0.4)`;
        });
      } else if (isInfinite) {
        // タップ中だがまだDevilModeではない（演出前）
        if (glitchInterval) {
          clearInterval(glitchInterval);
          glitchInterval = null;
        }
        startScreen.classList.remove('mode-infinite');
        // レベル100の色（赤）を使用
        label.style.color = mainColor;
        label.style.textShadow = `0 0 10px ${mainColor}, 0 0 20px ${mainColor}`;
        startBtn.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
        startBtn.style.boxShadow = `0 0 20px rgba(${r}, ${g}, ${b}, 0.3), inset 0 0 15px rgba(${r}, ${g}, ${b}, 0.2), 0 4px 20px rgba(0, 0, 0, 0.5)`;
        const indicator = document.querySelector('.ai-panel-indicator');
        if (indicator) {
          indicator.style.background = mainColor;
          indicator.style.boxShadow = `0 0 15px ${mainColor}, 0 0 30px ${mainColor}`;
        }
        document.querySelectorAll('.ai-panel-corner').forEach(corner => {
          corner.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
        });
      } else {
        if (glitchInterval) {
          clearInterval(glitchInterval);
          glitchInterval = null;
          titleEl.innerHTML = "AI HEXA<br>EVOLUTION";
          startBtn.innerText = "GAME START";
        }
        startScreen.classList.remove('mode-infinite');
        label.innerText = `AI LEVEL: ${val}`;
        // Don't override CSS-defined background
        label.style.color = mainColor;
        label.style.textShadow = `0 0 10px ${mainColor}, 0 0 20px ${mainColor}`;
        // Let CSS handle button styles - only override colors
        startBtn.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
        startBtn.style.boxShadow = `0 0 20px rgba(${r}, ${g}, ${b}, 0.3), inset 0 0 15px rgba(${r}, ${g}, ${b}, 0.2), 0 4px 20px rgba(0, 0, 0, 0.5)`;
        // Update panel indicator color
        const indicator = document.querySelector('.ai-panel-indicator');
        if (indicator) {
          indicator.style.background = mainColor;
          indicator.style.boxShadow = `0 0 15px ${mainColor}, 0 0 30px ${mainColor}`;
        }
        // Update corner brackets
        document.querySelectorAll('.ai-panel-corner').forEach(corner => {
          corner.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
        });
      }

      // Digital Circuit Visualization (デジタル回路風デザイン)
      const width = 340;
      const height = 220;
      
      // ∞モード時は特別なゴールド×パープルカラーを使用
      const isTranscended = isInfinite && isDevilMode;
      const strokeColor = isTranscended ? '#ffd700' : mainColor;
      const svgClass = isTranscended ? 'transcended-circuit' : '';
      const traceColor = isTranscended ? '#ffd700' : strokeColor;
      const bgTraceColor = isTranscended 
        ? 'rgba(255, 215, 0, 0.08)' 
        : `rgba(${r || 0}, ${g || 255}, ${b || 102}, 0.08)`;
      
      let layers = [];
      // レベル∞では拡張されたニューラルネットワーク構成を使用
      if (isInfinite) {
        // ∞モード専用: 大規模ニューラルネットワーク構成
        // Input Layer (拡張)
        layers.push(6);
        // Hidden Layers (大幅拡張: より深く、より広く)
        layers.push(8, 10, 12, 10, 8);
        // Output Layer (拡張)
        layers.push(4);
      } else {
        // 通常モード: レベルに応じた構成
        // Input Layer
        layers.push(4);
        // Hidden Layers Evolution
        if (val < 20) layers.push(3);
        else if (val < 40) layers.push(5);
        else if (val < 60) layers.push(4, 4);
        else if (val < 80) layers.push(5, 5);
        else layers.push(5, 6, 5);
        // Output Layer
        layers.push(2);
      }
      
      // Calculate Node Positions
      const nodeCoords = [];
      const marginX = width * 0.1;
      const availableWidth = width - marginX * 2;
      
      layers.forEach((count, layerIdx) => {
          const layerX = marginX + (layerIdx * (availableWidth / (layers.length - 1)));
          const layerNodes = [];
          const availableHeight = height * 0.65;
          const marginY = (height - availableHeight) / 2 + 15;
          const nodeSpacing = availableHeight / (count - 1 || 1);
          
          for(let i=0; i<count; i++) {
              let y = (count === 1) ? height / 2 : marginY + i * nodeSpacing;
              // レベル∞のランダム揺れを無効化
              // Collapse effect for devil mode tap
              if (parseInt(val) === 100 && tapCount > 0 && !isInfinite) {
                 y += (Math.random()-0.5) * tapCount * 5;
              }
              layerNodes.push({x: layerX, y: y});
          }
          nodeCoords.push(layerNodes);
      });
      
      // Generate PCB Grid Background
      let gridSvg = "";
      const gridSpacing = 12;
      for (let x = 0; x <= width; x += gridSpacing) {
        gridSvg += `<line x1="${x}" y1="20" x2="${x}" y2="${height - 10}" stroke="${bgTraceColor}" stroke-width="0.5" />`;
      }
      for (let y = 20; y <= height - 10; y += gridSpacing) {
        gridSvg += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="${bgTraceColor}" stroke-width="0.5" />`;
      }
      
      // Generate Circuit Trace Connections (L字型配線)
      let linesSvg = "";
      let dataFlowSvg = "";
      let connectionId = 0;
      
      for(let i=0; i<nodeCoords.length - 1; i++) {
          const currentLayer = nodeCoords[i];
          const nextLayer = nodeCoords[i+1];
          currentLayer.forEach((n1, idx1) => {
              nextLayer.forEach((n2, idx2) => {
                  const seed = (idx1 * 10 + idx2) * (i + 1) + val;
                  const rnd = Math.abs(Math.sin(seed));
                  // ∞モードでは接続閾値を上げてより多くの接続を表示
                  const connectionThreshold = isInfinite ? 0.7 : (0.3 + (100 / 200));
                  if (rnd < connectionThreshold) {
                      const opacity = isInfinite ? (0.4 + rnd * 0.4) : (0.3 + rnd * 0.5);
                      const lineWidth = isInfinite ? 1.2 : 1.5;
                      const color = traceColor;
                      
                      // L字型の回路配線パス
                      const midX = (n1.x + n2.x) / 2 + (idx1 % 2 === 0 ? 5 : -5);
                      const pathId = `trace-${connectionId++}`;
                      
                      // 配線パス（水平→垂直→水平）
                      const pathD = `M ${n1.x} ${n1.y} H ${midX} V ${n2.y} H ${n2.x}`;
                      linesSvg += `<path id="${pathId}" d="${pathD}" stroke="${color}" stroke-width="${lineWidth}" fill="none" opacity="${opacity}" stroke-linecap="square" />`;
                      
                      // ∞モードではデータフローアニメーションを増加 (25%)
                      const flowChance = isInfinite ? 0.25 : 0.15;
                      if (Math.random() < flowChance) {
                        const animDuration = isInfinite ? (1.5 + Math.random() * 1.5) : (2 + Math.random() * 2);
                        const animDelay = Math.random() * 3;
                        dataFlowSvg += `
                          <circle r="${isInfinite ? 1.5 : 2}" fill="${strokeColor}" opacity="0.9">
                            <animateMotion dur="${animDuration}s" repeatCount="indefinite" begin="${animDelay}s">
                              <mpath href="#${pathId}" />
                            </animateMotion>
                          </circle>`;
                      }
                  }
              });
          });
      }
      
      // Generate IC Chip Nodes (ICチップ風ノード)
      // ∞モードでは小さめのノードを使用して大規模ネットワークを表現
      let nodesSvg = "";
      const chipSize = isInfinite ? 7 : 10;
      nodeCoords.forEach((layer, layerIdx) => {
          layer.forEach((n, nodeIdx) => {
              {
                  // ICチップ風デザイン
                  const isInputOutput = layerIdx === 0 || layerIdx === nodeCoords.length - 1;
                  const size = isInputOutput ? chipSize + (isInfinite ? 1 : 2) : chipSize;
                  
                  // チップ本体（角丸正方形）
                  nodesSvg += `<rect x="${n.x - size/2}" y="${n.y - size/2}" width="${size}" height="${size}" rx="${isInfinite ? 1 : 2}" ry="${isInfinite ? 1 : 2}" fill="#0a0a15" stroke="${strokeColor}" stroke-width="${isInfinite ? 1 : 1.5}" />`;
                  
                  // 内部回路パターン
                  nodesSvg += `<rect x="${n.x - size/4}" y="${n.y - size/4}" width="${size/2}" height="${size/2}" fill="${strokeColor}" opacity="${isInfinite ? 0.7 : 0.6}" />`;
                  
                  // ピン（上下左右の小さな突起）- ∞モードでは省略して密度を高める
                  if (!isInfinite) {
                    const pinSize = 2;
                    const pinOffset = size/2 + 1;
                    nodesSvg += `<rect x="${n.x - 1}" y="${n.y - pinOffset - pinSize}" width="2" height="${pinSize}" fill="${strokeColor}" opacity="0.5" />`;
                    nodesSvg += `<rect x="${n.x - 1}" y="${n.y + pinOffset}" width="2" height="${pinSize}" fill="${strokeColor}" opacity="0.5" />`;
                  }
                  
                  // チップID表示 - ∞モードでは省略
                  if (!isInfinite) {
                    const chipId = `${String.fromCharCode(65 + layerIdx)}${nodeIdx}`;
                    nodesSvg += `<text x="${n.x}" y="${n.y + 1}" fill="${strokeColor}" font-size="5" text-anchor="middle" dominant-baseline="middle" font-family="'Share Tech Mono', monospace" opacity="0.8">${chipId}</text>`;
                  }
                  
                  // 発光エフェクト
                  const glowIntensity = isInfinite ? 1 : Math.min(val / 100, 1);
                  if (glowIntensity > 0.5) {
                    nodesSvg += `<rect x="${n.x - size/2}" y="${n.y - size/2}" width="${size}" height="${size}" rx="${isInfinite ? 1 : 2}" ry="${isInfinite ? 1 : 2}" fill="none" stroke="${strokeColor}" stroke-width="0.5" opacity="${glowIntensity * (isInfinite ? 0.5 : 0.4)}" />`;
                  }
              }
          });
      });
      
      // Via Holes (スルーホール装飾)
      // 軽量化: スルーホール数を削減 (8+6→5個固定)
      let viaSvg = "";
      {
        for (let i = 0; i < 5; i++) {
          const vx = 20 + Math.random() * (width - 40);
          const vy = 30 + Math.random() * (height - 60);
          viaSvg += `<circle cx="${vx}" cy="${vy}" r="2" fill="none" stroke="${strokeColor}" stroke-width="0.5" opacity="0.3" />`;
        }
      }
      
      // Enhanced Neural Network Collapse Effects for Infinite Mode
      // レベル∞でも暴走演出を無効化してスパーク効果なし
      let sparksSvg = "";
      if (false) { // isInfiniteを無効化
        // === LAYER 1: Background Data Corruption ===
        // Cascading error messages with different severity levels
        const errorMessages = [
          {text: "CRITICAL_FAULT", color: "#f00", size: 12},
          {text: "MEMORY_OVERFLOW", color: "#f60", size: 10},
          {text: "STACK_CORRUPTION", color: "#ff0", size: 9},
          {text: "NEURAL_LINK_SEVERED", color: "#f0f", size: 11},
          {text: "CORE_TEMPERATURE_CRITICAL", color: "#f30", size: 8},
          {text: "KERNEL_PANIC", color: "#f00", size: 14},
          {text: "SEGMENTATION_FAULT", color: "#0ff", size: 10},
          {text: "BUS_ERROR", color: "#ff0", size: 9},
          {text: "DEADLOCK_DETECTED", color: "#f60", size: 11},
          {text: "INFINITE_LOOP", color: "#f0f", size: 10}
        ];
        
        for(let i = 0; i < 8; i++) {
          const msg = errorMessages[Math.floor(Math.random() * errorMessages.length)];
          const x = Math.random() * (width - 80) + 20;
          const y = 25 + Math.random() * (height - 50);
          const delay = Math.random() * 3;
          const duration = 0.5 + Math.random() * 1.5;
          sparksSvg += `
            <text x="${x}" y="${y}" fill="${msg.color}" font-size="${msg.size}" 
                  font-family="'Share Tech Mono', monospace" opacity="0.7"
                  style="animation: warning-flash ${duration}s infinite ${delay}s;">
              ${msg.text}
              <animate attributeName="opacity" values="0;0.9;0.3;0.8;0" dur="${duration}s" repeatCount="indefinite" begin="${delay}s" />
            </text>`;
        }
        
        // === LAYER 2: Binary Data Rain ===
        for(let i = 0; i < 6; i++) {
          const x = 30 + (i * (width - 60) / 5);
          const binaryStream = Array(8).fill().map(() => Math.round(Math.random())).join('');
          const delay = Math.random() * 2;
          sparksSvg += `
            <text x="${x}" y="-10" fill="#0f0" font-size="8" font-family="monospace" opacity="0.4"
                  style="animation: binary-rain 3s linear infinite ${delay}s;">
              ${binaryStream}
            </text>`;
        }
        
        // === LAYER 3: Electrical Arcs between random points ===
        for(let i = 0; i < 5; i++) {
          const x1 = 30 + Math.random() * (width - 60);
          const y1 = 40 + Math.random() * (height - 80);
          const x2 = x1 + (Math.random() - 0.5) * 80;
          const y2 = y1 + (Math.random() - 0.5) * 60;
          const ctrl1x = (x1 + x2) / 2 + (Math.random() - 0.5) * 40;
          const ctrl1y = (y1 + y2) / 2 + (Math.random() - 0.5) * 40;
          const delay = Math.random() * 2;
          sparksSvg += `
            <path d="M${x1},${y1} Q${ctrl1x},${ctrl1y} ${x2},${y2}" 
                  fill="none" stroke="#fff" stroke-width="2" stroke-dasharray="5,5"
                  style="animation: electric-arc 0.5s infinite ${delay}s;">
              <animate attributeName="stroke" values="#fff;#ff0;#f00;#fff" dur="0.2s" repeatCount="indefinite" />
            </path>
            <circle cx="${x1}" cy="${y1}" r="3" fill="#ff0">
              <animate attributeName="r" values="2;5;2" dur="0.3s" repeatCount="indefinite" begin="${delay}s" />
              <animate attributeName="fill" values="#ff0;#fff;#ff0" dur="0.15s" repeatCount="indefinite" />
            </circle>`;
        }
        
        // === LAYER 4: Central AI Core Malfunction ===
        const coreX = width / 2;
        const coreY = height / 2;
        sparksSvg += `
          <g transform="translate(${coreX}, ${coreY})" class="ai-core-malfunction">
            <!-- Outer distortion rings -->
            <circle r="50" fill="none" stroke="#f00" stroke-width="1" opacity="0.3" stroke-dasharray="10,5">
              <animate attributeName="r" values="45;55;45" dur="0.8s" repeatCount="indefinite" />
              <animate attributeName="stroke-dashoffset" values="0;30" dur="0.5s" repeatCount="indefinite" />
              <animateTransform attributeName="transform" type="rotate" values="0;360" dur="3s" repeatCount="indefinite" />
            </circle>
            <circle r="40" fill="none" stroke="#ff0" stroke-width="1" opacity="0.4" stroke-dasharray="8,4">
              <animate attributeName="r" values="38;45;38" dur="0.6s" repeatCount="indefinite" />
              <animateTransform attributeName="transform" type="rotate" values="360;0" dur="2s" repeatCount="indefinite" />
            </circle>
            
            <!-- Core housing with damage -->
            <circle r="32" fill="#100" stroke="#f00" stroke-width="3">
              <animate attributeName="stroke" values="#f00;#ff0;#f60;#f00" dur="0.4s" repeatCount="indefinite" />
              <animate attributeName="fill" values="#100;#300;#100" dur="0.3s" repeatCount="indefinite" />
            </circle>
            
            <!-- Cracked core pattern -->
            <path d="M-15,-15 L5,0 L-10,10 L8,20" stroke="#f00" stroke-width="2" fill="none" opacity="0.8">
              <animate attributeName="stroke" values="#f00;#ff0;#f00" dur="0.2s" repeatCount="indefinite" />
            </path>
            <path d="M10,-20 L0,-5 L15,5 L-5,15" stroke="#f60" stroke-width="2" fill="none" opacity="0.7">
              <animate attributeName="stroke" values="#f60;#fff;#f60" dur="0.25s" repeatCount="indefinite" />
            </path>
            
            <!-- Pulsing unstable core -->
            <circle r="18" fill="#300">
              <animate attributeName="fill" values="#300;#f00;#600;#300" dur="0.35s" repeatCount="indefinite" />
              <animate attributeName="r" values="16;20;16" dur="0.25s" repeatCount="indefinite" />
            </circle>
            
            <!-- Glitching eye/sensor -->
            <ellipse rx="10" ry="12" fill="#f00" style="animation: eye-move 0.15s infinite steps(8);">
              <animate attributeName="fill" values="#f00;#ff0;#f0f;#f00" dur="0.2s" repeatCount="indefinite" />
              <animate attributeName="rx" values="10;8;12;10" dur="0.3s" repeatCount="indefinite" />
            </ellipse>
            
            <!-- Fragmented pupil -->
            <rect x="-4" y="-15" width="8" height="30" fill="#000" style="animation: data-corrupt 0.1s infinite;">
              <animate attributeName="x" values="-4;-2;-6;-4" dur="0.15s" repeatCount="indefinite" />
            </rect>
            
            <!-- Spark emanations -->
            <g style="animation: neural-spark 0.2s infinite;">
              <line x1="0" y1="-25" x2="0" y2="-35" stroke="#ff0" stroke-width="2">
                <animate attributeName="y2" values="-35;-40;-35" dur="0.15s" repeatCount="indefinite" />
              </line>
              <line x1="20" y1="-15" x2="30" y2="-20" stroke="#ff0" stroke-width="2" />
              <line x1="-20" y1="10" x2="-32" y2="15" stroke="#f00" stroke-width="2" />
              <line x1="15" y1="18" x2="25" y2="28" stroke="#f60" stroke-width="2" />
            </g>
            
            <!-- Warning text rotating around core -->
            <text fill="#f00" font-size="6" font-family="'Share Tech Mono', monospace">
              <textPath href="#warning-path">
                ▲ CRITICAL ▲ UNSTABLE ▲ DANGER ▲ MELTDOWN ▲
                <animate attributeName="startOffset" values="0%;100%" dur="4s" repeatCount="indefinite" />
              </textPath>
            </text>
          </g>
          
          <!-- Warning path definition -->
          <defs>
            <path id="warning-path" d="M${coreX},${coreY - 45} a45,45 0 1,1 0,90 a45,45 0 1,1 0,-90" fill="none" />
          </defs>`;
        
        // === LAYER 5: System Status Corruption ===
        sparksSvg += `
          <g transform="translate(10, 30)" style="animation: data-corrupt 0.5s infinite;">
            <text fill="#f00" font-size="7" font-family="'Share Tech Mono', monospace" opacity="0.8">
              SYSTEM_STATUS: <tspan fill="#ff0">CRITICAL</tspan>
              <animate attributeName="opacity" values="0.8;0.2;0.9;0.8" dur="0.3s" repeatCount="indefinite" />
            </text>
            <text y="10" fill="#f60" font-size="6" font-family="monospace" opacity="0.7">
              CPU_TEMP: <tspan fill="#f00">9999°C</tspan>
            </text>
            <text y="20" fill="#0f0" font-size="6" font-family="monospace" opacity="0.6">
              MEM_INTEGRITY: <tspan fill="#f00">0.01%</tspan>
              <animate attributeName="opacity" values="0.6;0;0.6" dur="0.4s" repeatCount="indefinite" />
            </text>
          </g>
          
          <g transform="translate(${width - 100}, 30)" style="animation: data-corrupt 0.4s infinite 0.2s;">
            <text fill="#f0f" font-size="7" font-family="'Share Tech Mono', monospace" opacity="0.8">
              NEURAL_SYNC: <tspan fill="#f00">FAILED</tspan>
            </text>
            <text y="10" fill="#0ff" font-size="6" font-family="monospace" opacity="0.7">
              CONNECTIONS: <tspan fill="#ff0">SEVERED</tspan>
            </text>
            <text y="20" fill="#ff0" font-size="6" font-family="monospace" opacity="0.6">
              AI_CORE: <tspan fill="#f00" style="animation: rgb-split 0.2s infinite;">UNSTABLE</tspan>
            </text>
          </g>`;
        
        // === LAYER 6: Thermal Gradients for nodes ===
        for(let l = 0; l < layers.length; l++) {
          for(let n = 0; n < layers[l]; n++) {
            sparksSvg += `
              <defs>
                <radialGradient id="thermal-gradient-${l}-${n}">
                  <stop offset="0%" stop-color="#ff0">
                    <animate attributeName="stop-color" values="#ff0;#f00;#f60;#ff0" dur="0.3s" repeatCount="indefinite" />
                  </stop>
                  <stop offset="100%" stop-color="transparent" />
                </radialGradient>
              </defs>`;
          }
        }
        
        // === LAYER 7: Scan line interference ===
        for(let i = 0; i < 3; i++) {
          const y = 30 + Math.random() * (height - 60);
          const delay = Math.random() * 2;
          sparksSvg += `
            <rect x="0" y="${y}" width="${width}" height="3" fill="#f00" opacity="0.3">
              <animate attributeName="y" values="${y};${y + height};${y}" dur="2s" repeatCount="indefinite" begin="${delay}s" />
              <animate attributeName="opacity" values="0.3;0.6;0.3" dur="0.5s" repeatCount="indefinite" />
            </rect>`;
        }
      }
      
      // Labels (デジタル表示風)
      let labelsSvg = "";
      const fontSize = 11;
      const yPos = height - 3;
      const textStyle = `fill="${strokeColor}" font-size="${fontSize}" text-anchor="middle" font-family="'Share Tech Mono', monospace" font-weight="bold" letter-spacing="1px"`;
      labelsSvg += `<text id="cpu-lbl-input" x="${nodeCoords[0][0].x}" y="${yPos}" ${textStyle}>&lt;IN&gt;</text>`;
      labelsSvg += `<text id="cpu-lbl-output" x="${nodeCoords[nodeCoords.length-1][0].x}" y="${yPos}" ${textStyle}>&lt;OUT&gt;</text>`;
      if (layers.length > 2) {
          const midHiddenX = (nodeCoords[1][0].x + nodeCoords[nodeCoords.length-2][0].x) / 2;
          labelsSvg += `<text id="cpu-lbl-hidden" x="${midHiddenX}" y="${yPos}" ${textStyle}>&lt;PROC&gt;</text>`;
      }
      
      // Title Text (デジタル回路風)
      // ∞モード時は特別なタイトル
      const nnTitle = isTranscended ? '∞ TRANSCENDED' : '// NEURAL_CIRCUIT';
      const nnTextSvg = isTranscended ? `
        <g>
          <defs>
            <linearGradient id="infinity-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#ffd700">
                <animate attributeName="stop-color" values="#ffd700;#fff;#9b59b6;#fff;#ffd700" dur="3s" repeatCount="indefinite" />
              </stop>
              <stop offset="50%" style="stop-color:#9b59b6">
                <animate attributeName="stop-color" values="#9b59b6;#ffd700;#fff;#ffd700;#9b59b6" dur="3s" repeatCount="indefinite" />
              </stop>
              <stop offset="100%" style="stop-color:#ffd700">
                <animate attributeName="stop-color" values="#ffd700;#9b59b6;#ffd700;#fff;#ffd700" dur="3s" repeatCount="indefinite" />
              </stop>
            </linearGradient>
            <filter id="infinity-glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="3" result="blur"/>
              <feFlood flood-color="#ffd700" flood-opacity="0.6"/>
              <feComposite in2="blur" operator="in"/>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <text id="cpu-lbl-nn" x="${width/2}" y="12" fill="url(#infinity-gradient)" font-size="22" text-anchor="middle" dominant-baseline="middle" font-family="'Orbitron', sans-serif" font-weight="900" filter="url(#infinity-glow)" style="letter-spacing: 4px;">∞ TRANSCENDED</text>
          <line x1="${width/2 - 90}" y1="22" x2="${width/2 + 90}" y2="22" stroke="url(#infinity-gradient)" stroke-width="2" opacity="0.6">
            <animate attributeName="opacity" values="0.6;1;0.6" dur="2s" repeatCount="indefinite" />
          </line>
        </g>` : `
        <g>
          <text id="cpu-lbl-nn" x="${width/2}" y="12" fill="${strokeColor}" font-size="18" text-anchor="middle" dominant-baseline="middle" font-family="'Orbitron', sans-serif" font-weight="800" style="letter-spacing: 3px; opacity: 0.95;">// NEURAL_CIRCUIT</text>
          <line x1="${width/2 - 80}" y1="20" x2="${width/2 + 80}" y2="20" stroke="${strokeColor}" stroke-width="1" opacity="0.3" />
        </g>`;

      // レベル∞でもフィルターなし
      const filterAttr = '';

      const svg = `
        <svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="${svgClass}" style="overflow: visible;">
          <defs>
            <filter id="glow-geo" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="2" result="blur" />
              <feComposite in="SourceGraphic" in2="blur" operator="over" />
            </filter>
            <style>
              @keyframes chip-glow {
                0% { opacity: 0.3; }
                100% { opacity: 0.7; }
              }
            </style>
          </defs>
          <g ${filterAttr}>
            ${gridSvg}
            ${viaSvg}
            ${linesSvg}
            ${dataFlowSvg}
            ${nodesSvg}
            ${sparksSvg}
            ${labelsSvg}
            ${nnTextSvg}
          </g>
        </svg>
      `;
      faceContainer.innerHTML = svg;
    };

    slider.addEventListener('input', (e) => {
      tapCount = 0;
      if (!audio.ctx) {
        audio.init();
        audio.enabled = true;
      }
      updateFace(e.target.value);
    });

    // ニューラルリンク破壊エフェクト（未来的な壊れていく演出）
    const triggerNeuralBreakEffect = (container, count) => {
      // 既存のエフェクトをクリア
      container.querySelectorAll('.break-effect').forEach(el => el.remove());
      
      const svg = container.querySelector('svg');
      if (!svg) return;
      
      const rect = container.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      
      // 破壊段階に応じたエフェクト強度
      const intensity = Math.min(count / 10, 1);
      
      // 1. グリッチライン（水平スキャンライン）
      for (let i = 0; i < Math.min(count, 5); i++) {
        const glitchLine = document.createElement('div');
        glitchLine.className = 'break-effect';
        glitchLine.style.cssText = `
          position: absolute;
          left: 0;
          width: 100%;
          height: ${2 + Math.random() * 3}px;
          top: ${Math.random() * 100}%;
          background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(0, 255, 255, ${0.3 + intensity * 0.4}) 20%, 
            rgba(255, 255, 255, ${0.5 + intensity * 0.3}) 50%, 
            rgba(0, 255, 255, ${0.3 + intensity * 0.4}) 80%, 
            transparent 100%);
          pointer-events: none;
          animation: glitch-scan 0.3s ease-out forwards;
          z-index: 10;
        `;
        container.appendChild(glitchLine);
        setTimeout(() => glitchLine.remove(), 300);
      }
      
      // 2. デジタルノイズブロック
      for (let i = 0; i < count * 2; i++) {
        const noiseBlock = document.createElement('div');
        noiseBlock.className = 'break-effect';
        const size = 5 + Math.random() * 15;
        noiseBlock.style.cssText = `
          position: absolute;
          width: ${size}px;
          height: ${size * (0.3 + Math.random() * 0.7)}px;
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          background: ${Math.random() > 0.5 ? 'rgba(0, 255, 255, 0.6)' : 'rgba(255, 0, 100, 0.5)'};
          pointer-events: none;
          animation: noise-fade 0.4s ease-out forwards;
          z-index: 10;
        `;
        container.appendChild(noiseBlock);
        setTimeout(() => noiseBlock.remove(), 400);
      }
      
      // 3. 回路切断スパーク
      for (let i = 0; i < Math.ceil(count / 2); i++) {
        const spark = document.createElement('div');
        spark.className = 'break-effect';
        const x = 10 + Math.random() * 80;
        const y = 10 + Math.random() * 80;
        spark.style.cssText = `
          position: absolute;
          left: ${x}%;
          top: ${y}%;
          width: 4px;
          height: 4px;
          background: #fff;
          border-radius: 50%;
          box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #fff;
          pointer-events: none;
          animation: spark-burst 0.5s ease-out forwards;
          z-index: 15;
        `;
        container.appendChild(spark);
        setTimeout(() => spark.remove(), 500);
      }
      
      // 4. エラーコードフラッシュ（高い破壊段階で）
      if (count >= 5) {
        const errorFlash = document.createElement('div');
        errorFlash.className = 'break-effect';
        const errors = ['LINK_SEVERED', 'NODE_FAULT', 'CRITICAL_ERR', 'SYNC_LOST', 'OVERFLOW'];
        errorFlash.textContent = errors[Math.floor(Math.random() * errors.length)];
        errorFlash.style.cssText = `
          position: absolute;
          left: ${20 + Math.random() * 60}%;
          top: ${20 + Math.random() * 60}%;
          transform: translate(-50%, -50%);
          font-family: 'Share Tech Mono', monospace;
          font-size: ${8 + count}px;
          color: ${count >= 8 ? '#ff0066' : '#0ff'};
          text-shadow: 0 0 5px currentColor;
          pointer-events: none;
          animation: error-flash 0.6s ease-out forwards;
          z-index: 20;
          white-space: nowrap;
        `;
        container.appendChild(errorFlash);
        setTimeout(() => errorFlash.remove(), 600);
      }
      
      // 5. フレーム歪み効果（高い破壊段階で）
      if (count >= 7) {
        container.style.filter = `hue-rotate(${(count - 7) * 30}deg) brightness(${1 + (count - 7) * 0.1})`;
        setTimeout(() => {
          container.style.filter = '';
        }, 200);
      }
    };

    // 破壊エフェクト用のスタイルを動的に追加
    if (!document.getElementById('neural-break-styles')) {
      const breakStyles = document.createElement('style');
      breakStyles.id = 'neural-break-styles';
      breakStyles.textContent = `
        @keyframes glitch-scan {
          0% { transform: translateX(-100%); opacity: 1; }
          100% { transform: translateX(100%); opacity: 0; }
        }
        @keyframes noise-fade {
          0% { opacity: 1; transform: scale(1); }
          50% { opacity: 0.8; transform: scale(1.2); }
          100% { opacity: 0; transform: scale(0.5); }
        }
        @keyframes spark-burst {
          0% { transform: scale(1); opacity: 1; }
          50% { transform: scale(3); opacity: 0.8; }
          100% { transform: scale(0); opacity: 0; }
        }
        @keyframes error-flash {
          0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
          20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
          80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
      `;
      document.head.appendChild(breakStyles);
    }

    const handleFaceTap = (e) => {
      if (e.cancelable) e.preventDefault();
      if (isDevilMode) return;
      
      if (!audio.ctx) {
        audio.init();
        audio.enabled = true;
      }
      
      if (audio.ctx) {
        if (audio.ctx.state === 'suspended') {
          audio.ctx.resume();
        }
        // Unlock audio context with silent sound
        const osc = audio.ctx.createOscillator();
        const gain = audio.ctx.createGain();
        gain.gain.value = 0;
        osc.connect(gain);
        gain.connect(audio.ctx.destination);
        osc.start(0);
        osc.stop(0.01);
      }
      
      if (parseInt(slider.value) === 100) {
        tapCount++;
        
        // 未来的な破壊エフェクト（揺れではなく壊れていく演出）
        triggerNeuralBreakEffect(faceContainer, tapCount);
        
        // タップごとに崩壊を進行させる
        updateFace(100);
        
        if (tapCount >= 10) {
          // Play Neural Transcendence effect before enabling devil mode
          playNeuralTranscendence(() => {
            // After transcendence animation completes
            isDevilMode = true;
            slider.disabled = true;
            
            // Update UI to show ∞ mode
            label.innerText = `AI LEVEL: ∞`;
            label.style.color = '#ffd700';
            label.style.textShadow = '0 0 10px #ffd700, 0 0 20px #9b59b6, 0 0 40px #ffd700';
            
            // Update title
            titleEl.innerHTML = "NEURAL<br>TRANSCENDENCE";
            titleEl.style.background = 'linear-gradient(135deg, #ffd700, #fff, #9b59b6, #fff, #ffd700)';
            titleEl.style.backgroundSize = '400% 400%';
            titleEl.style.webkitBackgroundClip = 'text';
            titleEl.style.backgroundClip = 'text';
            titleEl.style.webkitTextFillColor = 'transparent';
            titleEl.style.animation = 'infinity-gradient 3s ease infinite';
            
            // Update start button
            startBtn.innerText = "CHALLENGE ∞";
            startBtn.style.borderColor = 'rgba(255, 215, 0, 0.6)';
            startBtn.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.4), 0 0 40px rgba(155, 89, 182, 0.3), inset 0 0 15px rgba(255, 215, 0, 0.2)';
            
            // Update panel indicator
            const indicator = document.querySelector('.ai-panel-indicator');
            if (indicator) {
              indicator.style.background = 'linear-gradient(135deg, #ffd700, #9b59b6)';
              indicator.style.boxShadow = '0 0 15px #ffd700, 0 0 30px #9b59b6';
            }
            
            // Update corner brackets
            document.querySelectorAll('.ai-panel-corner').forEach(corner => {
              corner.style.borderColor = 'rgba(255, 215, 0, 0.4)';
            });
            
            updateFace(100);
          });
        }
      }
    };
    faceContainer.addEventListener('touchstart', handleFaceTap, {passive: false});
    faceContainer.addEventListener('click', handleFaceTap);

    updateFace(slider.value);

    const startGame = (e) => {
      if (e.cancelable) e.preventDefault();
      initGame(slider.value, isDevilMode);
    };

    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('touchstart', startGame, {passive: false});
    
    // Initialize Falling Blocks Background
    initFallingBlocksBackground();
  };

  // =====================================================
  // Falling Blocks Background Animation
  // =====================================================
  function initFallingBlocksBackground() {
    const canvas = document.getElementById('falling-blocks-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let fallingBlocks = [];
    let animationId = null;
    let isActive = false;
    let blockImages = [];
    let imagesLoaded = 0;
    
    // Block texture URLs (using actual game block textures)
    const blockUrls = [
      'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/lx089jdk.jpeg', // Purple
      'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/zcmuvq2z.jpeg', // Blue
      'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/ii1cqrn9.jpeg', // Red
      'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/2awljusp.jpeg', // Yellow
      'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/e0c19784-944d-43f8-872c-2326af2f8335/files/6jx8wd1g.jpeg'  // Cyan
    ];
    
    // Preload block images
    blockUrls.forEach((url, index) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        imagesLoaded++;
      };
      img.src = url;
      blockImages[index] = img;
    });
    
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    class FallingBlockBg {
      constructor() {
        this.reset(true);
      }
      
      reset(initial = false) {
        this.x = Math.random() * canvas.width;
        this.y = initial ? Math.random() * canvas.height : -60;
        this.size = 20 + Math.random() * 30;
        this.speed = 0.5 + Math.random() * 1.5;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        this.opacity = 0.1 + Math.random() * 0.3;
        this.imageIndex = Math.floor(Math.random() * blockUrls.length);
        this.swayOffset = Math.random() * Math.PI * 2;
        this.swaySpeed = 0.01 + Math.random() * 0.02;
        this.swayAmount = 20 + Math.random() * 30;
      }
      
      update() {
        this.y += this.speed;
        this.rotation += this.rotationSpeed;
        this.swayOffset += this.swaySpeed;
        
        // Add swaying motion like rain
        this.x += Math.sin(this.swayOffset) * 0.3;
        
        if (this.y > canvas.height + 60) {
          this.reset();
        }
      }
      
      draw() {
        if (imagesLoaded < blockUrls.length) return;
        
        const img = blockImages[this.imageIndex];
        if (!img || !img.complete) return;
        
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // 軽量化: shadowBlurを削除（高負荷なため）
        ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);
        
        ctx.restore();
      }
    }
    
    const initBlocks = () => {
      fallingBlocks = [];
      // 軽量化: ブロック数をさらに削減 (25→15)
      const count = Math.min(15, Math.floor(canvas.width * canvas.height / 50000));
      for (let i = 0; i < count; i++) {
        fallingBlocks.push(new FallingBlockBg());
      }
      // 軽量化: 初期化時に一度だけソート（サイズは固定なので毎フレーム不要）
      fallingBlocks.sort((a, b) => a.size - b.size);
    };
    
    const animate = () => {
      if (!isActive) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 軽量化: ソートは初期化時のみ実行（毎フレームのソートを削除）
      fallingBlocks.forEach(block => {
        block.update();
        block.draw();
      });
      
      animationId = requestAnimationFrame(animate);
    };
    
    // Observer to start/stop animation based on visibility
    const observer = new MutationObserver(() => {
      const startScreen = document.getElementById('start-screen');
      const isVisible = startScreen && startScreen.style.display !== 'none';
      
      if (isVisible && !isActive) {
        isActive = true;
        initBlocks();
        animate();
      } else if (!isVisible && isActive) {
        isActive = false;
        if (animationId) cancelAnimationFrame(animationId);
      }
    });
    
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      observer.observe(startScreen, { attributes: true, attributeFilter: ['style'] });
    }
  }

  function setupTutorial() {
    const tutorialBtn = document.getElementById('mode-tutorial');
    const tutorialModal = document.getElementById('tutorial-modal');
    const nextBtn = document.getElementById('tutorial-next-btn');
    const skipBtn = document.getElementById('tutorial-skip-btn');
    const aiText = document.getElementById('tutorial-ai-text');
    const stepTitle = document.getElementById('tutorial-step-title');
    const stepContent = document.getElementById('tutorial-step-content');
    const previewContainer = document.getElementById('tutorial-preview-container');

    const iconStyle = "height: 1.4em; vertical-align: middle; margin: 0 2px; display: inline-block;";
    const imgP = `<img src="https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/76f481e5-bbd5-458e-a55e-caae103acd2f/files/dnsyu96c.gif" style="${iconStyle}">`;
    const imgR = `<img src="https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/64b7a0a8-5fc9-4244-998b-b17a2f9499b6/files/iy2j9zwo.gif" style="${iconStyle}">`;
    const imgC = `<img src="https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/02df3ae1-4d6f-475f-90b4-776d070c0d8c/files/2hlu1rff.gif" style="${iconStyle}">`;
    const imgS = `<img src="https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/03c94eb1-1a14-4da1-9a54-88433f2f1dc2/files/jrfi0a0l.gif" style="${iconStyle}">`;

    const dpadUrl = 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/boeh23kv.png';
    const itemUrl = 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/h9o0fz0b.png';
    const swapUrl = 'https://odqcczjoaznmfpiywmoj-all.supabase.co/storage/v1/object/public/assets/d77375bb-97c6-4909-b8a4-e4693baba941/files/8uyzg3ax.png';

    let currentStep = 0;
    const steps = [
      {
        ai: "ようこそ。コアシステムの基本操作を説明する。",
        title: "基本ルール",
        html: "<ul><li>同じ色のブロックを縦・横・斜めに<strong>3つ以上</strong>つなげて消去せよ。</li><li><strong>連鎖</strong>を組むことで対戦相手に攻撃データを送信できる。</li><li>左から5列目が最上段まで積み上がると<strong>GAME OVER</strong>だ。</li></ul>"
      },
      {
        ai: "操作をマスターし、パフォーマンスを最適化せよ。",
        title: "操作方法",
        html: `<ul style="list-style:none; padding:0; margin:0;">
          <li style="margin-bottom:15px; display:flex; align-items:center;">
            <div style="width:70px; display:flex; justify-content:center; margin-right:10px; flex-shrink:0;">
              <img src="${dpadUrl}" style="height:60px;">
            </div>
            <div><strong>移動・回転・落下</strong><br><span style="font-size:0.8em; color:#aaa;">左右で移動、上で回転、下で落下</span></div>
          </li>
          <li style="margin-bottom:15px; display:flex; align-items:center;">
            <div style="width:70px; display:flex; justify-content:center; margin-right:10px; flex-shrink:0;">
              <div style="position:relative; width:50px; height:30px; display:flex; justify-content:center; align-items:center;">
                <img src="${itemUrl}" style="position:absolute; width:100%; height:100%; object-fit:contain;">
                <span style="position:relative; z-index:1; font-size:10px; font-weight:bold; color:#fff; text-shadow:0 0 2px #000; font-family:'Orbitron', sans-serif;">ITEM</span>
              </div>
            </div>
            <div><strong>アイテム使用</strong><br><span style="font-size:0.8em; color:#aaa;">先頭のアイテムを使用</span></div>
          </li>
          <li style="margin-bottom:5px; display:flex; align-items:center;">
            <div style="width:70px; display:flex; justify-content:center; margin-right:10px; flex-shrink:0;">
              <img src="${swapUrl}" style="height:45px;">
            </div>
            <div><strong>アイテム入替</strong><br><span style="font-size:0.8em; color:#aaa;">アイテムの順序を変更</span></div>
          </li>
        </ul>`
      },
      {
        ai: "特殊モジュールを検知。状況に応じて使用せよ。",
        title: "アイテム: P & R",
        html: `<ul><li><strong>${imgP} プリズム:</strong> 特定の色のブロックを全て消去する。</li><li><strong>${imgR} リバース:</strong> 自フィールドを上下反転させる。ピンチ時の逆転に有効。</li></ul>`
      },
      {
        ai: "高度な戦闘のための上級戦術データだ。",
        title: "アイテム: C & S",
        html: `<ul><li><strong>${imgC} クリア:</strong> 自フィールドを全消去する（緊急回避用）。</li><li><strong>${imgS} スワップ:</strong> 相手とフィールドを入れ替える。コンボも奪取可能。</li></ul>`
      },
      {
        ai: "チュートリアル完了。…最後に一つ忠告だ。レベル100のニューラルリンクは非常に繊細にできている。あまり過度に接触（タップ）しないようにな。",
        title: "準備はいいか？",
        html: "<p style='text-align:center; margin-top:20px;'>健闘を祈る。</p>"
      }
    ];

    const updateTutorial = () => {
      const s = steps[currentStep];
      aiText.innerText = "";
      let i = 0;
      const type = () => {
        if(i < s.ai.length) { aiText.innerText += s.ai.charAt(i); i++; setTimeout(type, 20); }
      };
      type();
      
      stepTitle.innerText = s.title;
      stepContent.innerHTML = s.html;
      
      if (currentStep === 0) {
        previewContainer.classList.add('active');
        if (window.tutorialP5) window.tutorialP5.loop();
      } else {
        previewContainer.classList.remove('active');
        if (window.tutorialP5) window.tutorialP5.noLoop();
      }

      if (currentStep === steps.length - 1) {
        nextBtn.innerText = "閉じる";
        skipBtn.style.display = 'none';
      } else {
        nextBtn.innerText = "次へ >>";
        skipBtn.style.display = 'block';
      }
    };

    const toggleTutorial = (show) => {
      tutorialModal.style.display = show ? 'flex' : 'none';
      if (show) {
        if (!audio.ctx) audio.init();
        currentStep = 0;
        updateTutorial();
      }
    };

    tutorialBtn.addEventListener('click', () => toggleTutorial(true));
    tutorialBtn.addEventListener('touchstart', (e) => { e.preventDefault(); toggleTutorial(true); }, {passive: false});
    
    const nextHandler = () => {
      if (currentStep < steps.length - 1) {
        currentStep++;
        updateTutorial();
      } else {
        toggleTutorial(false);
      }
    };

    nextBtn.addEventListener('click', nextHandler);
    nextBtn.addEventListener('touchstart', (e) => { e.preventDefault(); nextHandler(); }, {passive: false});
    
    skipBtn.addEventListener('click', () => toggleTutorial(false));
    skipBtn.addEventListener('touchstart', (e) => { e.preventDefault(); toggleTutorial(false); }, {passive: false});
  }

  function setupModeSelect() {
    const modeScreen = document.getElementById('mode-select-screen');
    const startScreen = document.getElementById('start-screen');
    const btnTraining = document.getElementById('mode-training');
    const btnBattle = document.getElementById('mode-battle');

    const startTransition = (onComplete) => {
      const core = modeScreen.querySelector('.ai-core-container');
      const elementsToSuck = modeScreen.querySelectorAll('.mode-card, .subtitle');
      
      // Warp Sound Effect
      if (audio && audio.ctx) {
         const t = audio.ctx.currentTime;
         const osc = audio.ctx.createOscillator();
         const gain = audio.ctx.createGain();
         osc.type = 'sawtooth';
         osc.frequency.setValueAtTime(100, t);
         osc.frequency.exponentialRampToValueAtTime(3000, t + 0.6);
         
         const filter = audio.ctx.createBiquadFilter();
         filter.type = 'lowpass';
         filter.frequency.setValueAtTime(200, t);
         filter.frequency.exponentialRampToValueAtTime(20000, t + 0.6);
         
         gain.gain.setValueAtTime(0.3, t);
         gain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
         
         osc.connect(filter);
         filter.connect(gain);
         gain.connect(audio.ctx.destination);
         osc.start(t);
         osc.stop(t + 0.6);
      }

      core.classList.add('core-warp');
      elementsToSuck.forEach(el => el.classList.add('sucking'));

      setTimeout(() => {
        onComplete();
        setTimeout(() => {
            core.classList.remove('core-warp');
            elementsToSuck.forEach(el => el.classList.remove('sucking'));
        }, 100);
      }, 700);
    };

    const selectTraining = (e) => {
      if (e.cancelable) e.preventDefault();
      // Play futuristic UI click sound
      if (typeof FuturisticSFX !== 'undefined' && FuturisticSFX.ctx) {
        FuturisticSFX.playUIClick();
      }
      startTransition(() => {
        isTrainingMode = true;
        initGame(0, false);
      });
    };

    const selectBattle = (e) => {
      if (e.cancelable) e.preventDefault();
      // Play futuristic transition sound
      if (typeof FuturisticSFX !== 'undefined' && FuturisticSFX.ctx) {
        FuturisticSFX.playTransitionSound();
      }
      startTransition(() => {
        isTrainingMode = false;
        modeScreen.style.display = 'none';
        startScreen.style.display = 'flex';
        const slider = document.getElementById('cpu-strength-slider');
        if (slider) {
          isDevilMode = false;
          slider.disabled = false;
          slider.value = 50;
          slider.dispatchEvent(new Event('input'));
        }
      });
    };

    btnTraining.addEventListener('click', selectTraining);
    btnTraining.addEventListener('touchstart', selectTraining, {passive: false});
    
    btnBattle.addEventListener('click', selectBattle);
    btnBattle.addEventListener('touchstart', selectBattle, {passive: false});
    
    // Setup Friend Battle Mode
    setupFriendBattle();
    
    // Initialize Mode Select Screen Particle System
    initModeSelectParticles();
    
    // Add Ripple Effect to Mode Cards
    initModeCardRipple();
  }
  
  // =====================================================
  // Friend Battle Mode - Passcode System
  // =====================================================
  function setupFriendBattle() {
    const btnFriendBattle = document.getElementById('mode-friend-battle');
    const passcodeModal = document.getElementById('passcode-modal');
    const passcodeInput = document.getElementById('passcode-input');
    const passcodeError = document.getElementById('passcode-error');
    const passcodeCancel = document.getElementById('passcode-cancel');
    const passcodeSubmit = document.getElementById('passcode-submit');
    
    const CORRECT_PASSCODE = 'Hexapo';
    const FRIEND_BATTLE_URL = 'https://3000-ia9grkugaxf7ukq7up4t9-de59bda9.sandbox.novita.ai/';
    let isUnlocked = false;
    
    // Show passcode modal
    const showPasscodeModal = () => {
      passcodeModal.style.display = 'flex';
      passcodeInput.value = '';
      passcodeError.textContent = '';
      setTimeout(() => passcodeInput.focus(), 100);
    };
    
    // Hide passcode modal
    const hidePasscodeModal = () => {
      passcodeModal.style.display = 'none';
      passcodeInput.value = '';
      passcodeError.textContent = '';
    };
    
    // Navigate to Friend Battle URL - robust method
    const navigateToFriendBattle = () => {
      // Method 1: Try creating a temporary <a> link and clicking it (most reliable on mobile)
      const link = document.createElement('a');
      link.href = FRIEND_BATTLE_URL;
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Method 2: Fallback to window.open if link click didn't work
      setTimeout(() => {
        const newWindow = window.open(FRIEND_BATTLE_URL, '_blank');
        // Method 3: If popup was blocked, redirect current page
        if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
          window.location.href = FRIEND_BATTLE_URL;
        }
      }, 100);
    };
    
    // Unlock friend battle
    const unlockFriendBattle = () => {
      isUnlocked = true;
      btnFriendBattle.classList.remove('locked');
      hidePasscodeModal();
      
      // Play unlock sound
      if (audio && audio.ctx) {
        const t = audio.ctx.currentTime;
        const osc = audio.ctx.createOscillator();
        const gain = audio.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
        osc.frequency.setValueAtTime(800, t + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        osc.connect(gain);
        gain.connect(audio.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.3);
      }
      
      // Navigate to Friend Battle URL
      setTimeout(() => {
        navigateToFriendBattle();
      }, 300);
    };
    
    // Validate passcode
    const validatePasscode = () => {
      const input = passcodeInput.value;
      if (input === CORRECT_PASSCODE) {
        unlockFriendBattle();
      } else {
        passcodeError.textContent = 'ACCESS DENIED - INVALID CODE';
        passcodeInput.value = '';
        
        // Play error sound
        if (audio && audio.ctx) {
          const t = audio.ctx.currentTime;
          const osc = audio.ctx.createOscillator();
          const gain = audio.ctx.createGain();
          osc.type = 'square';
          osc.frequency.setValueAtTime(200, t);
          osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
          gain.gain.setValueAtTime(0.2, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
          osc.connect(gain);
          gain.connect(audio.ctx.destination);
          osc.start(t);
          osc.stop(t + 0.2);
        }
        
        // Shake animation
        passcodeInput.style.animation = 'none';
        setTimeout(() => {
          passcodeInput.style.animation = 'shake 0.3s ease';
        }, 10);
      }
    };
    
    // Click handler for friend battle card
    const handleFriendBattleClick = (e) => {
      // Only prevent default for touch events to avoid double-firing
      if (e.type === 'touchend') {
        e.preventDefault();
      }
      e.stopPropagation();
      
      if (isUnlocked) {
        // Already unlocked, open URL directly
        navigateToFriendBattle();
      } else {
        // Show passcode modal
        showPasscodeModal();
      }
    };
    
    // Event listeners - use touchend for mobile to allow user gesture for popup
    btnFriendBattle.addEventListener('click', handleFriendBattleClick);
    btnFriendBattle.addEventListener('touchend', handleFriendBattleClick, {passive: false});
    
    passcodeCancel.addEventListener('click', hidePasscodeModal);
    passcodeCancel.addEventListener('touchstart', (e) => { e.preventDefault(); hidePasscodeModal(); }, {passive: false});
    
    passcodeSubmit.addEventListener('click', validatePasscode);
    passcodeSubmit.addEventListener('touchstart', (e) => { e.preventDefault(); validatePasscode(); }, {passive: false});
    
    // Enter key to submit
    passcodeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        validatePasscode();
      }
    });
    
    // Close modal on backdrop click
    passcodeModal.addEventListener('click', (e) => {
      if (e.target === passcodeModal) {
        hidePasscodeModal();
      }
    });
  }
  
  // =====================================================
  // Mode Select Screen - Particle System
  // =====================================================
  function initModeSelectParticles() {
    const canvas = document.getElementById('mode-particle-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationId = null;
    let isActive = false;
    
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    class Particle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 0.5;
        this.speedX = (Math.random() - 0.5) * 0.3;
        this.speedY = (Math.random() - 0.5) * 0.3 - 0.2;
        this.opacity = Math.random() * 0.5 + 0.1;
        this.hue = 180 + Math.random() * 40;
        this.pulse = Math.random() * Math.PI * 2;
        this.pulseSpeed = 0.02 + Math.random() * 0.03;
      }
      
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.pulse += this.pulseSpeed;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.reset();
          this.y = canvas.height + 10;
        }
      }
      
      draw() {
        const pulseOpacity = this.opacity * (0.5 + 0.5 * Math.sin(this.pulse));
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${pulseOpacity})`;
        ctx.fill();
        
        // 軽量化: グラデーションのGlow効果を削除（負荷が高いため）
      }
    }
    
    const initParticles = () => {
      particles = [];
      // 軽量化: パーティクル数を削減 (50→20)
      const count = Math.min(20, Math.floor(canvas.width * canvas.height / 40000));
      for (let i = 0; i < count; i++) {
        particles.push(new Particle());
      }
    };
    
    const animate = () => {
      if (!isActive) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      particles.forEach(p => {
        p.update();
        p.draw();
      });
      
      animationId = requestAnimationFrame(animate);
    };
    
    // Observer to start/stop animation based on visibility
    const observer = new MutationObserver(() => {
      const modeScreen = document.getElementById('mode-select-screen');
      const isVisible = modeScreen && modeScreen.style.display !== 'none';
      
      if (isVisible && !isActive) {
        isActive = true;
        initParticles();
        animate();
      } else if (!isVisible && isActive) {
        isActive = false;
        if (animationId) cancelAnimationFrame(animationId);
      }
    });
    
    const modeScreen = document.getElementById('mode-select-screen');
    if (modeScreen) {
      observer.observe(modeScreen, { attributes: true, attributeFilter: ['style'] });
    }
  }
  
  // =====================================================
  // Mode Card Ripple Effect
  // =====================================================
  function initModeCardRipple() {
    const cards = document.querySelectorAll('.mode-card');
    
    cards.forEach(card => {
      card.addEventListener('touchstart', createRipple, { passive: true });
      card.addEventListener('mousedown', createRipple);
    });
    
    function createRipple(e) {
      const card = e.currentTarget;
      const rect = card.getBoundingClientRect();
      
      // Get touch/click position
      let x, y;
      if (e.touches && e.touches[0]) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      
      // Create ripple element
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      
      // Set ripple color based on card type
      if (card.classList.contains('training')) {
        ripple.style.background = 'rgba(78, 205, 196, 0.4)';
      } else if (card.classList.contains('battle')) {
        ripple.style.background = 'rgba(255, 0, 102, 0.4)';
      } else if (card.classList.contains('tutorial')) {
        ripple.style.background = 'rgba(255, 215, 0, 0.4)';
      }
      
      card.appendChild(ripple);
      
      // Remove ripple after animation
      setTimeout(() => {
        ripple.remove();
      }, 600);
    }
  }

  function setupBootScreen() {
    const bootScreen = document.getElementById('boot-screen');
    const startScreen = document.getElementById('start-screen');
    const modeScreen = document.getElementById('mode-select-screen');
    const powerBtn = document.getElementById('power-btn-container');
    const ringProgress = document.getElementById('ring-progress');
    const bootText = document.querySelector('.boot-text');
    
    let isBooting = false;
    let progress = 0;
    let bootSoundOsc = null;
    let bootSoundGain = null;
    
    // ==========================================
    // System Info Panel - Hacking Style Display
    // ==========================================
    function initSystemInfoPanel() {
      const sysDevice = document.getElementById('sys-device');
      const sysOS = document.getElementById('sys-os');
      const sysBrowser = document.getElementById('sys-browser');
      const sysResolution = document.getElementById('sys-resolution');
      const sysLanguage = document.getElementById('sys-language');
      const sysConnection = document.getElementById('sys-connection');
      const sysLatency = document.getElementById('sys-latency');
      const sysIpMock = document.getElementById('sys-ip-mock');
      const sysMemory = document.getElementById('sys-memory');
      const sysCores = document.getElementById('sys-cores');
      
      if (!sysDevice) return;
      
      // Detect device type
      const ua = navigator.userAgent;
      let deviceType = 'UNKNOWN';
      if (/Mobile|Android|iPhone|iPad/i.test(ua)) {
        if (/iPad/i.test(ua)) deviceType = 'TABLET_iOS';
        else if (/Android.*Tablet/i.test(ua)) deviceType = 'TABLET_AND';
        else if (/iPhone/i.test(ua)) deviceType = 'MOBILE_iOS';
        else deviceType = 'MOBILE_AND';
      } else {
        deviceType = 'DESKTOP';
      }
      
      // Detect OS
      let osName = 'UNKNOWN';
      if (/Windows/i.test(ua)) osName = 'WIN_NT';
      else if (/Mac/i.test(ua)) osName = 'DARWIN';
      else if (/Linux/i.test(ua)) osName = 'LINUX';
      else if (/Android/i.test(ua)) osName = 'ANDROID';
      else if (/iOS|iPhone|iPad/i.test(ua)) osName = 'iOS';
      
      // Detect Browser
      let browserName = 'UNKNOWN';
      if (/Chrome/i.test(ua) && !/Edge|Edg/i.test(ua)) browserName = 'CHROMIUM';
      else if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) browserName = 'WEBKIT';
      else if (/Firefox/i.test(ua)) browserName = 'GECKO';
      else if (/Edge|Edg/i.test(ua)) browserName = 'EDGE';
      
      // Get connection type
      let connectionType = 'UNKNOWN';
      if (navigator.connection) {
        connectionType = navigator.connection.effectiveType?.toUpperCase() || 'UNKNOWN';
      }
      
      // Generate mock IP
      const mockIP = `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
      const mockPort = Math.floor(Math.random() * 65535);
      
      // Memory info
      let memoryInfo = 'N/A';
      if (navigator.deviceMemory) {
        memoryInfo = `${navigator.deviceMemory}GB`;
      }
      
      // CPU cores
      let cpuCores = 'N/A';
      if (navigator.hardwareConcurrency) {
        cpuCores = `${navigator.hardwareConcurrency}`;
      }
      
      // Animate info display
      const displayInfo = (el, prefix, value, delay, highlight = false) => {
        setTimeout(() => {
          el.textContent = `${prefix}: ${value}`;
          el.classList.add('active');
          if (highlight) el.classList.add('highlight');
          setTimeout(() => el.classList.remove('active'), 300);
        }, delay);
      };
      
      displayInfo(sysDevice, 'DEV_TYPE', deviceType, 200);
      displayInfo(sysOS, 'OS_KERNEL', osName, 400);
      displayInfo(sysBrowser, 'RENDER_ENG', browserName, 600);
      displayInfo(sysResolution, 'VIEWPORT', `${window.innerWidth}x${window.innerHeight}`, 800);
      displayInfo(sysLanguage, 'LOCALE', navigator.language || 'N/A', 1000);
      displayInfo(sysConnection, 'NET_TYPE', connectionType, 1200);
      displayInfo(sysMemory, 'MEM_ALLOC', memoryInfo, 1600);
      displayInfo(sysCores, 'CPU_THREAD', cpuCores, 1800);
      displayInfo(sysIpMock, 'TRACE_ADDR', `${mockIP}:${mockPort}`, 2000, true);
      
      // Ping simulation
      let pingUpdateInterval = null;
      const updateLatency = () => {
        const basePing = Math.floor(Math.random() * 30) + 10;
        const jitter = Math.floor(Math.random() * 15);
        sysLatency.textContent = `LATENCY: ${basePing + jitter}ms`;
        sysLatency.classList.add('active');
        setTimeout(() => sysLatency.classList.remove('active'), 300);
      };
      setTimeout(() => {
        updateLatency();
        pingUpdateInterval = setInterval(updateLatency, 2000);
      }, 1400);
      
      // Store interval for cleanup
      window.sysInfoPingInterval = pingUpdateInterval;
    }
    
    // Initialize system info panel
    initSystemInfoPanel();
    
    // ==========================================
    // Matrix Digital Rain Effect (Ultra-Detailed Movie Style)
    // ==========================================
    const matrixCanvas = document.getElementById('matrix-canvas');
    const matrixCtx = matrixCanvas.getContext('2d', { willReadFrequently: true });
    let matrixAnimationId = null;
    
    // Glow particles canvas
    const glowParticlesCanvas = document.getElementById('glow-particles-canvas');
    const glowCtx = glowParticlesCanvas ? glowParticlesCanvas.getContext('2d') : null;
    let glowParticles = [];
    
    // Initialize matrix canvas size
    let hexaTitleInitialized = false;
    const resizeMatrixCanvas = () => {
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
      if (glowParticlesCanvas) {
        glowParticlesCanvas.width = window.innerWidth;
        glowParticlesCanvas.height = window.innerHeight;
      }
      // Re-initialize HEXA title on resize (will be set after initHexaTitle is defined)
      if (hexaTitleInitialized && typeof initHexaTitle === 'function') {
        initHexaTitle();
      }
    };
    resizeMatrixCanvas();
    window.addEventListener('resize', resizeMatrixCanvas);
    
    // Glow Particle class for ambient effects
    class GlowParticle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = Math.random() * (glowParticlesCanvas?.width || window.innerWidth);
        this.y = Math.random() * (glowParticlesCanvas?.height || window.innerHeight);
        this.size = Math.random() * 3 + 1;
        this.speedX = (Math.random() - 0.5) * 0.5;
        this.speedY = Math.random() * 0.5 + 0.2;
        this.opacity = Math.random() * 0.5 + 0.2;
        this.life = Math.random() * 100 + 50;
        this.maxLife = this.life;
        this.char = Math.random() < 0.3 ? 
          'アイウエオカキクケコ'[Math.floor(Math.random() * 10)] : '';
      }
      
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        this.opacity = (this.life / this.maxLife) * 0.5;
        
        if (this.life <= 0 || this.y > (glowParticlesCanvas?.height || window.innerHeight)) {
          this.reset();
          this.y = -10;
        }
      }
      
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = '#00ff46';
        ctx.shadowColor = '#00ff46';
        ctx.shadowBlur = 10;
        
        if (this.char) {
          ctx.font = `${this.size * 4}px monospace`;
          ctx.fillText(this.char, this.x, this.y);
        } else {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }
    
    // Initialize glow particles (軽量化: パーティクル数を50→20に削減)
    const initGlowParticles = () => {
      glowParticles = [];
      for (let i = 0; i < 20; i++) {
        glowParticles.push(new GlowParticle());
      }
    };
    if (glowCtx) initGlowParticles();
    
    // Character sets (katakana, numbers, symbols, flipped variants)
    const katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
    const numbers = '0123456789';
    const symbols = '!@#$%^&*()_+-=[]{}|;:<>?/~`';
    const flipped = '∀Ↄ∃∀⅁HIſ⋊⅂WNOԀΌᴚS⊥∩ΛM⅄Z';
    const corrupted = '▓░▒█▀▄■□▪▫';
    const allChars = katakana + numbers + symbols + flipped + corrupted;
    
    // Matrix configuration
    const fontSize = 14;
    const columnWidth = fontSize * 0.8;
    let columns = [];
    let highlights = [];
    let frameCount = 0;
    
    // Column class for individual streams
    class MatrixColumn {
      constructor(x, speed, layer) {
        this.x = x;
        this.y = Math.random() * -500;
        this.speed = speed;
        this.chars = [];
        this.layer = layer; // 0: background, 1: midground, 2: foreground
        this.glowIntensity = layer === 2 ? 1.0 : layer === 1 ? 0.6 : 0.3;
        this.charCount = Math.floor(Math.random() * 15) + 10;
        this.refreshRate = Math.random() * 0.15 + 0.05;
        
        // Initialize characters
        for (let i = 0; i < this.charCount; i++) {
          this.chars.push({
            char: allChars[Math.floor(Math.random() * allChars.length)],
            corrupted: Math.random() < 0.08,
            distorted: Math.random() < 0.05,
            brightness: 1 - (i / this.charCount) * 0.8
          });
        }
      }
      
      update() {
        this.y += this.speed;
        
        // Random character refresh
        for (let i = 0; i < this.chars.length; i++) {
          if (Math.random() < this.refreshRate) {
            this.chars[i].char = allChars[Math.floor(Math.random() * allChars.length)];
            this.chars[i].corrupted = Math.random() < 0.08;
            this.chars[i].distorted = Math.random() < 0.05;
          }
        }
        
        // Reset when off screen
        if (this.y - this.charCount * fontSize > matrixCanvas.height) {
          this.y = Math.random() * -300;
          this.speed = (Math.random() * 3 + 1) * (this.layer + 1) * 0.5;
          this.charCount = Math.floor(Math.random() * 15) + 10;
        }
      }
      
      draw(ctx) {
        for (let i = 0; i < this.chars.length; i++) {
          const charY = this.y + i * fontSize;
          if (charY < 0 || charY > matrixCanvas.height) continue;
          
          const charData = this.chars[i];
          const isHead = i === 0;
          
          // Calculate color and glow
          let alpha = charData.brightness * this.glowIntensity;
          let r, g, b;
          
          if (isHead) {
            // Bright white head with intense glow
            r = 255; g = 255; b = 255;
            alpha = 1;
          } else if (charData.corrupted) {
            // Corrupted characters have slight red tint
            r = 120; g = 255; b = 120;
            alpha *= 0.7;
          } else {
            // Normal green with varying intensity
            r = 0;
            g = Math.floor(200 + 55 * charData.brightness);
            b = Math.floor(50 * charData.brightness);
          }
          
          ctx.save();
          
          // Apply distortion
          if (charData.distorted) {
            ctx.translate(this.x + Math.random() * 4 - 2, charY);
            ctx.scale(Math.random() < 0.5 ? -1 : 1, Math.random() < 0.3 ? -1 : 1);
          } else {
            ctx.translate(this.x, charY);
          }
          
          // Glow effect for foreground
          if (this.layer === 2 || isHead) {
            ctx.shadowColor = isHead ? '#ffffff' : '#00ff00';
            ctx.shadowBlur = isHead ? 20 : 10 * this.glowIntensity;
          }
          
          // Set font with slight variation
          const fontVariation = charData.corrupted ? fontSize * (0.8 + Math.random() * 0.4) : fontSize;
          ctx.font = `${fontVariation}px monospace`;
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          ctx.fillText(charData.char, 0, 0);
          
          // Double draw for glow effect
          if (isHead) {
            ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.fillText(charData.char, 0, 0);
          }
          
          ctx.restore();
        }
      }
    }
    
    // Flickering highlight class
    class MatrixHighlight {
      constructor() {
        this.x = Math.random() * matrixCanvas.width;
        this.y = Math.random() * matrixCanvas.height;
        this.char = allChars[Math.floor(Math.random() * allChars.length)];
        this.life = Math.random() * 10 + 5;
        this.maxLife = this.life;
      }
      
      update() {
        this.life--;
        if (Math.random() < 0.3) {
          this.char = allChars[Math.floor(Math.random() * allChars.length)];
        }
        return this.life > 0;
      }
      
      draw(ctx) {
        const alpha = (this.life / this.maxLife);
        ctx.save();
        ctx.font = `${fontSize * 1.5}px monospace`;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 25;
        ctx.fillText(this.char, this.x, this.y);
        ctx.restore();
      }
    }
    
    // Initialize columns for multiple layers (軽量化: カラム数を大幅削減)
    const initMatrixColumns = () => {
      columns = [];
      const numColumns = Math.ceil(matrixCanvas.width / columnWidth);
      
      // Background layer (slower, dimmer) - 0.4→0.2に削減
      for (let i = 0; i < numColumns * 0.2; i++) {
        const x = Math.random() * matrixCanvas.width;
        columns.push(new MatrixColumn(x, Math.random() * 1 + 0.5, 0));
      }
      
      // Midground layer - 0.4→0.2に削減
      for (let i = 0; i < numColumns * 0.2; i++) {
        const x = Math.random() * matrixCanvas.width;
        columns.push(new MatrixColumn(x, Math.random() * 2 + 1, 1));
      }
      
      // Foreground layer (faster, brighter) - 0.5→0.25に削減
      for (let i = 0; i < numColumns * 0.25; i++) {
        const x = Math.random() * matrixCanvas.width;
        columns.push(new MatrixColumn(x, Math.random() * 4 + 2, 2));
      }
    };
    initMatrixColumns();
    // Sort once after initialization
    columns.sort((a, b) => a.layer - b.layer);
    
    // Draw scanlines (CRT effect)
    const drawScanlines = (ctx) => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      for (let y = 0; y < matrixCanvas.height; y += 3) {
        ctx.fillRect(0, y, matrixCanvas.width, 1);
      }
    };
    
    // ==========================================
    // HEXA Title - Matrix Code Integration
    // ==========================================
    
    // HEXA letter definitions using a pixel-art style grid (7x9 grid for each letter)
    const hexaLetterPatterns = {
      H: [
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,1,1,1,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,0,0,0,1]
      ],
      E: [
        [1,1,1,1,1],
        [1,0,0,0,0],
        [1,0,0,0,0],
        [1,1,1,1,0],
        [1,0,0,0,0],
        [1,0,0,0,0],
        [1,1,1,1,1]
      ],
      X: [
        [1,0,0,0,1],
        [0,1,0,1,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,1,0,1,0],
        [1,0,0,0,1]
      ],
      A: [
        [0,0,1,0,0],
        [0,1,0,1,0],
        [1,0,0,0,1],
        [1,1,1,1,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,0,0,0,1]
      ]
    };
    
    // HEXA title particle system
    class HexaTitleParticle {
      constructor(targetX, targetY, isStroke) {
        this.targetX = targetX;
        this.targetY = targetY;
        this.x = targetX + (Math.random() - 0.5) * 20;
        this.y = targetY + (Math.random() - 0.5) * 20;
        this.isStroke = isStroke;
        this.char = allChars[Math.floor(Math.random() * allChars.length)];
        this.opacity = isStroke ? 0.15 + Math.random() * 0.25 : 0.02 + Math.random() * 0.05;
        this.baseOpacity = this.opacity;
        this.phase = Math.random() * Math.PI * 2;
        this.phaseSpeed = 0.02 + Math.random() * 0.03;
        this.size = isStroke ? 10 + Math.random() * 4 : 8 + Math.random() * 3;
        this.glowIntensity = isStroke ? 0.4 + Math.random() * 0.3 : 0.05;
        this.charChangeRate = isStroke ? 0.02 : 0.01;
        this.shimmerPhase = Math.random() * Math.PI * 2;
        this.shimmerSpeed = 0.05 + Math.random() * 0.05;
      }
      
      update(time) {
        this.phase += this.phaseSpeed;
        this.shimmerPhase += this.shimmerSpeed;
        
        // Subtle position oscillation
        this.x = this.targetX + Math.sin(this.phase) * 1.5;
        this.y = this.targetY + Math.cos(this.phase * 0.7) * 1.5;
        
        // Character change
        if (Math.random() < this.charChangeRate) {
          this.char = allChars[Math.floor(Math.random() * allChars.length)];
        }
        
        // Opacity pulse with shimmer
        const shimmer = Math.sin(this.shimmerPhase) * 0.1;
        this.opacity = this.baseOpacity * (0.7 + Math.sin(this.phase) * 0.3) + shimmer;
      }
      
      draw(ctx) {
        ctx.save();
        
        const green = this.isStroke ? 220 + Math.floor(Math.random() * 35) : 180 + Math.floor(Math.random() * 40);
        const brightness = this.isStroke ? 1.2 : 0.6;
        
        // Holographic color shift for stroke particles
        let r = 0, g = green, b = Math.floor(green * 0.3);
        if (this.isStroke) {
          const holo = Math.sin(this.shimmerPhase * 2) * 0.15;
          r = Math.floor(holo > 0 ? holo * 50 : 0);
          b = Math.floor(green * 0.4 + Math.abs(holo) * 30);
        }
        
        ctx.globalAlpha = Math.min(1, this.opacity);
        ctx.font = `${this.size}px monospace`;
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        // Glow effect for stroke particles
        if (this.isStroke && this.glowIntensity > 0.3) {
          ctx.shadowColor = `rgba(0, 255, 70, ${this.glowIntensity})`;
          ctx.shadowBlur = 8 * this.glowIntensity;
        }
        
        ctx.fillText(this.char, this.x, this.y);
        
        // Extra glow pass for bright particles
        if (this.isStroke && Math.random() < 0.3) {
          ctx.globalAlpha = this.opacity * 0.3;
          ctx.shadowBlur = 15;
          ctx.fillText(this.char, this.x, this.y);
        }
        
        ctx.restore();
      }
    }
    
    // Initialize HEXA title particles
    let hexaParticles = [];
    const initHexaTitle = () => {
      hexaParticles = [];
      
      const letters = ['H', 'E', 'X', 'A'];
      const cellSize = Math.min(matrixCanvas.width / 25, 12); // Responsive size
      const letterWidth = 5 * cellSize;
      const letterHeight = 7 * cellSize;
      const spacing = cellSize * 1.5;
      const totalWidth = letters.length * letterWidth + (letters.length - 1) * spacing;
      const startX = (matrixCanvas.width - totalWidth) / 2;
      const startY = matrixCanvas.height * 0.12; // Upper portion of screen
      
      letters.forEach((letter, letterIndex) => {
        const pattern = hexaLetterPatterns[letter];
        const letterX = startX + letterIndex * (letterWidth + spacing);
        
        for (let row = 0; row < pattern.length; row++) {
          for (let col = 0; col < pattern[row].length; col++) {
            const isStroke = pattern[row][col] === 1;
            const x = letterX + col * cellSize;
            const y = startY + row * cellSize;
            
            // More particles for stroke areas, fewer for background (軽量化: パーティクル数削減)
            const particleCount = isStroke ? 2 + Math.floor(Math.random() * 1) : (Math.random() < 0.5 ? 1 : 0);
            
            for (let p = 0; p < particleCount; p++) {
              const offsetX = (Math.random() - 0.5) * cellSize * 0.8;
              const offsetY = (Math.random() - 0.5) * cellSize * 0.8;
              hexaParticles.push(new HexaTitleParticle(x + offsetX, y + offsetY, isStroke));
            }
          }
        }
      });
      
      // Add ambient particles around the title (軽量化: 50→20に削減)
      const ambientCount = 20;
      for (let i = 0; i < ambientCount; i++) {
        const x = startX - cellSize * 2 + Math.random() * (totalWidth + cellSize * 4);
        const y = startY - cellSize * 2 + Math.random() * (letterHeight + cellSize * 4);
        hexaParticles.push(new HexaTitleParticle(x, y, false));
      }
    };
    
    // Draw HEXA title
    const drawHexaTitle = (ctx, time) => {
      for (const particle of hexaParticles) {
        particle.update(time);
        particle.draw(ctx);
      }
    };
    
    // Initialize HEXA title
    initHexaTitle();
    hexaTitleInitialized = true;
    
    // Main matrix animation loop (軽量化: 描画頻度を削減しつつ見た目を維持)
    const animateMatrix = () => {
      frameCount++;
      
      // Clear with trail effect (motion blur)
      matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
      
      // Every few frames, do a deeper clear for CRT haze (3→5フレームに変更)
      if (frameCount % 5 === 0) {
        matrixCtx.fillStyle = 'rgba(0, 8, 0, 0.02)';
        matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
      }
      
      // Update and draw columns (already sorted by layer)
      for (const column of columns) {
        column.update();
        column.draw(matrixCtx);
      }
      
      // Add random highlights/flickers (軽量化: 0.2→0.08に削減)
      if (Math.random() < 0.08) {
        highlights.push(new MatrixHighlight());
      }
      
      // Update and draw highlights (軽量化: 最大数を制限)
      if (highlights.length > 10) highlights = highlights.slice(-10);
      highlights = highlights.filter(h => {
        h.draw(matrixCtx);
        return h.update();
      });
      
      // Add scanlines occasionally for CRT effect (軽量化: 2→4フレームに変更)
      if (frameCount % 4 === 0) {
        drawScanlines(matrixCtx);
      }
      
      // Occasional screen flicker (軽量化: 0.005→0.002に削減)
      if (Math.random() < 0.002) {
        matrixCtx.fillStyle = 'rgba(0, 50, 0, 0.1)';
        matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
      }
      
      // Draw HEXA title integrated with matrix code (軽量化: 2フレームごとに描画)
      if (frameCount % 2 === 0) {
        drawHexaTitle(matrixCtx, frameCount);
      }
      
      // Draw glow particles (軽量化: 3フレームごとに描画)
      if (glowCtx && glowParticlesCanvas && frameCount % 3 === 0) {
        glowCtx.clearRect(0, 0, glowParticlesCanvas.width, glowParticlesCanvas.height);
        for (const particle of glowParticles) {
          particle.update();
          particle.draw(glowCtx);
        }
      }
      
      matrixAnimationId = requestAnimationFrame(animateMatrix);
    };
    
    // Start matrix animation
    animateMatrix();
    
    // Stop matrix animation function
    const stopMatrixAnimation = () => {
      if (matrixAnimationId) {
        cancelAnimationFrame(matrixAnimationId);
        matrixAnimationId = null;
      }
      // Clear glitch interval
      if (glitchInterval) {
        clearInterval(glitchInterval);
        glitchInterval = null;
      }
      // Fade out the canvases
      matrixCanvas.classList.add('matrix-fade-out');
      if (glowParticlesCanvas) {
        glowParticlesCanvas.classList.add('matrix-fade-out');
      }
      setTimeout(() => {
        matrixCanvas.style.display = 'none';
        if (glowParticlesCanvas) {
          glowParticlesCanvas.style.display = 'none';
        }
      }, 500);
    };

    // Glitch text messages for boot sequence
    const glitchMessages = [
      'INITIALIZE_AI_CORE',
      'ENGAGE_SYSTEM_BOOT',
      'LOADING_NEURAL_NET',
      'SYNCING_MATRIX_DATA',
      'DECRYPT_CORE_FILES'
    ];
    let glitchInterval = null;
    
    // Glitch text animation
    const animateGlitchText = (element, finalText) => {
      const chars = 'アイウエオカキクケコ0123456789!@#$%^&*';
      let iterations = 0;
      const maxIterations = finalText.length * 3;
      
      if (glitchInterval) clearInterval(glitchInterval);
      
      glitchInterval = setInterval(() => {
        element.innerText = finalText.split('').map((char, index) => {
          if (index < iterations / 3) return finalText[index];
          return chars[Math.floor(Math.random() * chars.length)];
        }).join('');
        
        element.setAttribute('data-text', element.innerText);
        
        iterations++;
        if (iterations >= maxIterations) {
          clearInterval(glitchInterval);
          element.innerText = finalText;
          element.setAttribute('data-text', finalText);
        }
      }, 30);
    };
    
    const startBoot = (e) => {
      if (isBooting) return;
      if (e.cancelable) e.preventDefault();
      isBooting = true;
      powerBtn.classList.add('active');
      
      // Glitchy boot text animation
      animateGlitchText(bootText, 'ENGAGING_SYSTEM...');
      bootText.classList.add('blink');
      
      if (!audio.ctx) audio.init();
      if (audio.ctx && audio.ctx.state === 'suspended') audio.ctx.resume();
      
      if (audio.ctx) {
        bootSoundOsc = audio.ctx.createOscillator();
        bootSoundGain = audio.ctx.createGain();
        bootSoundOsc.type = 'sawtooth';
        bootSoundOsc.frequency.setValueAtTime(50, audio.ctx.currentTime);
        bootSoundOsc.frequency.linearRampToValueAtTime(200, audio.ctx.currentTime + 2);
        bootSoundGain.gain.setValueAtTime(0.1, audio.ctx.currentTime);
        bootSoundGain.gain.linearRampToValueAtTime(0.5, audio.ctx.currentTime + 2);
        
        const filter = audio.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(100, audio.ctx.currentTime);
        filter.frequency.linearRampToValueAtTime(2000, audio.ctx.currentTime + 2);
        
        bootSoundOsc.connect(filter);
        filter.connect(bootSoundGain);
        bootSoundGain.connect(audio.ctx.destination);
        bootSoundOsc.start();
      }
    };

    const updateRing = (p) => {
      const circumference = 2 * Math.PI * 45;
      const offset = circumference - (p / 100) * circumference;
      ringProgress.style.strokeDashoffset = offset;
    };

    powerBtn.addEventListener('mousedown', startBoot);
    powerBtn.addEventListener('touchstart', startBoot, {passive: false});

    const bootLoop = () => {
      if (gameState !== 'BOOT') return;
      
      if (isBooting) {
        progress += 1.5;
        if (progress >= 100) {
          progress = 100;
          completeBoot();
          return;
        }
      }
      updateRing(progress);
      
      if (isBooting && progress > 0) {
        const shake = Math.random() * (progress / 20);
        powerBtn.style.transform = `translate(${Math.random()*shake - shake/2}px, ${Math.random()*shake - shake/2}px)`;
      } else {
        powerBtn.style.transform = 'none';
      }
      requestAnimationFrame(bootLoop);
    };
    
    requestAnimationFrame(bootLoop);

    const completeBoot = () => {
      // Stop matrix animation
      stopMatrixAnimation();
      
      audio.playTitleBGM();

      if (bootSoundOsc) {
        try { bootSoundOsc.stop(); } catch(e){}
        bootSoundOsc = null;
      }
      
      if (audio.ctx) {
        const osc = audio.ctx.createOscillator();
        const gain = audio.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, audio.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(880, audio.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, audio.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audio.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audio.ctx.destination);
        osc.start();
        osc.stop(audio.ctx.currentTime + 0.5);
      }

      bootScreen.style.backgroundColor = '#fff';
      powerBtn.style.display = 'none';
      bootText.style.display = 'none';
      
      setTimeout(() => {
        bootScreen.style.transition = 'opacity 1s';
        bootScreen.style.opacity = '0';
        modeScreen.style.display = 'flex';
        modeScreen.style.opacity = '0';
        modeScreen.style.transition = 'opacity 1s';
        
        void modeScreen.offsetWidth;
        modeScreen.style.opacity = '1';
        
        gameState = 'TITLE';
        
        // Initialize HEXA logo effects
        initHexaLogoEffects();
        
        setTimeout(() => {
          bootScreen.style.display = 'none';
        }, 1000);
      }, 100);
    };
  }
  
  // ==========================================
  // HEXA Logo Dynamic Effects
  // ==========================================
  function initHexaLogoEffects() {
    const hexaLetters = document.querySelectorAll('.hexa-letter');
    const particlesContainer = document.getElementById('hexa-particles');
    
    if (!hexaLetters.length || !particlesContainer) return;
    
    // Create floating particles
    const createParticle = () => {
      const particle = document.createElement('div');
      particle.className = 'hexa-particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.top = Math.random() * 100 + '%';
      particle.style.animationDuration = (Math.random() * 2 + 1) + 's';
      particle.style.animationDelay = Math.random() * 2 + 's';
      particlesContainer.appendChild(particle);
      
      setTimeout(() => particle.remove(), 4000);
    };
    
    // Spawn particles periodically
    setInterval(() => {
      if (document.getElementById('mode-select-screen').style.display !== 'none') {
        for (let i = 0; i < 2; i++) createParticle();
      }
    }, 500);
    
    // Random micro-glitch effect on letters
    const triggerMicroGlitch = (letter) => {
      if (Math.random() > 0.3) return;
      
      letter.classList.add('refract-active');
      setTimeout(() => letter.classList.remove('refract-active'), 150);
    };
    
    // Periodic random glitch triggers
    setInterval(() => {
      if (document.getElementById('mode-select-screen').style.display === 'none') return;
      
      const randomLetter = hexaLetters[Math.floor(Math.random() * hexaLetters.length)];
      triggerMicroGlitch(randomLetter);
    }, 2000);
    
    // Add data stream effect around letters during reconstruction
    hexaLetters.forEach((letter, index) => {
      letter.addEventListener('animationiteration', () => {
        // Create tiny data fragments during animation cycles
        if (Math.random() > 0.7) {
          const fragment = document.createElement('span');
          fragment.className = 'hexa-micro-fragment';
          fragment.textContent = ['0', '1', '∆', '∇', '□'][Math.floor(Math.random() * 5)];
          fragment.style.cssText = `
            position: absolute;
            font-size: 6px;
            color: rgba(0, 255, 255, 0.6);
            pointer-events: none;
            animation: micro-fragment-float 0.5s ease-out forwards;
            left: ${50 + (Math.random() - 0.5) * 40}%;
            top: ${50 + (Math.random() - 0.5) * 40}%;
          `;
          letter.appendChild(fragment);
          setTimeout(() => fragment.remove(), 500);
        }
      });
    });
    
    // Add CSS for micro fragments
    if (!document.getElementById('hexa-micro-style')) {
      const style = document.createElement('style');
      style.id = 'hexa-micro-style';
      style.textContent = `
        @keyframes micro-fragment-float {
          0% { opacity: 1; transform: translate(0, 0) scale(1); }
          100% { opacity: 0; transform: translate(${Math.random() > 0.5 ? '' : '-'}20px, -30px) scale(0.5); }
        }
        .hexa-particle {
          animation: particle-drift 3s ease-in-out infinite;
        }
        @keyframes particle-drift {
          0%, 100% { opacity: 0; transform: translateY(0) scale(0.5); }
          20% { opacity: 0.8; }
          80% { opacity: 0.8; }
          50% { transform: translateY(-20px) scale(1); }
        }
      `;
      document.head.appendChild(style);
    }
  }

  // ==========================================
  // レイアウト計算 (Layout Calculation)
  // ==========================================
  p.windowResized = function() {
    p.resizeCanvas(p.windowWidth, p.windowHeight);
    calculateLayout();
  };

  // ロボットの状態を更新する関数
  function updateRobotState() {
    const t = p.frameCount;
    
    // 表情変更タイマーを更新
    robotState.moodTimer++;
    
    // 現在の表情が終了したら新しい表情をランダムに選択
    if (robotState.moodTimer >= robotState.moodDuration) {
      robotState.moodTimer = 0;
      
      // 睡眠中からの復帰は驚きに
      if (robotState.mood === 'sleeping') {
        robotState.mood = 'surprised';
        robotState.surpriseTimer = 0;
        robotState.moodDuration = 60; // 驚きは短め
      } else if (robotState.mood === 'surprised') {
        // 驚き後はhappyに
        robotState.mood = 'happy';
        robotState.moodDuration = 180 + Math.floor(Math.random() * 200);
      } else {
        // ランダムに新しい表情を選択
        const rand = Math.random();
        if (rand < 0.35) {
          robotState.mood = 'happy';
          robotState.moodDuration = 200 + Math.floor(Math.random() * 250);
        } else if (rand < 0.55) {
          robotState.mood = 'neutral';
          robotState.moodDuration = 150 + Math.floor(Math.random() * 200);
        } else if (rand < 0.75) {
          robotState.mood = 'watching';
          robotState.watchingBlock = true;
          robotState.moodDuration = 180 + Math.floor(Math.random() * 150);
        } else if (rand < 0.90) {
          robotState.mood = 'sleepy';
          robotState.yawnTimer = 0;
          robotState.moodDuration = 200 + Math.floor(Math.random() * 100);
        } else {
          robotState.mood = 'sleeping';
          robotState.sleepZzTimer = 0;
          robotState.moodDuration = 300 + Math.floor(Math.random() * 200);
        }
      }
    }
    
    // 瞬きのタイミング更新
    robotState.blinkTimer++;
    if (!robotState.isBlinking && robotState.blinkTimer > 90 + Math.random() * 120) {
      robotState.isBlinking = true;
      robotState.blinkTimer = 0;
    }
    if (robotState.isBlinking && robotState.blinkTimer > 8) {
      robotState.isBlinking = false;
      robotState.blinkTimer = 0;
    }
    
    // watching時はプレイヤーのブロックを追跡
    if (robotState.mood === 'watching' && playerGame && playerGame.currentPiece) {
      const piece = playerGame.currentPiece;
      // ブロックのX座標に基づいて視線を移動
      robotState.eyeTargetX = (piece.x - 3.5) * 3;
      robotState.eyeTargetY = Math.max(-5, Math.min(5, (piece.y - 7) * 0.5));
    } else if (robotState.mood !== 'watching') {
      // 通常時は中央またはランダムな方向
      if (Math.random() < 0.02) {
        robotState.eyeTargetX = (Math.random() - 0.5) * 10;
        robotState.eyeTargetY = (Math.random() - 0.5) * 6;
      }
    }
    
    // 視線をスムーズに移動
    robotState.currentEyeX += (robotState.eyeTargetX - robotState.currentEyeX) * 0.1;
    robotState.currentEyeY += (robotState.eyeTargetY - robotState.currentEyeY) * 0.1;
    
    // あくびタイマー更新
    if (robotState.mood === 'sleepy') {
      robotState.yawnTimer++;
      if (robotState.yawnTimer > 60 && robotState.yawnTimer < 100) {
        robotState.isYawning = true;
      } else {
        robotState.isYawning = false;
      }
    }
    
    // 睡眠Zzzタイマー更新
    if (robotState.mood === 'sleeping') {
      robotState.sleepZzTimer++;
    }
    
    // 驚きタイマー更新
    if (robotState.mood === 'surprised') {
      robotState.surpriseTimer++;
    }
  }
  
  // ====================================================
  // カートゥーン調の可愛いAIキャラクター
  // ====================================================
  function drawCuteCartoonCharacter(t, floatY) {
    updateRobotState();
    
    let actualFloatY = floatY;
    if (robotState.mood === 'sleeping') {
      actualFloatY = floatY * 0.3;
    } else if (robotState.mood === 'surprised') {
      actualFloatY = floatY - Math.sin(robotState.surpriseTimer * 0.5) * 4;
    }
    
    const offsetY = actualFloatY - floatY;
    
    // === 背景のキラキラエフェクト ===
    p.noStroke();
    for (let i = 0; i < 6; i++) {
      let sparklePhase = (t * 0.03 + i * 1.2) % (Math.PI * 2);
      let sparkleAlpha = Math.sin(sparklePhase) * 80 + 40;
      if (sparkleAlpha > 0) {
        let sx = Math.cos(i * 1.05 + t * 0.02) * 70;
        let sy = Math.sin(i * 1.3 + t * 0.015) * 50 + offsetY;
        p.fill(255, 220, 100, sparkleAlpha);
        drawStar(sx, sy, 3, 6, 4);
      }
    }
    
    // === ふわふわグロー ===
    let glowHue = robotState.mood === 'happy' ? [255, 200, 230] : 
                  robotState.mood === 'sleeping' ? [180, 200, 255] :
                  robotState.mood === 'surprised' ? [255, 255, 180] : [200, 240, 255];
    for (let i = 3; i > 0; i--) {
      p.fill(glowHue[0], glowHue[1], glowHue[2], 15 * i);
      p.ellipse(0, offsetY, 130 + i * 15, 110 + i * 15);
    }
    
    // === 体（丸いスライム型） ===
    // 影
    p.fill(0, 50, 80, 60);
    p.ellipse(0, offsetY + 48, 80, 20);
    
    // 体のメイン（グラデーション効果）
    let bodyColor = robotState.mood === 'happy' ? [100, 220, 255] :
                    robotState.mood === 'sleeping' ? [150, 180, 230] :
                    robotState.mood === 'surprised' ? [130, 230, 200] : [120, 210, 250];
    
    // 体の外枠（濃い色）
    p.fill(bodyColor[0] * 0.7, bodyColor[1] * 0.7, bodyColor[2] * 0.8);
    p.ellipse(0, offsetY + 8, 95, 85);
    
    // 体のメイン
    p.fill(bodyColor[0], bodyColor[1], bodyColor[2]);
    p.ellipse(0, offsetY + 5, 90, 80);
    
    // ハイライト（上部）
    p.fill(255, 255, 255, 120);
    p.ellipse(-15, offsetY - 15, 35, 25);
    p.fill(255, 255, 255, 80);
    p.ellipse(20, offsetY - 10, 20, 15);
    
    // === ほっぺた（チーク） ===
    if (robotState.mood !== 'sleeping') {
      let cheekAlpha = robotState.mood === 'happy' ? 180 : 120;
      p.fill(255, 150, 180, cheekAlpha);
      p.ellipse(-32, offsetY + 10, 18, 12);
      p.ellipse(32, offsetY + 10, 18, 12);
    }
    
    // === 目 ===
    drawCuteEyes(t, offsetY);
    
    // === 口 ===
    drawCuteMouth(t, offsetY);
    
    // === 耳（猫耳風） ===
    drawCuteEars(t, offsetY);
    
    // === 睡眠エフェクト ===
    if (robotState.mood === 'sleeping') {
      drawCuteSleepingZzz(t, offsetY);
    }
    
    // === 驚きエフェクト ===
    if (robotState.mood === 'surprised' && robotState.surpriseTimer < 30) {
      drawCuteSurpriseEffect(t, offsetY);
    }
    
    // === ハッピー時のハートエフェクト ===
    if (robotState.mood === 'happy') {
      drawHappyHearts(t, offsetY);
    }
  }
  
  // 星を描画するヘルパー関数
  function drawStar(x, y, radius1, radius2, npoints) {
    let angle = p.TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    p.beginShape();
    for (let a = -p.HALF_PI; a < p.TWO_PI - p.HALF_PI; a += angle) {
      let sx = x + Math.cos(a) * radius2;
      let sy = y + Math.sin(a) * radius2;
      p.vertex(sx, sy);
      sx = x + Math.cos(a + halfAngle) * radius1;
      sy = y + Math.sin(a + halfAngle) * radius1;
      p.vertex(sx, sy);
    }
    p.endShape(p.CLOSE);
  }
  
  // 可愛い目を描画
  function drawCuteEyes(t, offsetY) {
    const eyeY = offsetY - 5;
    const leftEyeX = -18;
    const rightEyeX = 18;
    
    // 瞬き
    let blinkFactor = 1;
    if (robotState.isBlinking) {
      blinkFactor = 0.1;
    } else if (robotState.mood === 'sleeping') {
      blinkFactor = 0;
    } else if (robotState.mood === 'sleepy') {
      blinkFactor = 0.5 + Math.sin(t * 0.03) * 0.15;
    }
    
    if (robotState.mood === 'sleeping') {
      // 寝ている目（閉じた弧）
      p.noFill();
      p.stroke(50, 80, 120);
      p.strokeWeight(3);
      p.arc(leftEyeX, eyeY, 20, 10, 0, p.PI);
      p.arc(rightEyeX, eyeY, 20, 10, 0, p.PI);
    } else if (robotState.mood === 'happy') {
      // 嬉しい目（∩∩形）
      p.noFill();
      p.stroke(50, 80, 120);
      p.strokeWeight(3);
      p.arc(leftEyeX, eyeY + 3, 22, 14 * blinkFactor, p.PI, p.TWO_PI);
      p.arc(rightEyeX, eyeY + 3, 22, 14 * blinkFactor, p.PI, p.TWO_PI);
    } else if (robotState.mood === 'surprised') {
      // 驚いた目（大きな丸）
      p.fill(255);
      p.stroke(50, 80, 120);
      p.strokeWeight(2);
      let surpriseScale = 1 + Math.sin(robotState.surpriseTimer * 0.3) * 0.15;
      p.ellipse(leftEyeX, eyeY, 26 * surpriseScale, 28 * surpriseScale * blinkFactor);
      p.ellipse(rightEyeX, eyeY, 26 * surpriseScale, 28 * surpriseScale * blinkFactor);
      // 瞳
      p.fill(30, 60, 90);
      p.noStroke();
      p.ellipse(leftEyeX, eyeY, 12, 14);
      p.ellipse(rightEyeX, eyeY, 12, 14);
      // ハイライト
      p.fill(255);
      p.ellipse(leftEyeX + 4, eyeY - 4, 6, 6);
      p.ellipse(rightEyeX + 4, eyeY - 4, 6, 6);
    } else {
      // 通常の目（大きな可愛い目）
      // 白目
      p.fill(255);
      p.stroke(50, 80, 120);
      p.strokeWeight(2);
      p.ellipse(leftEyeX, eyeY, 24, 26 * blinkFactor);
      p.ellipse(rightEyeX, eyeY, 24, 26 * blinkFactor);
      
      if (blinkFactor > 0.3) {
        // 瞳（視線追従）
        let eyeOffX = robotState.currentEyeX * 0.3;
        let eyeOffY = robotState.currentEyeY * 0.3;
        p.fill(30, 60, 90);
        p.noStroke();
        p.ellipse(leftEyeX + eyeOffX, eyeY + eyeOffY, 12, 14 * blinkFactor);
        p.ellipse(rightEyeX + eyeOffX, eyeY + eyeOffY, 12, 14 * blinkFactor);
        // ハイライト
        p.fill(255);
        p.ellipse(leftEyeX + eyeOffX + 3, eyeY + eyeOffY - 3, 5, 5);
        p.ellipse(rightEyeX + eyeOffX + 3, eyeY + eyeOffY - 3, 5, 5);
        p.ellipse(leftEyeX + eyeOffX - 2, eyeY + eyeOffY + 2, 3, 3);
        p.ellipse(rightEyeX + eyeOffX - 2, eyeY + eyeOffY + 2, 3, 3);
      }
    }
  }
  
  // 可愛い口を描画
  function drawCuteMouth(t, offsetY) {
    const mouthY = offsetY + 20;
    
    p.noFill();
    p.stroke(50, 80, 120);
    p.strokeWeight(2.5);
    
    if (robotState.mood === 'happy') {
      // 大きな笑顔
      p.arc(0, mouthY - 5, 30, 20, 0, p.PI);
      // 舌
      p.fill(255, 150, 150);
      p.noStroke();
      p.ellipse(0, mouthY + 2, 12, 8);
    } else if (robotState.mood === 'sleeping') {
      // 小さな寝顔の口
      p.stroke(50, 80, 120);
      p.strokeWeight(2);
      p.line(-6, mouthY - 3, 6, mouthY - 3);
    } else if (robotState.mood === 'sleepy') {
      if (robotState.isYawning) {
        // あくび
        p.fill(255, 180, 180);
        p.stroke(50, 80, 120);
        p.strokeWeight(2);
        let yawnSize = 8 + Math.sin((robotState.yawnTimer - 60) * 0.1) * 5;
        p.ellipse(0, mouthY, yawnSize * 1.5, yawnSize * 2);
      } else {
        // 眠そうな口
        p.noFill();
        p.arc(0, mouthY - 3, 18, 10, 0, p.PI);
      }
    } else if (robotState.mood === 'surprised') {
      // 驚いた口（小さなO）
      p.fill(255, 180, 180);
      p.stroke(50, 80, 120);
      p.strokeWeight(2);
      let oSize = 8 + Math.sin(robotState.surpriseTimer * 0.2) * 2;
      p.ellipse(0, mouthY, oSize, oSize * 1.4);
    } else {
      // 普通の笑顔
      p.noFill();
      p.arc(0, mouthY - 3, 22, 14, 0.1, p.PI - 0.1);
    }
  }
  
  // 可愛いパンダ耳を描画
  function drawCuteEars(t, offsetY) {
    let earWiggle = Math.sin(t * 0.08) * 2;
    if (robotState.mood === 'surprised') {
      earWiggle = Math.sin(t * 0.3) * 4;
    }
    
    // パンダ耳のサイズ
    let earSize = 28;
    let innerEarSize = 14;
    
    // 左耳（丸いパンダ耳）
    // 耳の影
    p.fill(20, 20, 25, 80);
    p.noStroke();
    p.ellipse(-38 + earWiggle * 0.3, offsetY - 38, earSize + 4, earSize + 2);
    
    // 耳の外側（黒）
    p.fill(30, 35, 45);
    p.stroke(20, 25, 35);
    p.strokeWeight(2);
    p.ellipse(-38 + earWiggle * 0.3, offsetY - 40, earSize, earSize);
    
    // 耳の内側（ピンク）
    p.fill(255, 160, 180);
    p.noStroke();
    p.ellipse(-38 + earWiggle * 0.3, offsetY - 40, innerEarSize, innerEarSize);
    
    // 耳のハイライト
    p.fill(255, 255, 255, 60);
    p.ellipse(-42 + earWiggle * 0.3, offsetY - 44, 8, 6);
    
    // 右耳（丸いパンダ耳）
    // 耳の影
    p.fill(20, 20, 25, 80);
    p.noStroke();
    p.ellipse(38 - earWiggle * 0.3, offsetY - 38, earSize + 4, earSize + 2);
    
    // 耳の外側（黒）
    p.fill(30, 35, 45);
    p.stroke(20, 25, 35);
    p.strokeWeight(2);
    p.ellipse(38 - earWiggle * 0.3, offsetY - 40, earSize, earSize);
    
    // 耳の内側（ピンク）
    p.fill(255, 160, 180);
    p.noStroke();
    p.ellipse(38 - earWiggle * 0.3, offsetY - 40, innerEarSize, innerEarSize);
    
    // 耳のハイライト
    p.fill(255, 255, 255, 60);
    p.ellipse(42 - earWiggle * 0.3, offsetY - 44, 8, 6);
  }
  
  // 可愛いZzzエフェクト
  function drawCuteSleepingZzz(t, offsetY) {
    const zzzPhase = robotState.sleepZzTimer * 0.025;
    p.textAlign(p.CENTER, p.CENTER);
    p.textFont('Share Tech Mono');
    
    for (let i = 0; i < 3; i++) {
      let zPhase = (zzzPhase + i * 0.7) % 3;
      let zAlpha = 220 - zPhase * 70;
      if (zAlpha > 0) {
        p.fill(150, 180, 255, zAlpha);
        let zx = 50 + i * 10 + Math.sin(t * 0.04 + i) * 4;
        let zy = offsetY - 25 - zPhase * 22;
        let zSize = 14 + i * 3;
        p.textSize(zSize);
        p.text('z', zx, zy);
      }
    }
  }
  
  // 可愛い驚きエフェクト
  function drawCuteSurpriseEffect(t, offsetY) {
    // ポップな放射線
    p.stroke(255, 220, 100, 180 - robotState.surpriseTimer * 5);
    p.strokeWeight(3);
    for (let i = 0; i < 8; i++) {
      let angle = (i / 8) * p.TWO_PI + t * 0.05;
      let r1 = 55 + robotState.surpriseTimer * 0.5;
      let r2 = 70 + robotState.surpriseTimer;
      p.line(
        Math.cos(angle) * r1, offsetY + Math.sin(angle) * r1,
        Math.cos(angle) * r2, offsetY + Math.sin(angle) * r2
      );
    }
    
    // !マーク
    if (robotState.surpriseTimer < 20) {
      p.fill(255, 100, 100);
      p.noStroke();
      p.textSize(24);
      p.textAlign(p.CENTER, p.CENTER);
      p.text('!', 55, offsetY - 35);
    }
  }
  
  // ハッピー時のハートエフェクト
  function drawHappyHearts(t, offsetY) {
    p.noStroke();
    for (let i = 0; i < 3; i++) {
      let heartPhase = (t * 0.04 + i * 2) % 4;
      let heartAlpha = 200 - heartPhase * 50;
      if (heartAlpha > 0 && heartPhase < 3) {
        p.fill(255, 100, 150, heartAlpha);
        let hx = (i - 1) * 40 + Math.sin(t * 0.05 + i) * 8;
        let hy = offsetY - 50 - heartPhase * 15;
        drawHeart(hx, hy, 8 + heartPhase * 2);
      }
    }
  }
  
  // ハート描画ヘルパー
  function drawHeart(x, y, size) {
    p.beginShape();
    p.vertex(x, y);
    p.bezierVertex(x - size/2, y - size/2, x - size, y + size/3, x, y + size);
    p.bezierVertex(x + size, y + size/3, x + size/2, y - size/2, x, y);
    p.endShape(p.CLOSE);
  }
  
  // ロボットを描画する関数（旧版 - 互換性のため残す）
  function drawRobotCharacter(t, floatY) {
    // 状態を更新
    updateRobotState();
    
    // 睡眠中は浮遊を抑える
    let actualFloatY = floatY;
    if (robotState.mood === 'sleeping') {
      actualFloatY = floatY * 0.3;
    } else if (robotState.mood === 'surprised') {
      actualFloatY = floatY - Math.sin(robotState.surpriseTimer * 0.5) * 5;
    }
    
    // Glow（表情によって色が変わる）
    p.noStroke();
    let glowColor = [0, 255, 255, 30];
    if (robotState.mood === 'sleepy' || robotState.mood === 'sleeping') {
      glowColor = [100, 150, 255, 25];
    } else if (robotState.mood === 'surprised') {
      glowColor = [255, 255, 100, 40];
    }
    p.fill(glowColor[0], glowColor[1], glowColor[2], glowColor[3]);
    p.ellipse(0, actualFloatY - floatY, 140, 140);
    
    // Head
    p.fill(20, 30, 45);
    p.stroke(0, 255, 255);
    p.strokeWeight(2);
    p.rectMode(p.CENTER);
    p.rect(0, actualFloatY - floatY, 100, 80, 20);
    
    // Face Screen
    p.fill(0);
    p.noStroke();
    p.rect(0, actualFloatY - floatY, 80, 50, 10);
    
    // 表情によって目と口を描き分ける
    drawRobotFace(t, actualFloatY - floatY);
    
    // Antennas
    p.stroke(0, 255, 255);
    p.strokeWeight(2);
    let antennaWave = robotState.mood === 'surprised' ? Math.sin(t * 0.3) * 5 : 0;
    p.line(-20, -40 + actualFloatY - floatY, -30 + antennaWave, -60 + actualFloatY - floatY);
    p.line(20, -40 + actualFloatY - floatY, 30 - antennaWave, -60 + actualFloatY - floatY);
    
    // アンテナの先端
    p.fill(0, 255, 255);
    p.noStroke();
    let antennaPulse = robotState.mood === 'sleeping' ? 4 : 6 + Math.sin(t * 0.1) * 2;
    p.ellipse(-30 + antennaWave, -60 + actualFloatY - floatY, antennaPulse, antennaPulse);
    p.ellipse(30 - antennaWave, -60 + actualFloatY - floatY, antennaPulse, antennaPulse);
    
    // 睡眠中のZzzエフェクト
    if (robotState.mood === 'sleeping') {
      drawSleepingZzz(t, actualFloatY - floatY);
    }
    
    // 驚き時のエフェクト
    if (robotState.mood === 'surprised' && robotState.surpriseTimer < 30) {
      drawSurpriseEffect(t, actualFloatY - floatY);
    }
  }
  
  // ロボットの顔（目と口）を描画
  function drawRobotFace(t, offsetY) {
    const eyeBaseY = offsetY;
    const eyeOffsetX = robotState.currentEyeX;
    const eyeOffsetY = robotState.currentEyeY;
    
    // 瞬き係数（睡眠中は常に閉じる）
    let blinkFactor = 1;
    if (robotState.isBlinking) {
      blinkFactor = 0.1;
    } else if (robotState.mood === 'sleeping') {
      blinkFactor = 0.1;
    } else if (robotState.mood === 'sleepy') {
      blinkFactor = 0.5 + Math.sin(t * 0.03) * 0.2;
    } else if (robotState.mood === 'surprised') {
      blinkFactor = 1.3;
    }
    
    // 目の描画
    p.fill(0, 255, 255);
    
    if (robotState.mood === 'happy') {
      // 嬉しい目（∩∩ 形）
      p.noFill();
      p.stroke(0, 255, 255);
      p.strokeWeight(3);
      p.arc(-20 + eyeOffsetX, eyeBaseY + 2 + eyeOffsetY, 16, 12 * blinkFactor, p.PI, p.TWO_PI);
      p.arc(20 + eyeOffsetX, eyeBaseY + 2 + eyeOffsetY, 16, 12 * blinkFactor, p.PI, p.TWO_PI);
    } else if (robotState.mood === 'neutral' || robotState.mood === 'watching') {
      // 通常の目（楕円）
      p.noStroke();
      p.ellipse(-20 + eyeOffsetX, eyeBaseY + eyeOffsetY, 12, 18 * blinkFactor);
      p.ellipse(20 + eyeOffsetX, eyeBaseY + eyeOffsetY, 12, 18 * blinkFactor);
      // 瞳（watching時は大きめ）
      if (blinkFactor > 0.3) {
        p.fill(0);
        let pupilSize = robotState.mood === 'watching' ? 6 : 4;
        p.ellipse(-20 + eyeOffsetX * 1.3, eyeBaseY + eyeOffsetY * 1.3, pupilSize, pupilSize * blinkFactor);
        p.ellipse(20 + eyeOffsetX * 1.3, eyeBaseY + eyeOffsetY * 1.3, pupilSize, pupilSize * blinkFactor);
      }
    } else if (robotState.mood === 'sleepy' || robotState.mood === 'sleeping') {
      // 眠そうな目（半開きまたは閉じた線）
      p.noFill();
      p.stroke(0, 255, 255);
      p.strokeWeight(3);
      if (robotState.mood === 'sleeping') {
        // 完全に閉じた目
        p.line(-28, eyeBaseY, -12, eyeBaseY);
        p.line(12, eyeBaseY, 28, eyeBaseY);
      } else {
        // 半開きの目
        p.arc(-20, eyeBaseY + 3, 16, 8 * blinkFactor, 0, p.PI);
        p.arc(20, eyeBaseY + 3, 16, 8 * blinkFactor, 0, p.PI);
      }
    } else if (robotState.mood === 'surprised') {
      // 驚いた目（大きい丸）
      p.noStroke();
      let surpriseScale = 1 + Math.sin(robotState.surpriseTimer * 0.3) * 0.2;
      p.ellipse(-20, eyeBaseY, 16 * surpriseScale, 22 * surpriseScale * blinkFactor);
      p.ellipse(20, eyeBaseY, 16 * surpriseScale, 22 * surpriseScale * blinkFactor);
      // 小さな瞳
      p.fill(0);
      p.ellipse(-20, eyeBaseY, 5, 5);
      p.ellipse(20, eyeBaseY, 5, 5);
    }
    
    // 口の描画
    p.noFill();
    p.stroke(0, 255, 255);
    p.strokeWeight(2);
    
    if (robotState.mood === 'happy') {
      // 笑顔の口（大きなアーチ）
      p.arc(0, eyeBaseY + 12, 25, 15, 0, p.PI);
    } else if (robotState.mood === 'neutral' || robotState.mood === 'watching') {
      // 普通の口（小さなアーチ）
      p.arc(0, eyeBaseY + 10, 20, 10, 0, p.PI);
    } else if (robotState.mood === 'sleepy') {
      if (robotState.isYawning) {
        // あくび（大きな丸）
        p.fill(0, 200, 200);
        let yawnSize = 8 + Math.sin((robotState.yawnTimer - 60) * 0.1) * 6;
        p.ellipse(0, eyeBaseY + 12, yawnSize, yawnSize * 1.2);
      } else {
        // 眠そうな口（小さなへの字）
        p.line(-8, eyeBaseY + 12, 8, eyeBaseY + 12);
      }
    } else if (robotState.mood === 'sleeping') {
      // 睡眠中の口（小さな線）
      p.line(-6, eyeBaseY + 10, 6, eyeBaseY + 10);
    } else if (robotState.mood === 'surprised') {
      // 驚いた口（小さなO）
      p.fill(0, 200, 200);
      let oSize = 6 + Math.sin(robotState.surpriseTimer * 0.2) * 2;
      p.ellipse(0, eyeBaseY + 14, oSize, oSize * 1.3);
    }
  }
  
  // 睡眠中のZzzエフェクト
  function drawSleepingZzz(t, offsetY) {
    const zzzPhase = robotState.sleepZzTimer * 0.02;
    p.fill(100, 200, 255, 200);
    p.noStroke();
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(14);
    p.textFont('Share Tech Mono');
    
    for (let i = 0; i < 3; i++) {
      let zPhase = (zzzPhase + i * 0.8) % 3;
      let zAlpha = 200 - zPhase * 60;
      if (zAlpha > 0) {
        p.fill(100, 200, 255, zAlpha);
        let zx = 45 + i * 8 + Math.sin(t * 0.05 + i) * 3;
        let zy = offsetY - 20 - zPhase * 25;
        let zSize = 12 + i * 2;
        p.textSize(zSize);
        p.text('z', zx, zy);
      }
    }
  }
  
  // 驚きエフェクト
  function drawSurpriseEffect(t, offsetY) {
    // 周囲に放射状の線
    p.stroke(255, 255, 100, 150 - robotState.surpriseTimer * 5);
    p.strokeWeight(2);
    for (let i = 0; i < 8; i++) {
      let angle = (i / 8) * p.TWO_PI + t * 0.1;
      let r1 = 55 + robotState.surpriseTimer;
      let r2 = 70 + robotState.surpriseTimer * 1.5;
      p.line(
        Math.cos(angle) * r1, offsetY + Math.sin(angle) * r1,
        Math.cos(angle) * r2, offsetY + Math.sin(angle) * r2
      );
    }
  }
  
  function drawTrainingHUD(cx, cy) {
    let w = boardWidth;
    let h = boardHeight;
    
    p.push();
    p.translate(cx, cy);
    
    // Scale down to fit in right half
    p.scale(0.85);
    
    // AI Character (Cute Bot) - with dynamic expressions
    let t = p.frameCount;
    let floatY = Math.sin(t * 0.05) * 6;
    
    p.push();
    // AIキャラクターの位置を下げる（コントロールボタンとの間隔確保）
    p.translate(0, -h * 0.08 + floatY);
    
    // ロボットキャラクターを描画（表情・挙動付き）
    drawCuteCartoonCharacter(t, floatY);
    
    p.pop();
    
    // ANALYSISパネルの位置を下げて、ブロック表示枠と下線を揃える
    p.translate(0, h * 0.32);
    
    // ===== Always show Analysis Panel =====
    drawAnalysisPanel(w, h, t);
    
    p.pop();
  }
  
  // Draw Analysis Panel (normal mode) - 未来的デザイン
  function drawAnalysisPanel(w, h, t) {
    let panelW = w * 0.95;
    let panelH = h * 0.46;
    
    // === 外枠のアニメーションエフェクト ===
    // 走査線エフェクト
    let scanLineY = ((t * 0.02) % 1) * panelH - panelH/2;
    
    // パネル外側のグロー効果
    for (let i = 3; i > 0; i--) {
      let glowAlpha = 20 - i * 5;
      p.noFill();
      p.stroke(0, 255, 255, glowAlpha);
      p.strokeWeight(i * 2);
      p.rectMode(p.CENTER);
      p.rect(0, 0, panelW + i * 4, panelH + i * 4, 18);
    }
    
    // メインパネル背景（グラデーション効果）
    p.fill(5, 15, 35, 230);
    p.stroke(0, 255, 255, 150);
    p.strokeWeight(2);
    p.rectMode(p.CENTER);
    p.rect(0, 0, panelW, panelH, 15);
    
    // 内側の装飾ライン
    p.stroke(0, 255, 255, 40);
    p.strokeWeight(1);
    p.rect(0, 0, panelW - 8, panelH - 8, 12);
    
    // コーナーアクセント（4隅）
    let cornerSize = 15;
    let cornerOffset = 4;
    p.stroke(0, 255, 255, 200);
    p.strokeWeight(2);
    // 左上
    p.line(-panelW/2 + cornerOffset, -panelH/2 + cornerOffset + cornerSize, -panelW/2 + cornerOffset, -panelH/2 + cornerOffset);
    p.line(-panelW/2 + cornerOffset, -panelH/2 + cornerOffset, -panelW/2 + cornerOffset + cornerSize, -panelH/2 + cornerOffset);
    // 右上
    p.line(panelW/2 - cornerOffset - cornerSize, -panelH/2 + cornerOffset, panelW/2 - cornerOffset, -panelH/2 + cornerOffset);
    p.line(panelW/2 - cornerOffset, -panelH/2 + cornerOffset, panelW/2 - cornerOffset, -panelH/2 + cornerOffset + cornerSize);
    // 左下
    p.line(-panelW/2 + cornerOffset, panelH/2 - cornerOffset - cornerSize, -panelW/2 + cornerOffset, panelH/2 - cornerOffset);
    p.line(-panelW/2 + cornerOffset, panelH/2 - cornerOffset, -panelW/2 + cornerOffset + cornerSize, panelH/2 - cornerOffset);
    // 右下
    p.line(panelW/2 - cornerOffset - cornerSize, panelH/2 - cornerOffset, panelW/2 - cornerOffset, panelH/2 - cornerOffset);
    p.line(panelW/2 - cornerOffset, panelH/2 - cornerOffset - cornerSize, panelW/2 - cornerOffset, panelH/2 - cornerOffset);
    
    // 走査線（スキャンライン）
    p.stroke(0, 255, 255, 60);
    p.strokeWeight(1);
    p.line(-panelW/2 + 10, scanLineY, panelW/2 - 10, scanLineY);
    
    // ヘッダー背景
    p.noStroke();
    p.fill(0, 255, 255, 25);
    p.rect(0, -panelH/2 + 22, panelW - 20, 28, 5);
    
    // Header タイトル（グリッチエフェクト付き）
    let glitchOffset = Math.random() > 0.98 ? (Math.random() - 0.5) * 4 : 0;
    p.fill(0, 255, 255);
    p.noStroke();
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(12);
    p.textFont('Orbitron');
    p.text("PLAYER ANALYSIS", glitchOffset, -panelH/2 + 22);
    
    // ステータスインジケーター（点滅）
    let indicatorAlpha = 150 + Math.sin(t * 0.15) * 100;
    p.fill(0, 255, 150, indicatorAlpha);
    p.ellipse(-panelW/2 + 20, -panelH/2 + 22, 6, 6);
    
    // === データフィールド ===
    p.textFont('Share Tech Mono');
    
    let startX = -panelW * 0.44;
    let endX = panelW * 0.44;
    let yStart = -panelH * 0.18;
    let lineH = 30;
    
    // データ行を描画するヘルパー関数
    function drawDataRow(label, value, valueColor, y, icon) {
      // 背景バー
      let barAlpha = 40 + Math.sin(t * 0.1 + y * 0.1) * 15;
      p.fill(0, 50, 80, barAlpha);
      p.noStroke();
      p.rect(0, y, panelW - 20, 22, 4);
      
      // ラベル
      p.textAlign(p.LEFT, p.CENTER);
      p.textSize(10);
      p.fill(100, 180, 200);
      p.text(icon + " " + label, startX, y);
      
      // 値（グロー付き）
      p.textAlign(p.RIGHT, p.CENTER);
      p.textSize(13);
      // グロー
      p.fill(valueColor[0], valueColor[1], valueColor[2], 80);
      p.text(value, endX + 1, y + 1);
      // メイン
      p.fill(valueColor[0], valueColor[1], valueColor[2]);
      p.text(value, endX, y);
    }
    
    // Max Combo
    drawDataRow("MAX COMBO", playerGame.maxCombo, [255, 215, 0], yStart, "▶");
    yStart += lineH;
    
    // Total Blocks
    drawDataRow("BLOCKS CLEARED", playerGame.totalBlocksCleared, [0, 255, 255], yStart, "▶");
    yStart += lineH;
    
    // Speed (BPM)
    let elapsedMin = (playerGame.startTime > 0) ? (Date.now() - playerGame.startTime) / 60000 : 0;
    let bpm = elapsedMin > 0.01 ? (playerGame.totalBlocksCleared / elapsedMin).toFixed(1) : "0.0";
    drawDataRow("SPEED [BPM]", bpm, [255, 100, 150], yStart, "▶");
    
    // === ウェーブビジュアライザー ===
    yStart += 38;
    
    // ビジュアライザー背景
    p.fill(0, 30, 50, 100);
    p.noStroke();
    p.rect(0, yStart, panelW - 30, 32, 5);
    
    // 波形のグロー
    p.noFill();
    p.stroke(0, 255, 255, 50);
    p.strokeWeight(6);
    p.beginShape();
    for(let i=0; i<=30; i++) {
        let x = p.map(i, 0, 30, startX, endX);
        let n = p.noise(i * 0.15, t * 0.04);
        let y = yStart + p.map(n, 0, 1, -10, 10);
        p.vertex(x, y);
    }
    p.endShape();
    
    // メインの波形
    p.stroke(0, 255, 255);
    p.strokeWeight(2);
    p.beginShape();
    for(let i=0; i<=30; i++) {
        let x = p.map(i, 0, 30, startX, endX);
        let n = p.noise(i * 0.15, t * 0.04);
        let y = yStart + p.map(n, 0, 1, -10, 10);
        p.vertex(x, y);
    }
    p.endShape();
    
    // 波形上のドット（データポイント）
    p.fill(255, 255, 255);
    p.noStroke();
    for(let i=0; i<=30; i+=5) {
        let x = p.map(i, 0, 30, startX, endX);
        let n = p.noise(i * 0.15, t * 0.04);
        let y = yStart + p.map(n, 0, 1, -10, 10);
        p.ellipse(x, y, 4, 4);
    }
    
  }
  
  // Draw Route Display Panel (route mode - replaces Analysis)
  function drawRouteDisplayPanel(w, h, t) {
    // Panel BG with purple theme for route mode
    p.fill(10, 5, 25, 220);
    p.stroke(180, 100, 255, 100);
    p.strokeWeight(2);
    p.rectMode(p.CENTER);
    p.rect(0, 0, w * 0.95, h * 0.55, 15);
    
    // Animated border glow
    const glowAlpha = 60 + Math.sin(t * 0.08) * 30;
    p.noFill();
    p.stroke(180, 100, 255, glowAlpha);
    p.strokeWeight(4);
    p.rect(0, 0, w * 0.95 + 4, h * 0.55 + 4, 17);
    
    // Header with route icon
    p.fill(200, 150, 255);
    p.noStroke();
    p.textAlign(p.CENTER, p.TOP);
    p.textSize(16);
    p.textFont('Orbitron');
    p.text("⚡ COMBO ROUTE", 0, -h * 0.24);
    
    // Get current chain steps from player hints
    let chainSteps = null;
    let targetCombo = 0;
    
    // Check direct hints first
    if (playerGame && playerGame.directHints && playerGame.directHints.length > 0) {
      const firstHint = playerGame.directHints[0];
      if (firstHint.chainSteps && firstHint.chainSteps.length > 0) {
        chainSteps = firstHint.chainSteps;
        targetCombo = firstHint.chainSteps.length;
      }
    }
    
    // Also check clearPathHints
    if (!chainSteps && playerGame && playerGame.clearPathHints && playerGame.clearPathHints.chainSteps) {
      chainSteps = playerGame.clearPathHints.chainSteps;
      targetCombo = chainSteps.length;
    }
    
    if (chainSteps && chainSteps.length > 0) {
      // Draw route steps in the panel
      const stepColors = [
        [255, 80, 80],     // 1C: Red
        [255, 160, 60],    // 2C: Orange
        [255, 230, 80],    // 3C: Yellow
        [80, 230, 100],    // 4C: Green
        [80, 180, 255],    // 5C: Cyan
        [160, 80, 255],    // 6C: Purple
        [255, 80, 180],    // 7C: Pink
        [255, 255, 255],   // 8C: White
      ];
      
      const animPhase = (t * 0.03) % chainSteps.length;
      const currentStep = Math.floor(animPhase);
      
      const maxStepsToShow = Math.min(chainSteps.length, 6);
      const stepH = 42;
      const startY = -h * 0.15;
      const panelW = w * 0.85;
      
      // Target combo display
      p.fill(255, 200, 80);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(24);
      p.textStyle(p.BOLD);
      p.text(`${targetCombo} COMBO`, 0, startY - 25);
      p.textStyle(p.NORMAL);
      
      // Draw each step
      chainSteps.slice(0, maxStepsToShow).forEach((step, idx) => {
        const stepY = startY + 15 + idx * stepH;
        const color = stepColors[idx % stepColors.length];
        const isCurrentAnim = (idx === currentStep);
        const alpha = isCurrentAnim ? 255 : 150;
        
        // Step background (highlight current)
        if (isCurrentAnim) {
          p.fill(color[0], color[1], color[2], 40);
          p.noStroke();
          p.rectMode(p.CENTER);
          p.rect(0, stepY + stepH/2 - 5, panelW - 10, stepH - 6, 8);
        }
        
        // Step number badge
        p.fill(color[0], color[1], color[2], alpha);
        p.noStroke();
        p.ellipse(-panelW/2 + 25, stepY + stepH/2 - 5, 28, 28);
        
        p.fill(0);
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(14);
        p.textStyle(p.BOLD);
        p.text(step.chainNumber, -panelW/2 + 25, stepY + stepH/2 - 5);
        p.textStyle(p.NORMAL);
        
        // Block count and info
        p.fill(color[0], color[1], color[2], alpha);
        p.textAlign(p.LEFT, p.CENTER);
        p.textSize(13);
        p.textFont('Share Tech Mono');
        p.text(`${step.clearedBlocks.length} ブロック消去`, -panelW/2 + 50, stepY + stepH/2 - 5);
        
        // Show block colors (mini icons)
        const uniqueColors = [...new Set(step.clearedBlocks.map(b => b.color))];
        const miniSize = 16;
        uniqueColors.slice(0, 4).forEach((colorType, cidx) => {
          const bx = panelW/2 - 70 + cidx * (miniSize + 2);
          const by = stepY + stepH/2 - 5;
          
          if (gemImages[colorType]) {
            p.tint(255, alpha);
            p.image(gemImages[colorType], bx, by, miniSize, miniSize);
            p.noTint();
          }
        });
        
        // Current step indicator
        if (isCurrentAnim) {
          p.fill(color[0], color[1], color[2], 200);
          p.noStroke();
          p.triangle(
            panelW/2 - 15, stepY + stepH/2 - 10,
            panelW/2 - 15, stepY + stepH/2,
            panelW/2 - 5, stepY + stepH/2 - 5
          );
        }
      });
      
      // More steps indicator
      if (chainSteps.length > maxStepsToShow) {
        p.fill(150, 150, 180, 150);
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(11);
        p.text(`... +${chainSteps.length - maxStepsToShow} more`, 0, startY + 15 + maxStepsToShow * stepH);
      }
      
    } else {
      // No route available message
      p.fill(150, 150, 180, 180);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(14);
      p.textFont('Share Tech Mono');
      p.text("ブロックを配置すると", 0, -h * 0.05);
      p.text("ルートが表示されます", 0, h * 0.05);
      
      // Animated waiting indicator
      const dotCount = Math.floor((t * 0.05) % 4);
      p.fill(180, 100, 255, 150);
      p.textSize(20);
      p.text(".".repeat(dotCount), 0, h * 0.15);
    }
  }

  function drawTitleBackground() {
    let c1 = p.color(10, 5, 20);
    let c2 = p.color(20, 10, 40);
    for(let y=0; y<p.height; y++){
      let inter = p.map(y, 0, p.height, 0, 1);
      let c = p.lerpColor(c1, c2, inter);
      p.stroke(c);
      p.line(0, y, p.width, y);
    }
    
    p.push();
    p.translate(p.width/2, p.height/2);
    p.rotate(p.frameCount * 0.002);
    p.noFill();
    p.stroke(255, 255, 255, 15);
    p.strokeWeight(2);
    for(let i=0; i<16; i++) {
      p.rotate(p.TWO_PI/16);
      p.line(0, 0, p.width * 1.5, p.height * 1.5);
    }
    p.pop();

    fallingBgBlocks.forEach(b => {
      b.update();
      b.draw();
    });
    
    p.push();
    p.blendMode(p.MULTIPLY);
    p.noStroke();
    let grad = p.drawingContext.createRadialGradient(p.width/2, p.height/2, p.height/3, p.width/2, p.height/2, p.height);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.8)');
    p.drawingContext.fillStyle = grad;
    p.rect(0, 0, p.width, p.height);
    p.pop();
  }

  function calculateLayout() {
    // Calculate grid size to fit 2 boards side by side
    const availableHeight = p.height * 0.65; // Reduced for Next display space
    const availableWidth = (p.width * 0.95) / 2; // Width for one board
    
    // Aspect ratio of board
    const aspect = COLS / VISIBLE_ROWS;
    
    if (availableWidth / aspect < availableHeight) {
      boardWidth = availableWidth;
      boardHeight = boardWidth / aspect;
    } else {
      boardHeight = availableHeight;
      boardWidth = boardHeight * aspect;
    }
    
    cellSize = boardWidth / COLS;
    // Ensure space for Next display (approx 4.5 cells)
    let minTopMargin = cellSize * 3.2 + 3;
    if (minTopMargin < 90) minTopMargin = 90;
    boardY = minTopMargin;
  }

  // ==========================================
  // メイン描画ループ (Main Draw Loop)
  // ==========================================
  p.draw = function() {
    p.clear();
    
    if (gameState === 'TITLE') {
      drawTitleBackground();
    } else {
      if (playerGame && playerGame.opponentIsDevil) {
        drawCyberBackground();
      } else {
        drawDigitalBackground();
      }
    }
    
    if (gameState === 'TITLE' || gameState === 'BOOT') return;

    // Screen Shake Effect
    if (screenShake > 0) {
      let sx = p.random(-screenShake, screenShake);
      let sy = p.random(-screenShake, screenShake);
      p.translate(sx, sy);
      screenShake *= 0.9;
      if (screenShake < 0.5) screenShake = 0;
    }

    if (!isPaused && gameState === 'PLAYING') {
      if (isReviving) {
        updateRevivalSequence();
      } else {
        handleContinuousInput();
        
        playerGame.update();
        if (!isTrainingMode) {
          cpuGame.update();
          
          if (cpuGame.opponentIsDevil) {
            missileTimer++;
            let limit = 1800;
            if (cpuGame.revivalCount === 1) limit = 1200; // Phase 2: 20 seconds

            if (missileTimer >= limit) { 
              missileTimer = 0;
              if (cpuGame.revivalCount === 1) {
                launchLaser();
              } else {
                launchMissile();
              }
            }
            
            if (cpuGame.revivalCount >= 2 && p.random() < 0.02) {
              let ex = p.random(p.width);
              let ey = p.random(p.height);
              cpuGame.createBigExplosion(ex, ey);
            }
          }
        }
        
        // Update Attack Effects (軽量化: swap-pop方式)
        let writeIdx = 0;
        for (let i = 0; i < attackEffects.length; i++) {
          let effect = attackEffects[i];
          effect.update();
          if (!(effect.finished && effect.particles.length === 0)) {
            if (writeIdx !== i) attackEffects[writeIdx] = effect;
            writeIdx++;
          }
        }
        attackEffects.length = writeIdx;
      }
    }
    
    // Update Swap Button Position
    if (gameState === 'PLAYING' && !isPaused) {
       btnSwap.style.display = 'flex';
       if (dPad) dPad.style.display = 'block';
       if (btnItem) btnItem.style.display = 'flex';
       
       // Check for custom layout
       const customLayout = window.customButtonLayout;
       if (customLayout && customLayout.swap) {
         // Use custom layout for swap button
         btnSwap.style.left = `${customLayout.swap.left}px`;
         btnSwap.style.top = `${customLayout.swap.top}px`;
         btnSwap.style.width = `${customLayout.swap.width}px`;
         btnSwap.style.height = `${customLayout.swap.height}px`;
       } else {
         // Default position calculation
         let playerX = p.width * 0.25 - boardWidth / 2;
         let itemSize = cellSize * 1.4;
         let btnW = itemSize * 1.5;
         let btnH = cellSize * 1.4;
         let btnX = playerX + (itemSize - btnW) / 2;
         let btnY = boardY + boardHeight + 5 + itemSize + 5;
         
         btnSwap.style.left = `${btnX}px`;
         btnSwap.style.top = `${btnY}px`;
         btnSwap.style.width = `${btnW}px`;
         btnSwap.style.height = `${btnH}px`;
       }
    } else {
       btnSwap.style.display = 'none';
       if (dPad) dPad.style.display = 'none';
       if (btnItem) btnItem.style.display = 'none';
    }

    // Draw Player Board (Left)
    let playerX = p.width * 0.25 - boardWidth / 2;
    playerGame.draw(playerX, boardY, isPaused);

    // Draw CPU Board (Right)
    if (!isTrainingMode) {
      let cpuX = p.width * 0.75 - boardWidth / 2;
      cpuGame.draw(cpuX, boardY, isPaused);
    } else {
      drawTrainingHUD(p.width * 0.75, boardY + boardHeight / 2);
    }
    
    // Draw Attack Effects
    for (let i = attackEffects.length - 1; i >= 0; i--) {
      attackEffects[i].draw();
    }

    if (gameState === 'COUNTDOWN') {
      countdownTimer--;
      if (countdownTimer <= 0) {
        countdownValue--;
        countdownTimer = 60;
        if (countdownValue <= 0) {
          gameState = 'PLAYING';
          playerGame.spawnPiece(true);
          playerGame.startTimer();
          cpuGame.spawnPiece(true);
        }
      }
      
      if (gameState === 'COUNTDOWN') {
        p.push();
        // 背景を少し暗くしてサイバー空間を演出
        p.fill(0, 0, 0, 180);
        p.rect(0, 0, p.width, p.height);
        
        p.translate(p.width/2, p.height/2);
        
        // サイバーな円形装飾
        let t = p.frameCount;
        p.noFill();
        
        // 外側の回転リング (シアン)
        p.stroke(0, 255, 255, 200);
        p.strokeWeight(3);
        p.push();
        p.rotate(t * 0.05);
        let ringSize = Math.min(p.width, p.height) * 0.5;
        for(let i=0; i<3; i++) {
            p.rotate(p.TWO_PI / 3);
            p.arc(0, 0, ringSize, ringSize, 0, p.PI/2);
        }
        p.pop();
        
        // 内側の逆回転リング (マゼンタ)
        p.stroke(255, 0, 255, 200);
        p.strokeWeight(2);
        p.push();
        p.rotate(-t * 0.08);
        p.drawingContext.setLineDash([10, 15]); // 点線
        p.ellipse(0, 0, ringSize * 0.8, ringSize * 0.8);
        p.drawingContext.setLineDash([]); // リセット
        p.pop();
        
        // 中央の十字カーソル
        p.stroke(255, 255, 0, 150);
        p.strokeWeight(1);
        p.line(-20, 0, 20, 0);
        p.line(0, -20, 0, 20);
        
        // グリッチエフェクト付きテキスト
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(ringSize * 0.5);
        p.textStyle(p.BOLD);
        p.textFont('Orbitron');
        
        let displayText = countdownValue.toString();
        let xOff = 0;
        let yOff = 0;
        let glitch = p.random() < 0.15;
        
        if (glitch) {
            xOff = p.random(-5, 5);
            yOff = p.random(-5, 5);
            p.fill(255, 50, 50);
            if (p.random() < 0.3) displayText = String.fromCharCode(65 + p.floor(p.random(26)));
        } else {
            p.fill(0, 255, 255);
        }
        
        p.noStroke();
        p.text(displayText, xOff, yOff);
        
        // 補助テキスト
        p.textSize(18);
        p.fill(255, 255, 255, 200);
        p.textFont('Share Tech Mono');
        
        let subText = "";
        if (countdownValue === 3) {
          subText = "SYSTEM INITIALIZING...";
        } else if (countdownValue === 2) {
          let t = (60 - countdownTimer) / 60;
          let pct = Math.floor(t * 100);
          subText = `NEURAL SYNC: ${pct}%`;
          
          // Loading Bar
          p.push();
          p.stroke(0, 255, 255, 50);
          p.noFill();
          p.rectMode(p.CENTER);
          p.rect(0, ringSize * 0.75, 120, 6);
          p.noStroke();
          p.fill(0, 255, 255, 150);
          p.rectMode(p.CORNER);
          p.rect(-60, ringSize * 0.75 - 3, 120 * t, 6);
          p.pop();
        } else {
          subText = "TARGET LOCKED";
        }
        
        p.text(subText, 0, ringSize * 0.6);
        
        p.pop();
      }
    }

    if (!isPaused) {
      checkGameOver();
    }
  };

  // ==========================================
  // 般若モード演出ロジック (Devil Mode Logic)
  // ==========================================
  function updateRevivalSequence() {
    revivalTimer++;
    
    // 背景を暗くする演出 (Time Stop Effect)
    p.push();
    p.fill(0, 0, 0, 150);
    p.rect(0, 0, p.width, p.height);
    p.pop();
    
    // 1. 開始時演出 (Start)
    if (revivalTimer === 1) {
      let particles = [];
      for(let i=0; i<30; i++) {
        particles.push({
          angle: p.random(p.TWO_PI),
          dist: 20,
          speed: p.random(4, 12),
          char: p.random() < 0.5 ? '0' : '1'
        });
      }
      cpuGame.itemUseEffects.push({
        type: 'REVIVE',
        life: 1.0,
        maxLife: 250,
        frame: 0,
        particles: particles,
        color: '#FF0000',
        scale: 0.5,
        yOffset: 0
      });
      audio.playAttack();
    }
    
    // 2. 爆撃演出 (Bombing Phase) 60f - 210f (Slow and Heavy)
    if (revivalTimer >= 60 && revivalTimer < 210) {
      if (revivalTimer % 15 === 0) { // Every 15 frames (slower rhythm)
        let gx = p.floor(p.random(COLS));
        let gy = p.floor(p.random(HIDDEN_ROWS, ROWS));
        
        // Try to target existing blocks for better effect
        let attempts = 0;
        while (attempts < 5 && cpuGame.grid[gx][gy] === 0) {
            gx = p.floor(p.random(COLS));
            gy = p.floor(p.random(HIDDEN_ROWS, ROWS));
            attempts++;
        }

        let x = cpuGame.boardX + gx * cellSize + cellSize/2;
        let y = cpuGame.boardY + (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
        
        cpuGame.createBigExplosion(x, y);
        audio.playMissileHit(revivalTimer % 2);
        
        // Shake effect
        const container = document.getElementById('game-container');
        container.classList.remove('shake');
        void container.offsetWidth;
        container.classList.add('shake');
      }
    }
    
    // 3. 全消去実行 (Final Clear) 220f
    if (revivalTimer === 220) {
      cpuGame.clearField(true);
      cpuGame.garbageQueue = 0;
      cpuGame.currentPiece = null;
      cpuGame.spawnPiece();
      
      if (cpuGame.revivalCount === 2) {
        for(let x=0; x<COLS; x++) {
          for(let y=HIDDEN_ROWS; y<ROWS; y++) {
            if (playerGame.grid[x][y] !== 0) {
              if (playerGame.grid[x][y] <= 100) playerGame.grid[x][y] += 100;
              let px = playerGame.boardX + x * cellSize + cellSize/2;
              let py = playerGame.boardY + (y - HIDDEN_ROWS) * cellSize + cellSize/2;
              playerGame.createBigExplosion(px, py);
            }
          }
        }
        audio.playMissileHit(0);
      }
      
      // Grant Item P (Phase 2) or C (Phase 3) upon revival
      let itemToGrant = cpuGame.revivalCount === 2 ? 'C' : 'P';
      if (cpuGame.itemStock.length < 7) {
        cpuGame.itemStock.push(itemToGrant);
        cpuGame.triggerItemGetEffect(itemToGrant);
      }
      
      const container = document.getElementById('game-container');
      container.classList.remove('shake');
      void container.offsetWidth;
      container.classList.add('shake');
      
      audio.playDrop(true);
    }
    
    // 4. 終了 (Resume) 250f
    if (revivalTimer > 250) {
      isReviving = false;
      revivalTimer = 0;
      cpuGame.garbageQueue = 0;
    }
    
    // 攻撃エフェクトなども更新（時間停止中もエフェクトは動かす、軽量化: swap-pop方式）
    let writeIdx = 0;
    for (let i = 0; i < attackEffects.length; i++) {
        let effect = attackEffects[i];
        effect.update();
        if (!(effect.finished && effect.particles.length === 0)) {
          if (writeIdx !== i) attackEffects[writeIdx] = effect;
          writeIdx++;
        }
    }
    attackEffects.length = writeIdx;
  }

  function handleContinuousInput() {
    if (gameState !== 'PLAYING' || playerGame.state !== 'PLAYING') return;

    // Left
    if (inputState.left) {
      if (inputTimers.left === 0 || (inputTimers.left > DAS_DELAY && (inputTimers.left - DAS_DELAY) % DAS_SPEED === 0)) {
        playerGame.movePiece(-1, 0);
      }
      inputTimers.left++;
    } else {
      inputTimers.left = 0;
    }

    // Right
    if (inputState.right) {
      if (inputTimers.right === 0 || (inputTimers.right > DAS_DELAY && (inputTimers.right - DAS_DELAY) % DAS_SPEED === 0)) {
        playerGame.movePiece(1, 0);
      }
      inputTimers.right++;
    } else {
      inputTimers.right = 0;
    }
  }

  function launchMissile() {
    // Find potential targets in player grid
    let targets = [];
    for(let x=0; x<COLS; x++) {
      for(let y=HIDDEN_ROWS; y<ROWS; y++) { // Target visible area
        if (playerGame.grid[x][y] !== 0) {
           // 削除アニメーション中のブロックは対象から除外
           const isRemoving = playerGame.removingBlocks.some(b => b.x === x && b.y === y);
           if (!isRemoving) targets.push({x, y});
        }
      }
    }

    if (targets.length > 0) {
      // Shuffle targets to pick distinct ones
      p.shuffle(targets, true);

      // Determine number of missiles based on revival state
      let numMissiles;
      if (cpuGame.revivalCount === 0) {
        numMissiles = 2;
      } else if (cpuGame.revivalCount === 1) {
        numMissiles = p.floor(p.random(1, 11)); // 1 to 10
      } else {
        numMissiles = p.floor(p.random(5, 11)); // 5 to 10 (Phase 3)
      }

      let count = Math.min(targets.length, numMissiles);
      for (let i = 0; i < count; i++) {
        let target = targets[i];
        let startX = cpuGame.boardX + boardWidth / 2;
        let startY = cpuGame.boardY + boardHeight / 4;
        let endX = playerGame.boardX + target.x * cellSize + cellSize/2;
        let endY = playerGame.boardY + (target.y - HIDDEN_ROWS) * cellSize + cellSize/2;
        
        attackEffects.push(new ReticleEffect(p, endX, endY, () => {
          attackEffects.push(new MissileEffect(p, startX, startY, endX, endY, () => {
            playerGame.applyMissileDamage(target.x, target.y, cpuGame.revivalCount);
            audio.playMissileHit(i); // Missile impact sound
            // Futuristic screen flash effect (no shake)
            const container = document.getElementById('game-container');
            container.classList.add('quantum-impact');
            setTimeout(() => container.classList.remove('quantum-impact'), 150);
          }));
        }, i * 30));
      }
    }
  }

  function launchLaser() {
    // 3 Random Lasers (Unique columns)
    let cols = Array.from({length: COLS}, (_, i) => i);
    p.shuffle(cols, true);

    // 2 Penalty (false), 1 Clear (true)
    let types = [false, false, true];
    p.shuffle(types, true);

    for (let i = 0; i < 3; i++) {
      let col = cols[i];
      let isHelpful = types[i];
      let x = playerGame.boardX + col * cellSize + cellSize/2;
      let y = playerGame.boardY;
      let h = boardHeight;
      
      attackEffects.push(new LaserEffect(p, x, y, h, () => {
        playerGame.applyLaserDamage(col, isHelpful);
        audio.playMissileHit(i % 2);
        // Futuristic screen flash effect (no shake)
        const container = document.getElementById('game-container');
        container.classList.add('quantum-impact');
        setTimeout(() => container.classList.remove('quantum-impact'), 150);
      }, i * 10));
    }
  }

  // ==========================================
  // ゲームオーバー判定 (Game Over Check)
  // ==========================================
  function checkGameOver() {
    if (gameState === 'PLAYING' && (playerGame.state === 'GAMEOVER' || (!isTrainingMode && cpuGame.state === 'GAMEOVER'))) {
      let title = document.getElementById('game-result-title');
      
      if (playerGame.state === 'GAMEOVER') {
        title.innerText = "LINK\nTERMINATED";
        title.style.color = "#FF4444";
        // Play defeat sound
        if (typeof FuturisticSFX !== 'undefined' && FuturisticSFX.ctx) {
          FuturisticSFX.playDefeatSound();
        }
      } else {
        title.innerText = "HOSTILE AI\nNEUTRALIZED";
        title.style.color = "#00FFFF";
        // Play victory sound
        if (typeof FuturisticSFX !== 'undefined' && FuturisticSFX.ctx) {
          FuturisticSFX.playVictorySound();
        }
      }
      
      // Update Stats
      document.getElementById('result-max-combo').innerText = playerGame.maxCombo;
      document.getElementById('result-blocks').innerText = playerGame.totalBlocksCleared;
      
      // Reset Animations
      const modal = document.getElementById('game-over-modal');
      const fadeItems = modal.querySelectorAll('.fade-item');
      fadeItems.forEach(el => el.classList.remove('visible'));
      
      const rankEl = document.getElementById('result-rank');
      rankEl.classList.remove('visible');
      rankEl.innerText = '-';
      
      ['speed', 'tech', 'strategy', 'aggression'].forEach(k => {
        document.getElementById(`bar-${k}`).style.width = '0%';
      });
      document.getElementById('ai-comment-text').innerText = '';
      
      resultAnimationTimeouts.forEach(clearTimeout);
      resultAnimationTimeouts = [];
      isResultAnimationSkipped = false;
      gameOverTimestamp = Date.now();

      document.getElementById('game-over-modal').style.display = 'flex';
      
      // Sequence Animation
      resultAnimationTimeouts.push(setTimeout(() => document.getElementById('game-result-title').classList.add('visible'), 500));
      resultAnimationTimeouts.push(setTimeout(() => document.querySelector('.analysis-container').classList.add('visible'), 1000));
      resultAnimationTimeouts.push(setTimeout(() => analyzePlayStyle(playerGame), 1500)); // Start analysis visualization

      // Stop game state
      playerGame.state = 'GAMEOVER';
      cpuGame.state = 'GAMEOVER';
      gameState = 'GAMEOVER';
    }
  }

  // ==========================================
  // AI分析ロジック (AI Analysis Logic)
  // ==========================================
  function analyzePlayStyle(game) {
    const stats = game.stats;
    const elapsedSec = (Date.now() - game.startTime) / 1000;
    
    // 1. Calculate Metrics (0-100)
    
    // Speed: Average time per drop. Faster is better.
    // Target: 1.0s per drop = 100, 3.0s = 0
    const avgThinkTime = stats.drops > 0 ? (stats.totalThinkTime / stats.drops) / 1000 : 3.0;
    let speedScore = p.map(avgThinkTime, 3.0, 0.8, 20, 100, true);
    
    // Technique: Combo efficiency and rotation usage
    // Max Combo 5+ = 100
    let comboScore = p.map(game.maxCombo, 0, 8, 10, 100, true);
    // Efficiency: Moves per drop. Too many moves = bad efficiency.
    const movesPerDrop = stats.drops > 0 ? (stats.moves + stats.rotates) / stats.drops : 0;
    let efficiencyScore = p.map(movesPerDrop, 10, 2, 20, 100, true);
    let techScore = (comboScore * 0.7) + (efficiencyScore * 0.3);
    
    // Strategy: Item usage and survival
    // Survival time bonus (up to 3 mins)
    let survivalScore = p.map(elapsedSec, 0, 180, 20, 100, true);
    // Item usage bonus
    let itemScore = Math.min(stats.itemsUsed * 15, 100);
    let strategyScore = (survivalScore * 0.6) + (itemScore * 0.4);
    
    // Aggression: Total blocks cleared and attack gauge
    // Cleared blocks per minute
    const bpm = elapsedSec > 0 ? (game.totalBlocksCleared / elapsedSec) * 60 : 0;
    let aggressionScore = p.map(bpm, 10, 60, 20, 100, true);

    // 2. Determine Rank
    const totalScore = (speedScore + techScore + strategyScore + aggressionScore) / 4;
    let rank = 'D';
    let rankColor = '#888';
    if (totalScore >= 90) { rank = 'S'; rankColor = '#FFD700'; }
    else if (totalScore >= 80) { rank = 'A'; rankColor = '#FF4500'; }
    else if (totalScore >= 65) { rank = 'B'; rankColor = '#00FFFF'; }
    else if (totalScore >= 50) { rank = 'C'; rankColor = '#4169E1'; }

    // 3. Generate Comment
    const comments = [];
    if (speedScore > 85) comments.push("HIGH SPEED PROCESSING DETECTED.");
    else if (speedScore < 40) comments.push("PROCESSING SPEED: SUB-OPTIMAL.");
    
    if (techScore > 85) comments.push("EXCEPTIONAL PATTERN RECOGNITION.");
    else if (game.maxCombo < 3) comments.push("SUGGESTION: BUILD LARGER CHAINS.");
    
    if (aggressionScore > 80) comments.push("OFFENSIVE CAPABILITIES: MAXIMIZED.");
    
    if (rank === 'S') comments.push("EVALUATION: GOD-LIKE ENTITY.");
    else if (rank === 'A') comments.push("EVALUATION: HIGHLY EVOLVED INTELLECT.");
    else if (rank === 'D') comments.push("EVALUATION: NEED MORE TRAINING DATA.");
    
    let finalComment = comments.length > 0 ? comments.join(" ") : "ANALYSIS COMPLETE. STANDARD PERFORMANCE.";

    // 4. Update UI
    const rankEl = document.getElementById('result-rank');
    rankEl.innerText = rank;
    rankEl.style.color = rankColor;
    rankEl.style.textShadow = `0 0 20px ${rankColor}`;
    rankEl.classList.add('visible');
    audio.playRank();
    
    if (isResultAnimationSkipped) {
      audio.stopGauge();
      document.getElementById('bar-speed').style.width = `${speedScore}%`;
      document.getElementById('bar-tech').style.width = `${techScore}%`;
      document.getElementById('bar-strategy').style.width = `${strategyScore}%`;
      document.getElementById('bar-aggression').style.width = `${aggressionScore}%`;
      
      document.querySelector('.ai-comment-box').classList.add('visible');
      document.getElementById('ai-comment-text').innerText = finalComment;
      
      document.querySelector('.stats-container').classList.add('visible');
      document.getElementById('result-actions').classList.add('visible');
      
      const modal = document.getElementById('game-over-modal');
      modal.querySelectorAll('.fade-item').forEach(el => el.classList.add('visible'));
      return;
    }

    // Animate Bars
    resultAnimationTimeouts.push(setTimeout(() => {
      audio.playGauge();
      document.getElementById('bar-speed').style.width = `${speedScore}%`;
      document.getElementById('bar-tech').style.width = `${techScore}%`;
      document.getElementById('bar-strategy').style.width = `${strategyScore}%`;
      document.getElementById('bar-aggression').style.width = `${aggressionScore}%`;
    }, 600));

    // Show Comment Box
    resultAnimationTimeouts.push(setTimeout(() => {
      document.querySelector('.ai-comment-box').classList.add('visible');
    }, 2000));

    // Typewriter Effect for Comment
    resultAnimationTimeouts.push(setTimeout(() => {
        const commentEl = document.getElementById('ai-comment-text');
        commentEl.innerText = "";
        let i = 0;
        const typeWriter = () => {
          if (isResultAnimationSkipped) {
             commentEl.innerText = finalComment;
             return;
          }
          if (i < finalComment.length) {
            commentEl.innerText += finalComment.charAt(i);
            if (i % 2 === 0) audio.playTyping();
            i++;
            resultAnimationTimeouts.push(setTimeout(typeWriter, 30));
          }
        };
        typeWriter();
    }, 2500));

    // Show Stats & Button
    resultAnimationTimeouts.push(setTimeout(() => document.querySelector('.stats-container').classList.add('visible'), 4500));
    resultAnimationTimeouts.push(setTimeout(() => document.getElementById('result-actions').classList.add('visible'), 5500));
  }

  class FallingBlock {
    constructor(p) {
      this.p = p;
      this.reset(true);
    }

    reset(randomY = false) {
      this.x = this.p.random(this.p.width);
      this.y = randomY ? this.p.random(this.p.height) : -100;
      this.z = this.p.random(0.5, 1.5);
      this.speed = this.p.random(1, 3) * this.z;
      this.rot = this.p.random(this.p.TWO_PI);
      this.rotSpeed = this.p.random(-0.05, 0.05);
      
      let r = this.p.random();
      if (r < 0.6) {
        this.type = this.p.floor(this.p.random(1, BLOCK_TYPES + 1));
        this.isPenalty = false;
      } else if (r < 0.85) {
        this.type = this.p.floor(this.p.random(1, BLOCK_TYPES + 1));
        this.isPenalty = true;
      } else {
        const items = [7, 8, 9, 10];
        this.type = this.p.random(items);
        this.isPenalty = false;
      }
    }

    update() {
      this.y += this.speed;
      this.rot += this.rotSpeed;
      if (this.y > this.p.height + 100) this.reset();
    }

    draw() {
      this.p.push();
      this.p.translate(this.x, this.y);
      this.p.rotate(this.rot);
      this.p.scale(this.z);
      let size = 40;
      
      this.p.noStroke();
      this.p.fill(255, 255, 255, 30);
      this.p.ellipse(0, 0, size * 1.5, size * 1.5);

      let imgIndex = this.type;
      if (gemImages[imgIndex]) {
        this.p.image(gemImages[imgIndex], 0, 0, size, size);
      }

      if (this.isPenalty) {
        // Simplified Penalty Design for Background
        this.p.rectMode(this.p.CENTER);
        this.p.fill(60, 65, 70, 80);
        this.p.stroke(120, 125, 130, 150);
        this.p.strokeWeight(2);
        this.p.rect(0, 0, size, size, 5);

        this.p.stroke(245, 222, 179, 200);
        this.p.strokeWeight(size * 0.15);
        this.p.strokeCap(this.p.ROUND);
        let xSize = size * 0.35;
        this.p.line(-xSize, -xSize, xSize, xSize);
        this.p.line(xSize, -xSize, -xSize, xSize);
        this.p.stroke(255, 255, 255, 200);
        this.p.strokeWeight(size * 0.05);
        this.p.line(-xSize, -xSize, xSize, xSize);
        this.p.line(xSize, -xSize, -xSize, xSize);
      }
      this.p.pop();
    }
  }

  // ==========================================
  // ゲームロジッククラス (HexaGame Class)
  // ==========================================
  class HexaGame {
    constructor(p, isCpu, onCombo) {
      this.p = p;
      this.isCpu = isCpu;
      this.onCombo = onCombo;
      this.aiSettings = { speed: 20, errorChance: 0.05, chainWeight: 20.0, lookaheadDepth: 2, setupWeight: 1.5, steps: 1, targetCombo: 3 }; // Default Normal
      this.opponent = null;
      this.reset();
    }

    // --- 初期化・リセット ---
    reset(spawn = true) {
      this.grid = Array(COLS).fill().map(() => Array(ROWS).fill(0));
      this.state = 'PLAYING';
      this.dropTimer = 0;
      this.dropInterval = DROP_INTERVAL_INIT;
      this.currentPiece = null;
      this.particles = [];
      this.fireworks = [];
      this.removingBlocks = [];
      this.animationTimer = 0;
      this.comboCount = 0;
      this.comboScale = 1;
      this.lastComboLines = 0;
      this.pendingGarbage = 0;
      this.garbageQueue = 0;
      this.bounceState = Array(COLS).fill().map(() => Array(ROWS).fill().map(() => ({ y: 0, vy: 0 })));
      this.itemStock = ['P'];
      this.nextSpawnIsItem = false;
      this.itemGetEffects = [];
      this.itemUseEffects = [];
      this.opponentIsDevil = false;
      this.attackGauge = 0;
      this.hasRevived = false;
      this.revivalCount = 0;
      this.maxCombo = 0;
      this.totalBlocksCleared = 0;
      this.startTime = 0;
      this.matchBuffer = new Int8Array(COLS * ROWS);
      this.comboGraceTimer = 0;
      this.collapseParticles = [];
      this.isTraining = false;
      this.comboHints = [];
      this.createHints = [];
      this.clearPathHints = null; // 不要ブロック消去経路
      this.gameOverGraceTimer = 0;
      
      // Statistics for Analysis
      this.stats = {
        moves: 0,
        rotates: 0,
        drops: 0,
        totalThinkTime: 0,
        itemsUsed: 0
      };
      this.pieceStartTime = 0;
      
      this.lockDelayTimer = 0;
      this.LOCK_DELAY_LIMIT = 45;
      this.lockResetCount = 0; // 高速タップ対策：リセット回数制限
      this.LOCK_RESET_LIMIT = 8; // 最大リセット回数

      this.nextPieceBlocks = this.generateRandomBlocks();
      // AI vars
      this.aiTargetX = null;
      this.aiTargetRot = 0;
      this.aiMoveTimer = 0;
      this.aiGiveUpTimer = 0;
      this.lastItemUseFrame = -999;
      this.lastUsedItemType = null;
      this.nextPieceAlpha = 255;

      if (spawn) {
        this.spawnPiece(true);
      } else {
        this.currentPiece = null;
      }
    }

    startTimer() {
      this.startTime = Date.now();
    }

    triggerGameOverGrace() {
      this.state = 'GAMEOVER_GRACE';
      this.gameOverGraceTimer = 60;
    }

    // --- AI設定 ---
    setCpuStrength(strength) {
      if (strength > 100) {
        // Devil Mode (Hannya) - 平均8コンボを狙う
        this.aiSettings = { speed: 0, errorChance: 0.0, chainWeight: 200.0, lookaheadDepth: 8, setupWeight: 8.0, steps: 3, targetCombo: 8 };
        return;
      }
      // strength: 0 to 100
      const t = strength / 100;
      // Speed: 30 (Slow) -> 0 (Instant)
      const speed = Math.floor(this.p.lerp(30, 0, t));
      
      // Steps: 1 -> 2 (at high levels)
      const steps = t > 0.8 ? 2 : 1;
      
      // Error: 0.8 -> 0.0
      const errorChance = t > 0.9 ? 0 : 0.8 * Math.pow(1 - t, 2);
      
      // Chain: 10.0 -> 100.0
      const chainWeight = this.p.lerp(10.0, 100.0, t);
      
      // Lookahead Depth: 2 (Basic) -> 6 (Advanced) - 高レベルでより深い先読み
      const lookaheadDepth = Math.floor(this.p.lerp(2, 6, t));

      // Setup Weight: 1.0 -> 5.0 - 高レベルでセットアップ重視
      const setupWeight = this.p.lerp(1.0, 5.0, t);

      // AIレベルに応じた目標コンボ数を設定（より積極的に高コンボを狙う）
      // AIレベル0〜20：3コンボ中心
      // AIレベル21〜40：4コンボ中心
      // AIレベル41〜60：5コンボ中心
      // AIレベル61〜80：6コンボ中心
      // AIレベル81〜100：7コンボ中心
      // AIレベル無限(101+)：8コンボ中心（setCpuStrength先頭で処理）
      // ※盤面状況により目標達成困難な場合、狙える範囲での最大コンボに動的調整
      let targetCombo = 3;
      if (strength >= 81) {
        targetCombo = 7;
      } else if (strength >= 61) {
        targetCombo = 6;
      } else if (strength >= 41) {
        targetCombo = 5;
      } else if (strength >= 21) {
        targetCombo = 4;
      } else {
        targetCombo = 3;
      }

      this.aiSettings = { speed, errorChance, chainWeight, lookaheadDepth, setupWeight, steps, targetCombo };
    }

    // --- ブロック生成 ---
    generateRandomBlocks() {
      return [this.p.floor(this.p.random(1, BLOCK_TYPES + 1)), 
              this.p.floor(this.p.random(1, BLOCK_TYPES + 1)), 
              this.p.floor(this.p.random(1, BLOCK_TYPES + 1))];
    }

    spawnPiece(isInitial = false) {
      this.lastComboLines = 0;
      this.processGarbage();
      this.lockResetCount = 0; // 新しいピースでリセット回数をリセット

      let blocks = this.nextPieceBlocks;
      if (this.nextSpawnIsItem) {
        blocks = [0, 0, 7];
        this.nextSpawnIsItem = false;
      }

      if (!isInitial) {
        this.triggerNextTransition();
      }
      this.currentPiece = {
        x: 4,
        y: HIDDEN_ROWS - 2,
        visualX: 4,
        visualY: HIDDEN_ROWS - 2,
        blocks: blocks
      };
      this.nextPieceBlocks = this.generateRandomBlocks();
      this.pieceStartTime = Date.now();
      
      const isPBlock = this.currentPiece.blocks.includes(7);

      // If P-Block and spawn position is invalid (blocked), try to move up
      if (isPBlock && !this.isValid(this.currentPiece.x, this.currentPiece.y)) {
         if (this.isValid(this.currentPiece.x, this.currentPiece.y - 1)) {
             this.currentPiece.y -= 1;
         }
      }

      if (this.grid[4][HIDDEN_ROWS] !== 0) {
        let matches = this.findMatches();
        if (matches.length > 0) {
          this.state = 'ANIMATING';
          this.removingBlocks = matches;
          this.animationTimer = 0;
          this.comboScale = 2.0;
          this.comboGraceTimer = 0;
          this.currentPiece = null;
          return;
        }

        if (!isPBlock) {
          this.triggerGameOverGrace();
          return;
        }
      }

      // AI Decision
      if (this.isCpu) {
        this.aiTargetX = null; // Will be calculated in updateAI
        this.aiGiveUpTimer = 0;
      } else if (this.isTraining) {
        this.updateHints();
      }
    }

    updateHints() {
      this.comboHints = [];
      this.createHints = [];
      this.clearPathHints = null; // 不要ブロック消去経路
      
      if (!this.isTraining || !this.currentPiece || aiAssistLevel === 0) return;
      if (this.currentPiece.blocks.includes(7)) return;

      let bestChain = 0;
      let bestMoves = [];
      const originalBlocks = this.currentPiece.blocks;

      // === Phase 1: 現在のピースで即座にコンボが組めるか探索 ===
      for (let r = 0; r < 3; r++) {
        let blocks = [...originalBlocks];
        for(let i=0; i<r; i++) blocks.unshift(blocks.pop());

        for (let x = 0; x < COLS; x++) {
          let landY = this.findLandingY(this.grid, x);
          if (landY < 0) continue;

          let chain = this.getChainLength(x, landY, blocks);
          if (chain > 0) {
            if (chain > bestChain) {
              bestChain = chain;
              // 最もポテンシャルの高い1つだけを保存
              bestMoves = [{x, y: landY, blocks: [...blocks], chain, stepsToCombo: 1}];
            }
            // 同じコンボ数でも最初の1つのみを使用（複数候補は表示しない）
          }
        }
      }

      if (bestChain >= aiAssistLevel) {
        // 最もポテンシャルの高い1つだけを表示
        // 詳細な連鎖ステップ情報を取得（視覚化用）
        const hint = bestMoves[0];
        let simGrid = this.copyGrid(this.grid);
        for (let i = 0; i < 3; i++) {
          if (hint.y + i >= 0 && hint.y + i < ROWS) {
            simGrid[hint.x][hint.y + i] = hint.blocks[i];
          }
        }
        const detailedResult = this.simulateChainDetailed(simGrid, true);
        hint.chainSteps = detailedResult.chainSteps;
        hint.triggerGrid = simGrid;
        
        this.comboHints = [hint];
        return;
      }

      // === Phase 2: 不要ブロック消去を含めた最適経路探索 ===
      const optimalPath = this.findOptimalComboPath(aiAssistLevel);
      
      if (optimalPath && optimalPath.finalChain >= aiAssistLevel) {
        // 最速で目標コンボに到達できる経路が見つかった
        if (optimalPath.stepsToCombo === 1) {
          // 1手で達成
          this.comboHints = [{
            x: optimalPath.moves[0].x,
            y: optimalPath.moves[0].y,
            blocks: optimalPath.moves[0].blocks,
            chain: optimalPath.finalChain,
            stepsToCombo: 1,
            chainSteps: optimalPath.chainSteps,
            triggerGrid: optimalPath.triggerGrid
          }];
        } else {
          // 複数手必要（最初に消去が必要）
          this.clearPathHints = optimalPath;
          // 現在の手を表示（消去用のヒント）
          const currentMove = optimalPath.moves[0];
          this.createHints = [{
            x: currentMove.x,
            y: currentMove.y,
            blocks: currentMove.blocks,
            potential: optimalPath.finalChain,
            stepsToCombo: optimalPath.stepsToCombo,
            isClearingMove: currentMove.clearsBlocks,
            clearCount: currentMove.clearCount || 0
          }];
        }
      } else {
        // Phase 3: 最適経路が見つからない場合、従来のセットアップヒントを計算
        this.calculateCreateHintsAdvanced();
      }
    }

    // 着地Y座標を取得するヘルパー
    findLandingY(grid, x) {
      for (let y = 0; y < ROWS; y++) {
        if (grid[x][y] !== 0) {
          return y - 3;
        }
        if (y === ROWS - 1) return ROWS - 3;
      }
      return -1;
    }

    // グリッドをコピーするヘルパー
    copyGrid(grid) {
      let copy = [];
      for (let cx = 0; cx < COLS; cx++) {
        copy[cx] = grid[cx].slice();
      }
      return copy;
    }

    // === 強化版: 最適コンボ経路探索（優先度付き探索）===
    // 改善: フィールド高さペナルティ、適度なマッチ消去戦略
    findOptimalComboPath(targetCombo) {
      const originalBlocks = this.currentPiece.blocks;
      const nextBlocks = this.nextPieceBlocks || null;
      
      let bestPath = null;
      let bestScore = -Infinity;
      
      // 探索パラメータ（チューニング済み）
      const MAX_DEPTH = 3;
      const MAX_ITERATIONS = 800;
      let iterations = 0;
      
      // 現在のフィールド高さを取得（危険度判定用）
      const currentFieldHeight = this.getFieldHeight(this.grid);
      const isDangerZone = currentFieldHeight > 8; // 8段以上で危険
      
      // 優先度付きキューで探索（高ポテンシャルを優先）
      const queue = [];
      
      // 初期状態：現在のグリッド
      const initialState = {
        grid: this.copyGrid(this.grid),
        moves: [],
        depth: 0,
        currentBlocks: originalBlocks,
        nextBlocks: nextBlocks,
        priority: 0,
        accumulatedHeight: 0 // 積み上げ高さトラッキング
      };
      
      queue.push(initialState);
      
      // 探索済み状態の簡易ハッシュ（重複防止）
      const visited = new Set();
      
      // グリッドの最大高さを取得するヘルパー関数
      const getGridHeight = (grid) => {
        let maxHeight = 0;
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (grid[x][y] !== 0) {
              const height = ROWS - y;
              if (height > maxHeight) maxHeight = height;
              break;
            }
          }
        }
        return maxHeight;
      };
      
      // グリッドの連鎖ポテンシャルを評価する関数（改良版）
      const evaluateChainPotential = (grid) => {
        let potential = 0;
        // 各色のブロック数と隣接状況をカウント
        const colorCounts = new Array(7).fill(0);
        const adjacencyBonus = new Array(7).fill(0);
        
        for (let x = 0; x < COLS; x++) {
          for (let y = ROWS - 1; y >= ROWS - 10 && y >= 0; y--) {
            const c = grid[x][y];
            if (c > 0 && c <= 6) {
              colorCounts[c]++;
              // 隣接する同色をチェック
              const neighbors = [
                [x-1, y], [x+1, y], [x, y-1], [x, y+1],
                [x-1, y-1], [x+1, y-1], [x-1, y+1], [x+1, y+1]
              ];
              for (const [nx, ny] of neighbors) {
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                  if (grid[nx][ny] === c) adjacencyBonus[c] += 3;
                }
              }
            }
          }
        }
        
        // 2個以上同色があれば連鎖の可能性
        for (let c = 1; c <= 6; c++) {
          if (colorCounts[c] >= 2) {
            potential += colorCounts[c] * 5 + adjacencyBonus[c];
            // 3個以上揃っていれば消去可能性が高い
            if (colorCounts[c] >= 3) potential += 20;
          }
        }
        
        return potential;
      };
      
      // 目標コンボに効果的な消去かどうかを評価
      const evaluateClearEfficiency = (grid, chain, clearedCount, targetCombo) => {
        let efficiency = 0;
        
        // 消去後のポテンシャルを計算
        const postClearPotential = evaluateChainPotential(grid);
        
        // 大量消去は良い（フィールドを整理）
        efficiency += clearedCount * 15;
        
        // 消去後もポテンシャルが残っていれば良い
        efficiency += postClearPotential * 0.5;
        
        // 目標の半分以上のコンボなら価値あり（セットアップに使える）
        if (chain >= Math.ceil(targetCombo / 2)) {
          efficiency += chain * 50;
        }
        
        return efficiency;
      };
      
      while (queue.length > 0 && iterations < MAX_ITERATIONS) {
        iterations++;
        
        // 優先度でソート（高い順）- より頻繁にソート
        if (queue.length > 1 && iterations % 5 === 0) {
          queue.sort((a, b) => b.priority - a.priority);
        }
        
        const state = queue.shift();
        
        if (state.depth >= MAX_DEPTH) continue;
        
        const blocks = state.currentBlocks;
        if (!blocks || blocks.includes(7)) continue;
        
        // フィールド高さチェック（危険な状態では消去優先）
        const stateHeight = getGridHeight(state.grid);
        const isStateDangerous = stateHeight > 10;
        
        // 全回転・全列を探索
        for (let r = 0; r < 3; r++) {
          let rotatedBlocks = [...blocks];
          for (let i = 0; i < r; i++) rotatedBlocks.unshift(rotatedBlocks.pop());
          
          for (let x = 0; x < COLS; x++) {
            let landY = this.findLandingY(state.grid, x);
            if (landY < 0) continue;
            
            // シミュレーション用グリッドを作成
            let simGrid = this.copyGrid(state.grid);
            for (let i = 0; i < 3; i++) {
              if (landY + i >= 0 && landY + i < ROWS) {
                simGrid[x][landY + i] = rotatedBlocks[i];
              }
            }
            
            // 配置後の高さをチェック
            const newHeight = getGridHeight(simGrid);
            
            // 非常に高くなる配置は避ける（高コンボ目標でも）
            if (newHeight > 12 && state.depth > 0) continue;
            
            // マッチを検出してシミュレーション
            let chainResult = this.simulateChainDetailed(simGrid);
            
            // この手の情報を記録
            const move = {
              x: x,
              y: landY,
              blocks: [...rotatedBlocks],
              clearsBlocks: chainResult.chain > 0,
              clearCount: chainResult.clearedCount,
              resultingChain: chainResult.chain
            };
            
            const newMoves = [...state.moves, move];
            const stepsToCombo = newMoves.length;
            
            // 目標コンボ達成をチェック
            if (chainResult.chain >= targetCombo) {
              // スコア計算の改善：少ない手数で高コンボを最優先
              const chainBonus = chainResult.chain * 2000; // コンボ数の重み大幅増加
              const stepPenalty = stepsToCombo * 300; // 手数ペナルティ
              const efficiencyBonus = chainResult.clearedCount * 15;
              // 高さペナルティ（積み上げすぎを避ける）
              const heightPenalty = Math.max(0, state.accumulatedHeight - 6) * 100;
              const score = chainBonus - stepPenalty + efficiencyBonus - heightPenalty;
              
              if (score > bestScore) {
                bestScore = score;
                
                // 詳細な連鎖ステップ情報を取得（視覚化用）
                const detailedResult = this.simulateChainDetailed(simGrid, true);
                
                bestPath = {
                  moves: newMoves,
                  finalChain: chainResult.chain,
                  stepsToCombo: stepsToCombo,
                  totalCleared: chainResult.clearedCount,
                  chainSteps: detailedResult.chainSteps, // 連鎖ステップ情報を追加
                  triggerGrid: this.copyGrid(simGrid) // トリガー時のグリッド状態
                };
                
                // 1手で目標達成なら即座に返す
                if (stepsToCombo === 1 && chainResult.chain >= targetCombo) {
                  return bestPath;
                }
              }
            }
            
            // 探索継続: マッチが発生した場合、次の状態をキューに追加
            // 改善: 効率的な消去（目標に近づく消去）を優先
            if (chainResult.chain > 0 && chainResult.chain < targetCombo && state.depth + 1 < MAX_DEPTH) {
              const nextPieceForQueue = state.nextBlocks;
              if (nextPieceForQueue && !nextPieceForQueue.includes(7)) {
                // 消去効率を評価
                const clearEfficiency = evaluateClearEfficiency(
                  chainResult.resultGrid, 
                  chainResult.chain, 
                  chainResult.clearedCount,
                  targetCombo
                );
                
                // 小さすぎるコンボ（1-2C）で消去数も少ない場合はスキップ
                // ただし危険な状態では消去を優先
                if (!isStateDangerous && chainResult.chain <= 2 && chainResult.clearedCount < 6) {
                  continue;
                }
                
                const stateHash = this.hashGrid(chainResult.resultGrid) + '_' + (state.depth + 1);
                if (!visited.has(stateHash)) {
                  visited.add(stateHash);
                  
                  // 消去後の高さ
                  const postClearHeight = getGridHeight(chainResult.resultGrid);
                  
                  // 優先度計算：消去効率＋連鎖ポテンシャル＋高さボーナス
                  const clearPriority = clearEfficiency;
                  const potentialPriority = evaluateChainPotential(chainResult.resultGrid);
                  const chainPriority = chainResult.chain * 150;
                  // 消去で高さが減った場合はボーナス
                  const heightReductionBonus = Math.max(0, stateHeight - postClearHeight) * 50;
                  
                  queue.push({
                    grid: chainResult.resultGrid,
                    moves: newMoves,
                    depth: state.depth + 1,
                    currentBlocks: nextPieceForQueue,
                    nextBlocks: null,
                    clearedInPath: (state.clearedInPath || 0) + chainResult.clearedCount,
                    accumulatedHeight: postClearHeight,
                    priority: clearPriority + potentialPriority + chainPriority + heightReductionBonus
                  });
                }
              }
            }
            
            // 消去なしでも、ポテンシャルが高く、高さが危険でなければ探索継続
            if (chainResult.chain === 0 && state.depth + 1 < MAX_DEPTH && newHeight <= 11) {
              const nextPieceForQueue = state.nextBlocks;
              if (nextPieceForQueue && !nextPieceForQueue.includes(7)) {
                // 次の手で目標達成可能かチェック
                const potential = this.checkNextMovePotential(simGrid, nextPieceForQueue, targetCombo);
                if (potential >= targetCombo) {
                  const stateHash = this.hashGrid(simGrid) + '_' + (state.depth + 1);
                  if (!visited.has(stateHash)) {
                    visited.add(stateHash);
                    // 高ポテンシャル状態を優先（高さペナルティ付き）
                    const potentialPriority = evaluateChainPotential(simGrid) + potential * 60;
                    const heightPenalty = Math.max(0, newHeight - 8) * 30;
                    
                    queue.push({
                      grid: simGrid,
                      moves: newMoves,
                      depth: state.depth + 1,
                      currentBlocks: nextPieceForQueue,
                      nextBlocks: null,
                      accumulatedHeight: newHeight,
                      priority: potentialPriority - heightPenalty
                    });
                  }
                }
              }
            }
          }
        }
      }
      
      return bestPath;
    }
    
    // フィールドの最大高さを取得するヘルパー
    getFieldHeight(grid) {
      let maxHeight = 0;
      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          if (grid[x][y] !== 0) {
            const height = ROWS - y;
            if (height > maxHeight) maxHeight = height;
            break;
          }
        }
      }
      return maxHeight;
    }

    // グリッドの簡易ハッシュ（重複検出用）
    hashGrid(grid) {
      let hash = '';
      for (let x = 0; x < COLS; x++) {
        for (let y = ROWS - 5; y < ROWS; y++) { // 下5行のみをハッシュ
          hash += grid[x][y].toString(16);
        }
      }
      return hash;
    }

    // 詳細な連鎖シミュレーション（消去ブロック数も返す）
    simulateChainDetailed(simGrid, captureChainSteps = false) {
      let chain = 0;
      let clearedCount = 0;
      let active = true;
      let loopCount = 0;
      
      // グリッドのコピーを作成
      let workGrid = this.copyGrid(simGrid);
      
      // 各連鎖ステップの情報を保存（視覚化用）
      let chainSteps = [];
      
      while (active && loopCount < 10) {
        loopCount++;
        let matches = this.findMatches(workGrid);
        if (matches.length > 0) {
          chain++;
          clearedCount += matches.length;
          
          // 連鎖ステップ情報を保存
          if (captureChainSteps) {
            // 消去されるブロックの情報（色・位置）を保存
            let stepInfo = {
              chainNumber: chain,
              clearedBlocks: matches.map(m => ({
                x: m.x,
                y: m.y,
                color: workGrid[m.x][m.y]
              })),
              gridBefore: this.copyGrid(workGrid)
            };
            chainSteps.push(stepInfo);
          }
          
          matches.forEach(m => workGrid[m.x][m.y] = 0);
          // 重力適用
          for (let cx = 0; cx < COLS; cx++) {
            let writeY = ROWS - 1;
            for (let cy = ROWS - 1; cy >= 0; cy--) {
              if (workGrid[cx][cy] !== 0) {
                workGrid[cx][writeY] = workGrid[cx][cy];
                if (writeY !== cy) workGrid[cx][cy] = 0;
                writeY--;
              }
            }
          }
          
          // 連鎖後のグリッド状態も保存
          if (captureChainSteps && chainSteps.length > 0) {
            chainSteps[chainSteps.length - 1].gridAfter = this.copyGrid(workGrid);
          }
        } else {
          active = false;
        }
      }
      
      return {
        chain: chain,
        clearedCount: clearedCount,
        resultGrid: workGrid,
        chainSteps: chainSteps
      };
    }

    // 次の手で目標コンボ達成可能かチェック
    checkNextMovePotential(grid, nextBlocks, targetCombo) {
      let maxChain = 0;
      
      for (let r = 0; r < 3; r++) {
        let blocks = [...nextBlocks];
        for (let i = 0; i < r; i++) blocks.unshift(blocks.pop());
        
        for (let x = 0; x < COLS; x++) {
          let landY = this.findLandingY(grid, x);
          if (landY < 0) continue;
          
          let simGrid = this.copyGrid(grid);
          for (let i = 0; i < 3; i++) {
            if (landY + i >= 0 && landY + i < ROWS) {
              simGrid[x][landY + i] = blocks[i];
            }
          }
          
          let result = this.simulateChainDetailed(simGrid);
          if (result.chain > maxChain) {
            maxChain = result.chain;
            if (maxChain >= targetCombo) return maxChain;
          }
        }
      }
      
      return maxChain;
    }

    // === 改良版セットアップヒント計算 ===
    calculateCreateHintsAdvanced() {
      if (!this.isTraining || !this.currentPiece) return;
      if (this.currentPiece.blocks.includes(7)) return;

      let candidates = [];
      let bestScore = -Infinity;
      const originalBlocks = this.currentPiece.blocks;
      const nextBlocks = this.nextPieceBlocks;
      const targetCombo = aiAssistLevel;

      for (let r = 0; r < 3; r++) {
        let blocks = [...originalBlocks];
        for (let i = 0; i < r; i++) blocks.unshift(blocks.pop());

        for (let x = 0; x < COLS; x++) {
          let landY = this.findLandingY(this.grid, x);
          if (landY < 0) continue;

          // 即座に消える手はスキップ（それはcomboHintsで処理）
          let immediateChain = this.getChainLength(x, landY, blocks);
          if (immediateChain > 0) continue;

          // 配置後のグリッドをシミュレート
          let simGrid = this.copyGrid(this.grid);
          for (let i = 0; i < 3; i++) {
            if (landY + i >= 0 && landY + i < ROWS) {
              simGrid[x][landY + i] = blocks[i];
            }
          }

          // スコア計算
          let score = 0;
          let stepsToCombo = Infinity;
          let achievableChain = 0;
          
          // 次のピースでのポテンシャルをチェック
          if (nextBlocks && !nextBlocks.includes(7)) {
            for (let nr = 0; nr < 3; nr++) {
              let nextRotated = [...nextBlocks];
              for (let ni = 0; ni < nr; ni++) nextRotated.unshift(nextRotated.pop());
              
              for (let nx = 0; nx < COLS; nx++) {
                let nLandY = this.findLandingY(simGrid, nx);
                if (nLandY < 0) continue;
                
                let nextSimGrid = this.copyGrid(simGrid);
                for (let ni = 0; ni < 3; ni++) {
                  if (nLandY + ni >= 0 && nLandY + ni < ROWS) {
                    nextSimGrid[nx][nLandY + ni] = nextRotated[ni];
                  }
                }
                
                let nextChain = this.simulateChainDetailed(nextSimGrid);
                if (nextChain.chain > achievableChain) {
                  achievableChain = nextChain.chain;
                  if (nextChain.chain >= targetCombo) {
                    stepsToCombo = 2;
                  }
                }
              }
            }
          }
          
          // 任意のブロックでのポテンシャル（従来の方式も考慮）
          let generalPotential = this.getMaxChainFromOneDrop(simGrid);
          if (generalPotential > achievableChain) {
            achievableChain = generalPotential;
          }
          
          // スコア計算
          // - 達成可能なコンボ数が高いほど良い
          // - 目標に近いほど良い
          // - 手数が少ないほど良い
          score = achievableChain * 10000;
          if (achievableChain >= targetCombo) {
            score += 50000;
            score -= stepsToCombo * 5000; // 少ない手数を優先
          }
          
          // 低い位置を優先（安全）
          score += landY * 100;
          
          // 中央寄りを優先
          score -= Math.abs(x - 3.5) * 50;
          
          if (achievableChain >= 2) {
            candidates.push({
              x, 
              y: landY, 
              blocks: [...blocks], 
              potential: achievableChain,
              stepsToCombo: stepsToCombo === Infinity ? 3 : stepsToCombo,
              score: score
            });
            if (score > bestScore) bestScore = score;
          }
        }
      }

      if (candidates.length > 0) {
        // スコア順にソート
        candidates.sort((a, b) => b.score - a.score);
        
        // 同一場所・同一ブロックの重複を除去し、最もポテンシャルの高い1つだけを表示
        const uniqueCandidates = [];
        const seenPositions = new Set();
        
        for (const c of candidates) {
          // 場所とブロック配列でキーを作成
          const posKey = `${c.x}_${c.blocks.join(',')}`;
          if (!seenPositions.has(posKey)) {
            seenPositions.add(posKey);
            uniqueCandidates.push(c);
          }
        }
        
        // 最もポテンシャルの高い1つだけを表示
        this.createHints = uniqueCandidates.slice(0, 1);
      }
    }

    // 従来のcalculateCreateHints（互換性維持）
    calculateCreateHints() {
      this.calculateCreateHintsAdvanced();
    }

    getMaxChainFromOneDrop(grid) {
      let maxChain = 0;
      // Try dropping one block in each column
      for(let x=0; x<COLS; x++) {
        // Find landing y
        let y = -1;
        for(let r=0; r<ROWS; r++) {
          if(grid[x][r] !== 0) { y = r-1; break; }
          if(r === ROWS-1) y = ROWS-1;
        }
        if(y < 0) continue;

        // Try all colors (1-6)
        for(let c=1; c<=BLOCK_TYPES; c++) {
          // grid[x][y]構造なので、col単位でコピー
          let simGrid = [];
          for(let cx = 0; cx < COLS; cx++) {
            simGrid[cx] = grid[cx].slice();
          }
          simGrid[x][y] = c;
          let chain = this.simulateChain(simGrid);
          if(chain > maxChain) maxChain = chain;
        }
      }
      return maxChain;
    }

    simulateChain(simGrid) {
      let chain = 0;
      let active = true;
      let loopCount = 0;
      
      while(active && loopCount < 10) {
        loopCount++;
        let matches = this.findMatches(simGrid);
        if (matches.length > 0) {
          chain++;
          matches.forEach(m => simGrid[m.x][m.y] = 0);
          for (let cx = 0; cx < COLS; cx++) {
            let writeY = ROWS - 1;
            for (let cy = ROWS - 1; cy >= 0; cy--) {
              if (simGrid[cx][cy] !== 0) {
                simGrid[cx][writeY] = simGrid[cx][cy];
                if (writeY !== cy) simGrid[cx][cy] = 0;
                writeY--;
              }
            }
          }
        } else {
          active = false;
        }
      }
      return chain;
    }

    getChainLength(x, y, blocks) {
      // パフォーマンス最適化: グリッドバッファプールを使用
      const bufObj = acquireGridBuffer();
      const simGrid = bufObj.grid;
      copyGridToBuffer(this.grid, simGrid);
      for(let i=0; i<3; i++) {
        simGrid[x][y+i] = blocks[i];
      }
      const result = this.simulateChainPooled(simGrid);
      releaseGridBuffer(bufObj);
      return result;
    }

    // パフォーマンス最適化版simulateChain（Int8Array対応）
    simulateChainPooled(simGrid) {
      let chain = 0;
      let active = true;
      let loopCount = 0;
      
      while(active && loopCount < 10) {
        loopCount++;
        let matches = this.findMatches(simGrid);
        if (matches.length > 0) {
          chain++;
          for (let mi = 0; mi < matches.length; mi++) {
            const m = matches[mi];
            simGrid[m.x][m.y] = 0;
          }
          for (let cx = 0; cx < COLS; cx++) {
            let writeY = ROWS - 1;
            for (let cy = ROWS - 1; cy >= 0; cy--) {
              if (simGrid[cx][cy] !== 0) {
                simGrid[cx][writeY] = simGrid[cx][cy];
                if (writeY !== cy) simGrid[cx][cy] = 0;
                writeY--;
              }
            }
          }
        } else {
          active = false;
        }
      }
      return chain;
    }

    // --- メイン更新処理 ---
    update() {
      if (this.nextPieceAlpha < 255) {
        this.nextPieceAlpha = Math.min(255, this.nextPieceAlpha + 15);
      }

      if (this.state === 'PLAYING') {
        if (this.comboGraceTimer > 0) {
          this.comboGraceTimer--;
          if (this.comboGraceTimer <= 0) {
            if (this.comboCount > 0) {
              this.determineItemReward();
              this.comboCount = 0;
            }
          }
        }

        if (this.currentPiece) {
          // Smooth movement interpolation
          this.currentPiece.visualX = this.p.lerp(this.currentPiece.visualX, this.currentPiece.x, 0.3);
          this.currentPiece.visualY = this.p.lerp(this.currentPiece.visualY, this.currentPiece.y, 0.1);
          
          if (Math.abs(this.currentPiece.visualX - this.currentPiece.x) < 0.005) this.currentPiece.visualX = this.currentPiece.x;
          if (Math.abs(this.currentPiece.visualY - this.currentPiece.y) < 0.005) this.currentPiece.visualY = this.currentPiece.y;

          if (!this.isValid(this.currentPiece.x, this.currentPiece.y + 1)) {
            this.lockDelayTimer++;
            if (this.lockDelayTimer > this.LOCK_DELAY_LIMIT) {
              this.lockPiece();
              this.lockDelayTimer = 0;
            }
          } else {
            this.lockDelayTimer = 0;
          }
        }

        this.dropTimer++;
        if (this.dropTimer > this.dropInterval) {
          this.movePiece(0, 1);
          this.dropTimer = 0;
        }
        if (this.isCpu) {
          this.updateCPUItems();
          // AI steps based on settings
          const aiSteps = this.aiSettings.steps || (this.opponentIsDevil ? 2 : 1);
          for (let i = 0; i < aiSteps; i++) {
            this.updateAI();
          }
        }
      } else if (this.state === 'GAMEOVER_GRACE') {
        this.gameOverGraceTimer--;
        if (this.isCpu) this.updateCPUItems();
        
        if (this.gameOverGraceTimer <= 0) {
           let matches = this.findMatches();
           if (matches.length > 0) {
              this.state = 'ANIMATING';
              this.removingBlocks = matches;
              this.animationTimer = 0;
              this.comboScale = 2.0;
              this.comboGraceTimer = 0;
           } else if (this.grid[4][HIDDEN_ROWS] !== 0) {
              if (this.isCpu && this.opponentIsDevil && !isReviving && this.revivalCount < 2) {
                 this.triggerRevival();
              } else {
                 this.triggerCollapse();
              }
           } else {
              this.state = 'PLAYING';
              this.spawnPiece();
           }
        }
      } else if (this.state === 'ANIMATING') {
        if (this.isCpu) this.updateCPUItems();
        this.updateAnimation();
      } else if (this.state === 'COLLAPSING') {
        this.updateCollapse();
      }
      this.updateBounce();
    }

    // --- バウンド演出更新 ---
    updateBounce() {
      // アクティブなバウンスがあるセルのみ処理（リスト管理なしで軽量化）
      const bounceState = this.bounceState;
      for (let x = 0; x < COLS; x++) {
        const col = bounceState[x];
        for (let y = 0; y < ROWS; y++) {
          const b = col[y];
          const vy = b.vy;
          const by = b.y;
          if (by !== 0 || vy !== 0) {
            const newVy = vy + 1.0;
            const newY = by + newVy;
            if (newY > 0) {
              b.y = 0;
              b.vy = Math.abs(newVy) < 2.5 ? 0 : -newVy * 0.4;
            } else {
              b.y = newY;
              b.vy = newVy;
            }
          }
        }
      }
    }

    // --- AI思考ロジック ---
    updateAI() {
      if (!this.currentPiece) return;
      
      // Safety: グリッドが初期化されていない場合は処理をスキップ
      if (!this.grid || !this.grid[0]) return;
      
      // Safety: aiSettingsが初期化されていない場合はデフォルト値を使用
      if (!this.aiSettings) {
        this.aiSettings = { speed: 20, errorChance: 0.05, chainWeight: 20.0, lookaheadDepth: 2, setupWeight: 1.5, steps: 1, targetCombo: 3 };
      }
      
      // Safety: Force drop if stuck for too long
      this.aiGiveUpTimer++;
      if (this.aiGiveUpTimer > 300) { // Approx 5 seconds (or less in fast mode)
        this.hardDrop();
        return;
      }
      
      if (this.aiTargetX === null) {
        try {
          if (this.currentPiece.blocks && this.currentPiece.blocks.includes(7)) {
            this.findBestMoveForP();
          } else {
            this.findBestMove();
          }
        } catch (e) {
          // エラー発生時はデフォルトの位置にドロップ
          console.warn('AI findBestMove error:', e);
          this.aiTargetX = 4;
          this.aiTargetRot = 0;
        }
      }

      this.aiMoveTimer++;
      const aiSpeed = this.aiSettings.speed;
      
      if (this.aiMoveTimer > aiSpeed) {
        this.aiMoveTimer = 0;
        
        // Rotate
        if (this.aiTargetRot > 0) {
          this.rotatePiece();
          this.aiTargetRot--;
          return;
        }
        
        // Move X
        let moved = false;
        if (this.currentPiece.x < this.aiTargetX) {
          moved = this.movePiece(1, 0);
        } else if (this.currentPiece.x > this.aiTargetX) {
          moved = this.movePiece(-1, 0);
        } else {
          // Drop
          this.movePiece(0, 1);
          moved = true;
        }
        
        if (!moved) {
          // If blocked horizontally, try to drop. If drop also fails, reset target.
          if (!this.movePiece(0, 1)) {
             // If we can't move X and can't move Y, we are stuck or landed.
             // Don't immediately reset target to avoid oscillation.
             // Only reset if we are really far from target.
             if (Math.abs(this.currentPiece.x - this.aiTargetX) > 0) {
                this.aiTargetX = null;
             }
          }
        }
      }
    }

    // --- CPUアイテム使用ロジック ---
    updateCPUItems() {
      if (!this.itemStock || this.itemStock.length === 0) return;
      
      // Safety: グリッドが初期化されていない場合は処理をスキップ
      if (!this.grid || !this.grid[0]) return;

      // Analyze Field
      let totalBlocks = 0;
      let counts = new Array(BLOCK_TYPES + 1).fill(0);
      let colHeights = new Array(COLS).fill(0);
      let penaltyCount = 0;
      let opponentCombo = this.opponent ? this.opponent.comboCount : 0;
      
      for(let x=0; x<COLS; x++) {
        for(let y=0; y<ROWS; y++) {
          if (this.grid[x][y] !== 0) {
            totalBlocks++;
            let type = this.grid[x][y];
            if (type > 100) {
                type -= 100;
                penaltyCount++;
            }
            if (type <= BLOCK_TYPES) counts[type]++;
            
            let h = ROWS - y;
            if (h > colHeights[x]) colHeights[x] = h;
          }
        }
      }
      let col4Height = colHeights[4];
      
      // ===== ワーニング状態（GAMEOVER_GRACE）での緊急アイテム使用 =====
      // ゲームオーバー直前なので、延命できるアイテムを最優先で使用
      if (this.state === 'GAMEOVER_GRACE') {
        // 緊急時はディレイなしで即座にアイテム使用を試みる
        
        // Simulate Reverse for emergency check
        let revCol4Emergency = 0;
        let reverseMatchesEmergency = 0;
        const hasItemREmergency = this.itemStock.includes('R');
        if (hasItemREmergency) {
          let tempGrid = this.simulateReverseGrid();
          reverseMatchesEmergency = this.findMatches(tempGrid).length;
          for(let y=0; y<ROWS; y++) if(tempGrid[4][y]!==0) { revCol4Emergency = ROWS-y; break; }
        }
        
        // 相手フィールドの状況を確認（スワップ用）
        let opponentCol4HeightEmergency = 0;
        if (this.opponent && this.opponent.grid) {
          try {
            for(let y=0; y<ROWS; y++) {
              if (this.opponent.grid[4] && this.opponent.grid[4][y] !== 0) {
                opponentCol4HeightEmergency = ROWS - y;
                break;
              }
            }
          } catch (e) {
            opponentCol4HeightEmergency = 0;
          }
        }
        
        // 緊急アイテム優先度を評価
        const getEmergencyScore = (type) => {
          if (type === 'C') {
            // フィールド全消去：最優先で延命可能
            return 1000;
          } else if (type === 'S') {
            // スワップ：相手のフィールドが低ければ有効
            if (opponentCol4HeightEmergency < 10) return 900;
            return 0; // 相手も危険なら使わない
          } else if (type === 'R') {
            // リバース：反転後に5列目が低くなるか、マッチがあれば有効
            if (this.lastUsedItemType === 'R') return 0; // 連続使用禁止
            if (revCol4Emergency < 10) return 800; // 反転で大幅改善
            if (reverseMatchesEmergency > 0 && revCol4Emergency < 12) return 700; // マッチで消せる
            return 0;
          } else if (type === 'P') {
            // アイテムP: GAMEOVER_GRACE中は既に排出口が埋まっているため無効
            // （Pブロックが排出される前にゲームオーバーになる）
            return 0;
          }
          return 0;
        };
        
        // 最も効果的な緊急アイテムを探す
        let emergencyType = null;
        let emergencyScore = 0;
        
        let uniqueItemsEmergency = [...new Set(this.itemStock)];
        for (let type of uniqueItemsEmergency) {
          let s = getEmergencyScore(type);
          if (s > emergencyScore) {
            emergencyScore = s;
            emergencyType = type;
          }
        }
        
        // 緊急アイテムを使用
        if (emergencyScore > 0 && emergencyType) {
          // アイテムが先頭にあれば即使用
          if (this.itemStock[0] === emergencyType) {
            this.itemStock.shift();
            this.lastUsedItemType = emergencyType;
            if (emergencyType === 'R') {
              this.reverseField();
              this.triggerItemUseEffect('R');
              this.comboGraceTimer = 0;
              this.aiTargetX = null;
            } else if (emergencyType === 'C') {
              this.clearField();
              this.triggerItemUseEffect('C');
              this.aiTargetX = null;
            } else if (emergencyType === 'S') {
              this.performSwap(this.opponent);
              this.triggerItemUseEffect('S');
              this.aiTargetX = null;
              this.stats.itemsUsed++;
            }
            this.lastItemUseFrame = this.p.frameCount;
            // ワーニング状態を解除
            this.gameOverGraceTimer = 0;
            
            // アイテム効果によりフィールドが変化したので、マッチをチェック
            let emergencyMatches = this.findMatches();
            if (emergencyMatches.length > 0) {
              // マッチがあればアニメーション状態へ
              this.state = 'ANIMATING';
              this.removingBlocks = emergencyMatches;
              this.animationTimer = 0;
              this.comboScale = 2.0;
              this.comboGraceTimer = 0;
            } else {
              // マッチがなければPLAYINGに戻り、ピースを生成
              this.state = 'PLAYING';
              if (!this.currentPiece) {
                this.spawnPiece();
              }
            }
            return;
          } else {
            // 必要なアイテムが先頭にないなら即座にスワップ
            this.swapItems();
            // 次フレームで使用できるように
            return;
          }
        }
        // 延命アイテムがない場合はそのままゲームオーバーへ進む
        return;
      }
      // ===== 緊急アイテム使用ロジックここまで =====
      
      // Dynamic delay based on danger
      let delay = col4Height >= 10 ? 2 : 20;
      if (this.p.frameCount - this.lastItemUseFrame < delay) return;
      
      let maxColorCount = 0;
      for(let i=1; i<=BLOCK_TYPES; i++) {
          if (counts[i] > maxColorCount) maxColorCount = counts[i];
      }

      // Simulate Reverse - アイテムRを持っている場合のみシミュレーション
      let reverseMatches = 0;
      let revCol4 = 0;
      const hasItemR = this.itemStock.includes('R');
      if (hasItemR) {
        let tempGrid = this.simulateReverseGrid();
        reverseMatches = this.findMatches(tempGrid).length;
        for(let y=0; y<ROWS; y++) if(tempGrid[4][y]!==0) { revCol4 = ROWS-y; break; }
      }

      // Evaluate Items - アイテム使用タイミングを早めに調整
      const getScore = (type) => {
        let score = 0;
        
        // 状況判断: 5列目(index 4)が高くても、左右に逃げ場があればアイテムを温存する
        let sideSafe = (colHeights[3] < 9 || colHeights[5] < 9);
        
        // 相手フィールドの状況も確認（安全なnullチェック付き）
        let opponentCol4Height = 0;
        let opponentTotalBlocks = 0;
        if (this.opponent && this.opponent.grid) {
          try {
            for(let x=0; x<COLS; x++) {
              for(let y=0; y<ROWS; y++) {
                if (this.opponent.grid[x] && this.opponent.grid[x][y] !== 0) {
                  opponentTotalBlocks++;
                  if (x === 4) {
                    let h = ROWS - y;
                    if (h > opponentCol4Height) opponentCol4Height = h;
                  }
                }
              }
            }
          } catch (e) {
            // 相手フィールドが初期化されていない場合は無視
            opponentCol4Height = 0;
            opponentTotalBlocks = 0;
          }
        }
        
        // ピンチの定義（早めの判断に調整）
        // DoOrDie: 12段以上 (危険な状況)。アイテム使用を検討。
        const isDoOrDie = col4Height >= 12;
        
        // Critical: 11段以上 かつ (左右も埋まっている OR 全体的にブロックが多い)
        const isCritical = col4Height >= 11 && (!sideSafe || totalBlocks > 50);
        
        // Warning: 10段以上（早めの警戒）
        const isWarning = col4Height >= 10;

        if (type === 'S') {
            // アイテムS: 相手が大コンボ中（4コンボ以上）かつ自分もピンチの時に使用
            if (opponentCombo >= 5 && col4Height >= 8) {
                score = 180; // 相手の大コンボを奪取
            } else if (opponentCombo >= 4 && isDoOrDie) {
                score = 160; // 自分がピンチで相手が4コンボ中
            } else if (isDoOrDie && opponentCol4Height < 8 && opponentTotalBlocks < totalBlocks - 15) {
                // 自分が危険で、相手のフィールドが有利な時にスワップ
                score = 140;
            } else if (isCritical && opponentCol4Height < 6) {
                // Critical状態で相手が安全な時
                score = 100;
            }
        } else if (type === 'C') {
            // アイテムC: 危険な時に使用（早めに）
            if (isDoOrDie) score = 200;
            else if (isCritical) score = 150;
            else if (isWarning && totalBlocks > 55) score = 80;
        } else if (type === 'R') {
            // 1. 2回連続で使用しない
            if (this.lastUsedItemType === 'R') return 0;
            
            // 3. ピンチ回避（反転で状況改善が見込める時のみ）- 先にチェック
            if (revCol4 >= 11) return 0; // Avoid suicide

            // 2. コンボ中の使用 (コンボ継続狙い) - 1〜3コンボでも積極的に使用
            // フィールドが半分以上溜まっている場合（totalBlocks > 40）、1コンボからでも使用
            const fieldIsHalfFull = totalBlocks > 40;
            
            if (this.comboCount >= 1 && fieldIsHalfFull) {
                // フィールドが半分以上で1〜3コンボ中：積極的に使用してコンボ継続を狙う
                if (reverseMatches > 0) {
                    // 反転後にマッチがあれば高確率で高コンボが狙える
                    if (this.comboCount >= 3) score = 200; // 3コンボ以上なら最優先
                    else if (this.comboCount >= 2) score = 180; // 2コンボでも高優先
                    else score = 150; // 1コンボでも使用
                } else {
                    // マッチがなくてもコンボ中なら継続狙いで使用
                    if (this.comboCount >= 3) score = 140;
                    else if (this.comboCount >= 2) score = 100;
                    else score = 70; // 1コンボでも試す
                }
            } else if (this.comboCount >= 3) {
                // フィールドが半分未満でも3コンボ以上なら使用
                if (reverseMatches > 0) score = 180;
                else score = 120;
            }
            
            // アイテムストックがRで溢れそうな場合、積極的に使用
            const rCount = this.itemStock.filter(item => item === 'R').length;
            if (rCount >= 2 && totalBlocks > 30) {
                // Rが2つ以上あり、ある程度ブロックがあれば使用
                if (reverseMatches > 0) score = Math.max(score, 160);
                else score = Math.max(score, 100);
            }
            
            // ピンチ回避スコア
            let dangerScore = 0;
            if (isDoOrDie && revCol4 < 9) dangerScore = 150; // 反転で大幅改善が見込める
            else if (isCritical && revCol4 < 8 && reverseMatches > 0) dangerScore = 120;
            else if (isWarning && revCol4 < 7 && reverseMatches > 0) dangerScore = 80;
            
            score = Math.max(score, dangerScore);
        } else if (type === 'P') {
            // アイテムP: 早めに使用（フィールドが埋まる前に）
            if (this.state !== 'PLAYING' || this.nextSpawnIsItem) return 0;
            
            // 11段以上で使用開始。消せる色が十分にある時
            if (isDoOrDie && maxColorCount >= 4) {
                score = 150; // 緊急度高
            } else if (isCritical && maxColorCount >= 5) {
                score = 120; // Critical状態
            } else if (isWarning && maxColorCount >= 6) {
                // Warning状態で、消すと効果がある時
                score = 80;
            }
        }
        return score;
      };

      // Find best item in stock
      let bestType = null;
      let bestScore = 0;
      
      let uniqueItems = [...new Set(this.itemStock)];
      for (let type of uniqueItems) {
          let s = getScore(type);
          if (s > bestScore) {
              bestScore = s;
              bestType = type;
          }
      }

      const THRESHOLD = 50;

      if (bestScore >= THRESHOLD && bestType) {
          if (this.itemStock[0] === bestType) {
              // Use Item
              this.itemStock.shift();
              this.lastUsedItemType = bestType;
              if (bestType === 'P') {
                  this.nextSpawnIsItem = true;
                  this.nextPieceBlocks = [0, 0, 7];
                  this.triggerItemUseEffect('P');
              } else if (bestType === 'R') {
                  this.reverseField();
                  this.triggerItemUseEffect('R');
                  this.comboGraceTimer = 0;
                  this.aiTargetX = null;
              } else if (bestType === 'C') {
                  this.clearField();
                  this.triggerItemUseEffect('C');
                  this.aiTargetX = null;
              } else if (bestType === 'S') {
                  this.performSwap(this.opponent);
                  this.triggerItemUseEffect('S');
                  this.aiTargetX = null;
                  this.stats.itemsUsed++;
              }
              this.lastItemUseFrame = this.p.frameCount;
          } else {
              // Swap Item
              this.swapItems();
              this.lastItemUseFrame = this.p.frameCount - 10; // Quick swap
          }
      }
    }

    // --- AI補助メソッド ---
    simulateReverseGrid() {
        // Performance optimization: 再利用可能バッファを使用
        if (!this._reverseGridBuffer) {
          this._reverseGridBuffer = new Array(COLS);
          for(let i=0; i<COLS; i++) this._reverseGridBuffer[i] = new Array(ROWS);
        }
        const tempGrid = this._reverseGridBuffer;
        
        // コピーと反転を同時に行う
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            tempGrid[x][ROWS - 1 - y] = this.grid[x][y];
          }
        }
        
        // 重力適用
        for (let x = 0; x < COLS; x++) {
          let writeY = ROWS - 1;
          for (let y = ROWS - 1; y >= 0; y--) {
            if (tempGrid[x][y] !== 0) {
              if (writeY !== y) {
                tempGrid[x][writeY] = tempGrid[x][y];
                tempGrid[x][y] = 0;
              }
              writeY--;
            }
          }
        }
        return tempGrid;
    }

    findBestMoveForP() {
      // Safety check: gridが存在しない場合は早期リターン
      if (!this.grid || !this.grid[0]) {
        this.aiTargetX = 4;
        this.aiTargetRot = 0;
        return;
      }
      
      let counts = new Array(BLOCK_TYPES + 1).fill(0);
      for(let x=0; x<COLS; x++) {
        for(let y=0; y<ROWS; y++) {
          let t = this.grid[x][y];
          if (t > 0 && t <= BLOCK_TYPES) counts[t]++;
          else if (t > 100 && t-100 <= BLOCK_TYPES) counts[t-100]++;
        }
      }
      
      let sortedColors = [];
      for(let i=1; i<=BLOCK_TYPES; i++) sortedColors.push({type: i, count: counts[i]});
      sortedColors.sort((a, b) => b.count - a.count);
      
      // If in danger, prioritize colors in column 4
      let col4Height = 0;
      for(let y=0; y<ROWS; y++) if(this.grid[4][y]!==0) { col4Height = ROWS-y; break; }
      
      if (col4Height >= 10) {
          let col4Colors = new Set();
          for(let y=0; y<ROWS; y++) {
              let t = this.grid[4][y];
              if (t > 0) {
                  if (t > 100) t -= 100;
                  col4Colors.add(t);
              }
          }
          sortedColors.sort((a, b) => {
              let aIn = col4Colors.has(a.type) ? 1 : 0;
              let bIn = col4Colors.has(b.type) ? 1 : 0;
              if (aIn !== bIn) return bIn - aIn;
              return b.count - a.count;
          });
      }
      
      let bestX = 4;
      let found = false;
      const currentX = this.currentPiece ? this.currentPiece.x : 4;
      const currentY = this.currentPiece ? this.currentPiece.y : HIDDEN_ROWS - 2;
      
      for(let c of sortedColors) {
        if (c.count === 0) continue;
        let candidates = [];
        for(let x=0; x<COLS; x++) {
           // Check reachability first
           if (!this.canReach(currentX, x, currentY)) continue;

           for(let y=0; y<ROWS; y++) {
             if (this.grid[x][y] !== 0) {
               let t = this.grid[x][y];
               if (t > 100) t -= 100;
               if (t === c.type) {
                 candidates.push(x);
               }
               break;
             }
           }
        }
        if (candidates.length > 0) {
          candidates.sort((a, b) => Math.abs(a - currentX) - Math.abs(b - currentX));
          bestX = candidates[0];
          found = true;
          break;
        }
      }
      
      if (!found) {
        let maxH = 0;
        for(let x=0; x<COLS; x++) {
           if (!this.canReach(currentX, x, currentY)) continue;
           for(let y=0; y<ROWS; y++) {
             if (this.grid[x][y] !== 0) {
               if (ROWS-y > maxH) { maxH = ROWS-y; bestX = x; }
               break;
             }
           }
        }
      }
      
      this.aiTargetX = bestX;
      this.aiTargetRot = 0;
    }

    findBestMove() {
      // Safety check: currentPieceが存在しない場合は早期リターン
      if (!this.currentPiece || !this.currentPiece.blocks) {
        this.aiTargetX = 4;
        this.aiTargetRot = 0;
        return;
      }
      
      let bestScore = -Infinity;
      let bestX = 4;
      let bestRot = 0;
      
      const startX = this.currentPiece.x;
      const startY = this.currentPiece.y;
      
      // 高レベルAIは次のピースも考慮した評価を行う
      const targetCombo = this.aiSettings ? this.aiSettings.targetCombo || 3 : 3;
      const lookaheadDepth = this.aiSettings ? this.aiSettings.lookaheadDepth || 2 : 2;
      const useAdvancedEval = targetCombo >= 5 && lookaheadDepth >= 4;
      
      // 候補手を収集
      let candidates = [];

      // Try all rotations
      for (let r = 0; r < 3; r++) {
        let blocks = [...this.currentPiece.blocks];
        // Simulate rotation
        for(let i=0; i<r; i++) blocks.unshift(blocks.pop());

        // Try all columns
        for (let x = 0; x < COLS; x++) {
          // Check reachability
          if (!this.canReach(startX, x, startY)) continue;

          // Find drop Y
          let y = startY;
          let valid = true;
          while (true) {
            // Check if next Y is valid
            let nextY = y + 1;
            let collision = false;
            // Check collision for this position
            if (x < 0 || x >= COLS) collision = true;
            else {
              for (let i = 0; i < 3; i++) {
                let by = nextY + i;
                if (by < 0) continue;
                if (by >= ROWS || this.grid[x][by] !== 0) {
                  collision = true;
                  break;
                }
              }
            }
            
            if (collision) break;
            y++;
          }

          // Evaluate
          if (y > HIDDEN_ROWS - 3) {
            let score = this.evaluateMove(x, y, blocks);
            candidates.push({ x, y, rot: r, blocks: [...blocks], score });
            
            if (score > bestScore) {
              bestScore = score;
              bestX = x;
              bestRot = r;
            }
          }
        }
      }
      
      // 高レベルAI: 上位候補の中で、次のピースを考慮した追加評価
      if (useAdvancedEval && candidates.length > 0 && this.nextPieceBlocks) {
        // 上位5候補を絞り込む
        candidates.sort((a, b) => b.score - a.score);
        const topCandidates = candidates.slice(0, Math.min(5, candidates.length));
        
        let refinedBestScore = -Infinity;
        let refinedBestX = bestX;
        let refinedBestRot = bestRot;
        
        for (const cand of topCandidates) {
          // このcandidateを配置した後のグリッドをシミュレート
          // grid[x][y]構造なので、col単位でコピー
          let simGrid = [];
          for(let cx = 0; cx < COLS; cx++) {
            simGrid[cx] = this.grid[cx].slice();
          }
          for(let i = 0; i < 3; i++) {
            let by = cand.y + i;
            if (by >= 0 && by < ROWS) {
              simGrid[cand.x][by] = cand.blocks[i];
            }
          }
          
          // 連鎖があれば処理
          let matches = this.findMatches(simGrid);
          while (matches.length > 0) {
            matches.forEach(m => simGrid[m.x][m.y] = 0);
            // 重力適用
            for (let cx = 0; cx < COLS; cx++) {
              let writeY = ROWS - 1;
              for (let cy = ROWS - 1; cy >= 0; cy--) {
                if (simGrid[cx][cy] !== 0) {
                  if (writeY !== cy) {
                    simGrid[cx][writeY] = simGrid[cx][cy];
                    simGrid[cx][cy] = 0;
                  }
                  writeY--;
                }
              }
            }
            matches = this.findMatches(simGrid);
          }
          
          // 次のピースの評価を追加
          let nextPieceBonus = this.evaluateNextPiecePotential(simGrid, this.nextPieceBlocks);
          let refinedScore = cand.score + nextPieceBonus * 0.5;
          
          if (refinedScore > refinedBestScore) {
            refinedBestScore = refinedScore;
            refinedBestX = cand.x;
            refinedBestRot = cand.rot;
          }
        }
        
        bestX = refinedBestX;
        bestRot = refinedBestRot;
      }
      
      // Apply error chance for lower difficulties
      if (this.p.random() < this.aiSettings.errorChance) {
        bestX = this.p.floor(this.p.random(COLS));
        bestRot = this.p.floor(this.p.random(3));
      }

      this.aiTargetX = bestX;
      this.aiTargetRot = bestRot;
    }
    
    // 次のピースを置いた場合のポテンシャルを評価
    evaluateNextPiecePotential(grid, nextBlocks) {
      let bestScore = -Infinity;
      
      // 全ローテーション、全列をテスト
      for (let r = 0; r < 3; r++) {
        let blocks = [...nextBlocks];
        for(let i = 0; i < r; i++) blocks.unshift(blocks.pop());
        
        for (let x = 0; x < COLS; x++) {
          // 着地点を探す
          let landY = -1;
          for (let y = 0; y < ROWS; y++) {
            if (grid[x][y] !== 0) {
              landY = y - 3;
              break;
            }
            if (y === ROWS - 1) landY = ROWS - 3;
          }
          
          if (landY < 0 || landY >= ROWS - 2) continue;
          
          // スコア評価 - gridはgrid[x][y]構造なので、col単位でコピー
          let simGrid = [];
          for(let cx = 0; cx < COLS; cx++) {
            simGrid[cx] = grid[cx].slice();
          }
          for (let i = 0; i < 3; i++) {
            let by = landY + i;
            if (by >= 0 && by < ROWS) {
              simGrid[x][by] = blocks[i];
            }
          }
          
          // 連鎖数をカウント
          let chain = this.simulateChainQuick(simGrid);
          let score = chain * 10000;
          
          // 高さペナルティ
          for (let cx = 0; cx < COLS; cx++) {
            for (let cy = 0; cy < ROWS; cy++) {
              if (simGrid[cx][cy] !== 0) {
                let h = ROWS - cy;
                score -= h * h * 10;
                break;
              }
            }
          }
          
          if (score > bestScore) bestScore = score;
        }
      }
      
      return bestScore > -Infinity ? bestScore : 0;
    }

    canReach(fromX, toX, y) {
      if (fromX === toX) return true;
      const dir = fromX < toX ? 1 : -1;
      let curr = fromX;
      while (curr !== toX) {
        curr += dir;
        // Check collision at curr, y (and y+1, y+2)
        for (let i = 0; i < 3; i++) {
           let checkY = y + i;
           if (checkY >= ROWS) return false;
           if (checkY >= 0 && this.grid[curr][checkY] !== 0) return false;
        }
      }
      return true;
    }

    evaluateMove(x, y, blocks) {
      // Performance optimization: 再利用可能なグリッドバッファを使用
      if (!this._evalGridA) {
        this._evalGridA = new Array(COLS);
        this._evalGridB = new Array(COLS);
        this._evalGridC = new Array(COLS);
        for(let i=0; i<COLS; i++) {
          this._evalGridA[i] = new Array(ROWS);
          this._evalGridB[i] = new Array(ROWS);
          this._evalGridC[i] = new Array(ROWS);
        }
      }
      
      // Clone grid using pre-allocated buffer
      let tempGrid = this._evalGridA;
      for(let i=0; i<COLS; i++) {
        for(let j=0; j<ROWS; j++) {
          tempGrid[i][j] = this.grid[i][j];
        }
      }
      
      // Place blocks
      for(let i=0; i<3; i++) {
        let by = y + i;
        if (by >= 0 && by < ROWS) {
          tempGrid[x][by] = blocks[i];
        }
      }
      
      let score = 0;
      let currentGrid = tempGrid;
      let chain = 0;
      
      // ===== フィールド危険度の事前計算 =====
      let initialCol4Height = 0;
      let initialMaxHeight = 0;
      for(let cx=0; cx<COLS; cx++) {
        for(let cy=0; cy<ROWS; cy++) {
          if (this.grid[cx][cy] !== 0) {
            let h = ROWS - cy;
            if (h > initialMaxHeight) initialMaxHeight = h;
            if (cx === 4) initialCol4Height = h;
            break;
          }
        }
      }
      
      // 危険レベル判定
      const isDanger = initialCol4Height >= 10 || initialMaxHeight >= 12;
      const isCritical = initialCol4Height >= 12 || initialMaxHeight >= 13;
      const isDoOrDie = initialCol4Height >= 13;
      
      // 目標コンボ数（盤面状況に応じて動的に調整）
      const baseTargetCombo = this.aiSettings ? this.aiSettings.targetCombo || 3 : 3;
      const setupWeight = this.aiSettings ? this.aiSettings.setupWeight || 1.5 : 1.5;
      
      // 盤面のポテンシャルを評価して、目標コンボを動的に調整
      let targetCombo = baseTargetCombo;
      if (!isDoOrDie && !isCritical) {
        // 現在の盤面で達成可能な最大コンボを推定
        const maxAchievableCombo = this.estimateMaxAchievableCombo(this.grid, baseTargetCombo);
        // 目標コンボが達成困難な場合、狙える範囲での最大コンボに下げる
        if (maxAchievableCombo < baseTargetCombo) {
          targetCombo = Math.max(maxAchievableCombo, 2); // 最低2コンボは狙う
        }
      }
      
      // Simulation loop for chains - 深度を制限
      const maxDepth = Math.min(AI_SIMULATION_MAX_DEPTH, this.aiSettings ? this.aiSettings.lookaheadDepth || 5 : 5);
      
      while (chain < maxDepth) {
        let matchesData = this.findMatches(currentGrid);
        if (matchesData.length === 0) break;
        
        let matchCount = matchesData.length;
        
        // Score calculation - 計算を簡略化
        let chainBonus = chain < 4 ? (1 << (chain * 2)) : Math.pow(4, chain);
        score += matchCount * 1000 * chainBonus;
        
        // Prepare next state - バッファを交互に使用
        let nextGrid = (currentGrid === this._evalGridA) ? this._evalGridB : this._evalGridA;
        
        // Copy and clear matches in one pass
        for(let cx = 0; cx < COLS; cx++) {
          for(let cy = 0; cy < ROWS; cy++) {
            nextGrid[cx][cy] = currentGrid[cx][cy];
          }
        }
        for(let m = 0; m < matchesData.length; m++) {
          nextGrid[matchesData[m].x][matchesData[m].y] = 0;
        }
        
        // Gravity - インライン最適化
        for (let cx = 0; cx < COLS; cx++) {
          let writeY = ROWS - 1;
          for (let cy = ROWS - 1; cy >= 0; cy--) {
            if (nextGrid[cx][cy] !== 0) {
              if (writeY !== cy) {
                nextGrid[cx][writeY] = nextGrid[cx][cy];
                nextGrid[cx][cy] = 0;
              }
              writeY--;
            }
          }
        }
        currentGrid = nextGrid;
        chain++;
      }
      
      // 統合ループ: Height, Holes, Adjacency, VerticalPairs を一度に計算
      let maxHeight = 0;
      let col4Height = 0;
      let holes = 0;
      let adjacency = 0;
      let verticalPairs = 0;
      
      for(let cx=0; cx<COLS; cx++) {
        let foundBlock = false;
        for(let cy=0; cy<ROWS; cy++) {
          const cell = currentGrid[cx][cy];
          if (cell !== 0) {
            if (!foundBlock) {
              let h = ROWS - cy;
              if (h > maxHeight) maxHeight = h;
              if (cx === 4) col4Height = h;
              foundBlock = true;
            }
            // Holes check
            if (cy < ROWS - 1 && currentGrid[cx][cy+1] === 0) holes++;
            // Adjacency
            if (cx < COLS-1 && currentGrid[cx+1][cy] === cell) adjacency++;
            if (cy < ROWS-1 && currentGrid[cx][cy+1] === cell) {
              adjacency += 3;
              verticalPairs++;
            }
          }
        }
      }
      
      // ===== 危険時は生存を最優先 =====
      if (isDoOrDie) {
        // 即死危機: とにかく消して高さを下げることを最優先
        if (chain > 0) {
          // 消せるなら大きなボーナス
          score += chain * 500000;
          // 高さがどれだけ減るかも重視
          let heightReduction = initialCol4Height - col4Height;
          score += heightReduction * 100000;
        } else {
          // 消せない手は大きなペナルティ
          score -= 200000;
        }
      } else if (isCritical) {
        // 危険: 消せる手を優先しつつ、高さ削減を重視
        if (chain > 0) {
          score += chain * 200000;
          let heightReduction = initialCol4Height - col4Height;
          score += heightReduction * 50000;
        }
      } else if (isDanger) {
        // 警戒: 少し生存を意識
        if (chain > 0) {
          score += chain * 50000;
        }
      } else {
        // ===== 通常時: 目標コンボを狙う積み方を評価（より積極的に高コンボを狙う） =====
        
        // 即座に消える手かどうか
        let immediateChain = 0;
        {
          let simGrid = this._evalGridC;
          for(let i=0; i<COLS; i++) {
            for(let j=0; j<ROWS; j++) {
              simGrid[i][j] = tempGrid[i][j];
            }
          }
          let simMatches = this.findMatches(simGrid);
          if (simMatches.length > 0) {
            immediateChain = chain;
          }
        }
        
        if (immediateChain > 0) {
          // 消える手: 目標コンボ数との比較（高コンボをより重視）
          if (immediateChain >= targetCombo) {
            // 目標達成！大きなボーナス（目標超過は指数的に加算）
            let excessBonus = Math.pow(2, immediateChain - targetCombo);
            score += immediateChain * 120000 * setupWeight * excessBonus;
          } else if (immediateChain >= targetCombo - 1) {
            // 目標-1コンボは許容範囲（待っていても仕方ない場合もある）
            score += immediateChain * 60000 * setupWeight;
          } else if (immediateChain >= 3) {
            // 3コンボ以上なら軽いボーナス
            score += immediateChain * 20000;
          } else if (immediateChain === 2) {
            // 2コンボは状況次第（フィールドが混雑していれば許容）
            if (totalBlocks > 40) {
              score += immediateChain * 15000;
            } else {
              // フィールドに余裕があるなら待ってより大きなコンボを狙う
              score -= (targetCombo - immediateChain) * 15000 * setupWeight;
            }
          } else {
            // 1コンボで消すのは損（セットアップ破壊の可能性が高い）
            score -= (targetCombo - immediateChain) * 30000 * setupWeight;
          }
        } else {
          // 消えない手: セットアップのポテンシャルを評価
          // 次の一手で高コンボが狙えるかシミュレート
          let potential = this.evaluateSetupPotential(tempGrid, targetCombo);
          // ポテンシャルが高いほど大きなボーナス（高コンボへの準備を重視）
          score += potential * 40000 * setupWeight;
          
          // ポテンシャルが目標に近いならさらにボーナス
          if (potential >= targetCombo - 1) {
            score += 50000 * setupWeight;
          }
          
          // 隣接ボーナスを強化（セットアップ重視）
          score += adjacency * 300 * setupWeight;
          score += verticalPairs * 600 * setupWeight;
        }
      }
      
      // 基本的な評価（全状況共通）
      score -= maxHeight * maxHeight * 50;
      
      // Exit column (4) specific penalty
      if (col4Height > 10) {
        score -= col4Height * col4Height * col4Height * col4Height * 200;
      } else {
        score -= col4Height * col4Height * 100;
      }
      
      score -= holes * 5000;
      score += adjacency * 100;
      score += verticalPairs * 200;
      
      // Suicide check
      if (tempGrid[4][HIDDEN_ROWS] !== 0) {
        score -= 100000000;
      }
      
      // Random factor to make it less robotic
      score += this.p.random(0, 10);
      
      return score;
    }

    // セットアップポテンシャルを評価（次の数手でどれだけのコンボが狙えるか）
    evaluateSetupPotential(grid, targetCombo) {
      let maxPotential = 0;
      
      // 各列に1〜3ブロック落とした場合のコンボ数をシミュレート
      for(let testX = 0; testX < COLS; testX++) {
        // その列の着地点を探す
        let landY = -1;
        for(let r = 0; r < ROWS; r++) {
          if(grid[testX][r] !== 0) { landY = r - 1; break; }
          if(r === ROWS - 1) landY = ROWS - 1;
        }
        if(landY < 0) continue;
        
        // 全色でテスト
        for(let c = 1; c <= BLOCK_TYPES; c++) {
          // 1ブロックのみのシミュレーション（軽量化）
          // gridはgrid[x][y]構造なので、col単位でコピー
          let simGrid = [];
          for(let cx = 0; cx < COLS; cx++) {
            simGrid[cx] = grid[cx].slice();
          }
          if (landY >= 0 && landY < ROWS) {
            simGrid[testX][landY] = c;
          }
          
          let simChain = this.simulateChainQuick(simGrid);
          if (simChain > maxPotential) maxPotential = simChain;
          
          // 目標コンボ達成可能なら早期終了
          if (maxPotential >= targetCombo) {
            return maxPotential;
          }
        }
      }
      
      return maxPotential;
    }
    
    // 軽量版連鎖シミュレーション
    simulateChainQuick(simGrid) {
      let chain = 0;
      let active = true;
      let loopCount = 0;
      
      while(active && loopCount < 8) {
        loopCount++;
        let matches = this.findMatches(simGrid);
        if (matches.length > 0) {
          chain++;
          matches.forEach(m => simGrid[m.x][m.y] = 0);
          for (let cx = 0; cx < COLS; cx++) {
            let writeY = ROWS - 1;
            for (let cy = ROWS - 1; cy >= 0; cy--) {
              if (simGrid[cx][cy] !== 0) {
                simGrid[cx][writeY] = simGrid[cx][cy];
                if (writeY !== cy) simGrid[cx][cy] = 0;
                writeY--;
              }
            }
          }
        } else {
          active = false;
        }
      }
      return chain;
    }
    
    // 盤面から達成可能な最大コンボ数を推定
    // 複数手先のシミュレーションを行い、目標コンボが現実的かを判断
    estimateMaxAchievableCombo(grid, maxTarget) {
      let maxFound = 0;
      
      // 現在のブロック総数と色の分布を分析
      let totalBlocks = 0;
      let colorCounts = {};
      for(let cx = 0; cx < COLS; cx++) {
        for(let cy = 0; cy < ROWS; cy++) {
          if(grid[cx][cy] !== 0 && grid[cx][cy] !== 7) {
            totalBlocks++;
            const color = grid[cx][cy];
            colorCounts[color] = (colorCounts[color] || 0) + 1;
          }
        }
      }
      
      // ブロック数が少なすぎる場合、高コンボは困難
      if (totalBlocks < 12) {
        return Math.min(2, maxTarget);
      }
      
      // 各色の最大数から理論上のコンボ上限を推定
      let theoreticalMax = 0;
      for (let color in colorCounts) {
        // 3つ以上あれば消せる（1コンボにつき最低3ブロック必要）
        const combosFromColor = Math.floor(colorCounts[color] / 3);
        theoreticalMax += combosFromColor;
      }
      
      // 理論上の最大値が目標より低ければ、それを返す
      if (theoreticalMax < maxTarget) {
        return Math.max(theoreticalMax, 2);
      }
      
      // 複数の列・色で3手先までシミュレート
      const testColors = Object.keys(colorCounts).map(Number).filter(c => colorCounts[c] >= 3);
      
      for(let testX = 0; testX < COLS; testX++) {
        // その列の着地点を探す
        let landY = -1;
        for(let r = 0; r < ROWS; r++) {
          if(grid[testX][r] !== 0) { landY = r - 1; break; }
          if(r === ROWS - 1) landY = ROWS - 1;
        }
        if(landY < 0 || landY < 2) continue; // 3ブロック置く余地がない
        
        // 主要な色でテスト
        for(let ci = 0; ci < Math.min(testColors.length, 4); ci++) {
          const c = testColors[ci];
          
          // 3ブロック縦に置くシミュレーション
          let simGrid = [];
          for(let cx = 0; cx < COLS; cx++) {
            simGrid[cx] = grid[cx].slice();
          }
          
          // 3ブロック置く
          for(let i = 0; i < 3; i++) {
            const py = landY - 2 + i;
            if (py >= 0 && py < ROWS) {
              simGrid[testX][py] = c;
            }
          }
          
          let simChain = this.simulateChainQuick(simGrid);
          if (simChain > maxFound) maxFound = simChain;
          
          // 目標達成可能なら早期終了
          if (maxFound >= maxTarget) {
            return maxFound;
          }
        }
      }
      
      // 2手先のシミュレーション（より深い探索）
      if (maxFound < maxTarget && totalBlocks >= 20) {
        for(let x1 = 0; x1 < COLS; x1 += 2) { // 偶数列のみ（軽量化）
          let landY1 = -1;
          for(let r = 0; r < ROWS; r++) {
            if(grid[x1][r] !== 0) { landY1 = r - 1; break; }
            if(r === ROWS - 1) landY1 = ROWS - 1;
          }
          if(landY1 < 2) continue;
          
          for(let ci = 0; ci < Math.min(testColors.length, 3); ci++) {
            const c1 = testColors[ci];
            
            // 1手目のシミュレーション
            let simGrid1 = [];
            for(let cx = 0; cx < COLS; cx++) {
              simGrid1[cx] = grid[cx].slice();
            }
            for(let i = 0; i < 3; i++) {
              const py = landY1 - 2 + i;
              if (py >= 0 && py < ROWS) {
                simGrid1[x1][py] = c1;
              }
            }
            
            // 1手目で消えない場合、2手目を探す
            let matches1 = this.findMatches(simGrid1);
            if (matches1.length === 0) {
              // 2手目のシミュレーション
              for(let x2 = 0; x2 < COLS; x2 += 2) {
                let landY2 = -1;
                for(let r = 0; r < ROWS; r++) {
                  if(simGrid1[x2][r] !== 0) { landY2 = r - 1; break; }
                  if(r === ROWS - 1) landY2 = ROWS - 1;
                }
                if(landY2 < 2) continue;
                
                for(let cj = 0; cj < Math.min(testColors.length, 2); cj++) {
                  const c2 = testColors[cj];
                  
                  let simGrid2 = [];
                  for(let cx = 0; cx < COLS; cx++) {
                    simGrid2[cx] = simGrid1[cx].slice();
                  }
                  for(let i = 0; i < 3; i++) {
                    const py = landY2 - 2 + i;
                    if (py >= 0 && py < ROWS) {
                      simGrid2[x2][py] = c2;
                    }
                  }
                  
                  let simChain = this.simulateChainQuick(simGrid2);
                  if (simChain > maxFound) maxFound = simChain;
                  
                  if (maxFound >= maxTarget) {
                    return maxFound;
                  }
                }
              }
            }
          }
        }
      }
      
      return Math.max(maxFound, 2);
    }

    drawWarningOverlay() {
      if (this.state !== 'GAMEOVER_GRACE') return;
      
      const w = boardWidth;
      const h = boardHeight;
      const t = 1.0 - (this.gameOverGraceTimer / 60.0); // 0.0 -> 1.0
      
      this.p.push();
      this.p.rectMode(this.p.CORNER);
      
      // 1. Emergency Red Tint (Pulsing)
      let pulse = Math.sin(this.p.frameCount * 0.8) * 0.5 + 0.5;
      let alpha = (t * 0.6 + pulse * 0.2) * 255;
      
      this.p.noStroke();
      this.p.fill(255, 0, 0, alpha * 0.3);
      this.p.rect(0, 0, w, h);
      
      // 2. Highlight The Danger Zone (Column 5 / Index 4)
      let colX = 4 * cellSize;
      this.p.noFill();
      this.p.stroke(255, 0, 0, alpha);
      this.p.strokeWeight(3);
      this.p.rect(colX, 0, cellSize, h);
      
      // Diagonal hazard stripes on the column
      this.p.stroke(255, 0, 0, alpha * 0.5);
      this.p.strokeWeight(1);
      for(let y = 0; y < h; y += 20) {
          let offset = (this.p.frameCount * 2) % 20;
          this.p.line(colX, y + offset, colX + cellSize, y + offset + 10);
      }

      // 3. Central Warning UI
      this.p.translate(w/2, h/2);
      
      // Screen Shake for text
      let shake = t * 5;
      this.p.translate(this.p.random(-shake, shake), this.p.random(-shake, shake));
      
      // "WARNING" Text
      if (this.p.frameCount % 10 < 8) {
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.textFont('Orbitron');
        this.p.textStyle(this.p.BOLD);
        
        // Glitch effect layers
        this.p.textSize(40 + t * 10);
        this.p.fill(255, 0, 0, 200);
        this.p.text("WARNING", 4, 0);
        this.p.fill(0, 255, 255, 200);
        this.p.text("WARNING", -4, 0);
        this.p.fill(255);
        this.p.text("WARNING", 0, 0);
        
        // Subtext
        this.p.textSize(14);
        this.p.fill(255, 100, 100);
        this.p.text("SYSTEM OVERLOAD", 0, 35);
        
        // Countdown
        let timeLeft = (this.gameOverGraceTimer / 60).toFixed(2);
        this.p.textSize(28);
        this.p.fill(255, 0, 0);
        this.p.text(timeLeft, 0, 65);
      }
      
      // 4. Hexagonal Alert Ring
      this.p.noFill();
      this.p.stroke(255, 0, 0, alpha);
      this.p.strokeWeight(2);
      let r = 100 + Math.sin(this.p.frameCount * 0.5) * 10;
      this.p.beginShape();
      for(let i=0; i<6; i++) {
          let ang = i * this.p.TWO_PI / 6 + this.p.frameCount * 0.05;
          this.p.vertex(Math.cos(ang)*r, Math.sin(ang)*r);
      }
      this.p.endShape(this.p.CLOSE);
      
      this.p.pop();
    }

    // --- 描画処理 ---
    triggerNextTransition() {
      if (this.boardX === undefined) return;

      const nextScale = 0.95;
      const nextCellSize = cellSize * nextScale;
      const nextH = nextCellSize * 3.2;
      const gaugeH = 20;
      const gaugeY = -gaugeH - 5;
      
      const nextAreaW = cellSize * 2.2;
      const gaugeW = boardWidth - nextAreaW;
      const nextX = gaugeW + nextAreaW / 2;
      const nextY = gaugeY + gaugeH - nextH;
      
      const centerX = nextX;
      const centerY = nextY + nextH / 2;
      const absX = this.boardX + centerX;
      const absY = this.boardY + centerY;

      if (this.opponentIsDevil) {
        for (let i = 0; i < 10; i++) {
          let angle = this.p.random(this.p.TWO_PI);
          let speed = this.p.random(2, 6);
          this.particles.push({
            x: absX,
            y: absY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            gravity: 0.1,
            size: this.p.random(3, 6),
            life: this.p.random(0.4, 0.8),
            color: '#FF00FF',
            isSpark: true
          });
        }
      } else {
        for (let i = 0; i < 8; i++) {
          this.particles.push({
            x: absX + this.p.random(-nextCellSize, nextCellSize),
            y: absY + this.p.random(-nextH/2, nextH/2),
            vx: this.p.random(-1, 1),
            vy: this.p.random(-1, -2),
            gravity: -0.05,
            size: this.p.random(cellSize * 0.1, cellSize * 0.3),
            life: this.p.random(0.5, 1.0),
            color: '#FFFFFF',
            isBubble: true
          });
        }
      }
      this.nextPieceAlpha = 0;
    }

    // === コンボルート視覚化（フィールド上のブロックマーカーのみ表示）===
    // 右側パネルは drawRouteDisplayPanel で表示するため、ここではフィールド上のマーカーのみ
    drawComboRouteVisualization(chainSteps, placementX, placementY) {
      if (!chainSteps || chainSteps.length === 0) return;
      
      const p = this.p;
      const animPhase = (p.frameCount * 0.03) % chainSteps.length;
      const currentStep = Math.floor(animPhase);
      
      // 色の定義（各連鎖ステップごとに異なる色）
      const stepColors = [
        [255, 80, 80],     // 1C: 赤
        [255, 160, 60],    // 2C: オレンジ
        [255, 230, 80],    // 3C: 黄
        [80, 230, 100],    // 4C: 緑
        [80, 180, 255],    // 5C: 水色
        [160, 80, 255],    // 6C: 紫
        [255, 80, 180],    // 7C: ピンク
        [255, 255, 255],   // 8C: 白
      ];
      
      p.push();
      
      // フィールド上に消去されるブロックをハイライト表示（番号付き）
      chainSteps.forEach((step, idx) => {
        const color = stepColors[idx % stepColors.length];
        const isCurrentAnim = (idx === currentStep);
        const baseAlpha = isCurrentAnim ? 200 : 80;
        const pulseAlpha = isCurrentAnim ? baseAlpha + Math.sin(p.frameCount * 0.15) * 40 : baseAlpha;
        
        step.clearedBlocks.forEach(block => {
          if (block.y >= HIDDEN_ROWS) {
            const px = block.x * cellSize + cellSize/2;
            const py = (block.y - HIDDEN_ROWS) * cellSize + cellSize/2;
            
            // ブロックにオーバーレイマーカー（枠線）
            p.noFill();
            p.stroke(color[0], color[1], color[2], pulseAlpha);
            p.strokeWeight(isCurrentAnim ? 3 : 2);
            p.rectMode(p.CENTER);
            p.rect(px, py, cellSize - 2, cellSize - 2, 3);
            
            // 連鎖番号をブロック上に表示（背景付き）
            const numBgSize = 16;
            p.fill(0, 0, 0, pulseAlpha);
            p.noStroke();
            p.ellipse(px, py, numBgSize, numBgSize);
            
            p.fill(color[0], color[1], color[2], pulseAlpha + 50);
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(11);
            p.textStyle(p.BOLD);
            p.text(step.chainNumber, px, py);
            p.textStyle(p.NORMAL);
          }
        });
      });
      
      p.pop();
    }

    drawAIIntent() {
      if (!this.isCpu || !this.currentPiece || this.aiTargetX === null) return;
      
      let startX = this.boardX + this.currentPiece.x * cellSize + cellSize/2;
      let startY = this.boardY + (this.currentPiece.y - HIDDEN_ROWS) * cellSize + cellSize/2;
      let targetX = this.boardX + this.aiTargetX * cellSize + cellSize/2;
      let targetY = this.boardY + boardHeight; // Bottom of board
      
      this.p.push();
      this.p.blendMode(this.p.ADD);
      
      // Laser Sight Effect
      let alpha = 150 + Math.sin(this.p.frameCount * 0.8) * 100;
      this.p.stroke(255, 0, 255, alpha);
      this.p.strokeWeight(3);
      
      // Path lines
      this.p.line(startX, startY, targetX, startY);
      this.p.line(targetX, startY, targetX, targetY);
      
      // Target Marker (Rotating Reticle)
      this.p.noFill();
      this.p.stroke(0, 255, 255, 200);
      this.p.strokeWeight(2);
      
      this.p.translate(targetX, startY);
      this.p.rotate(this.p.frameCount * 0.15);
      this.p.rectMode(this.p.CENTER);
      this.p.rect(0, 0, cellSize, cellSize);
      this.p.rotate(this.p.PI / 4);
      this.p.rect(0, 0, cellSize * 0.7, cellSize * 0.7);
      
      this.p.pop();
    }

    draw(bx, by, isPaused) {
      this.boardX = bx;
      this.boardY = by;
      
      // Draw Board Background
      this.p.push();
      this.p.translate(bx, by);
      this.p.noStroke();
      this.p.fill(COLORS.gridBg);
      this.p.rect(-5, -5, boardWidth + 10, boardHeight + 10, 10);
      this.p.stroke(COLORS.gridBorder);
      this.p.strokeWeight(2);
      this.p.noFill();
      this.p.rect(0, 0, boardWidth, boardHeight, 5);

      // Define gauge metrics for layout
      const gaugeH = 20;
      const gaugeY = -gaugeH - 5;

      // Next Piece Display
      const nextScale = 0.95;
      const nextCellSize = cellSize * nextScale;
      const nextW = nextCellSize * 1.2;
      const nextH = nextCellSize * 3.2;
      
      const nextAreaW = cellSize * 2.2;
      const gaugeW = boardWidth - nextAreaW;
      const nextX = gaugeW + nextAreaW / 2;
      const nextY = gaugeY + gaugeH - nextH;

      this.p.push();
      this.p.translate(nextX, nextY);
      
      this.p.fill(0, 0, 0, 100);
      this.p.stroke(COLORS.gridBorder);
      this.p.strokeWeight(1);
      this.p.rectMode(this.p.CENTER);
      this.p.rect(0, nextH/2, nextW, nextH, 5);

      if (this.nextPieceBlocks) {
        for(let i=0; i<3; i++) {
          let type = this.nextPieceBlocks[i];
          let py = (i * nextCellSize) + nextCellSize/2 + (nextH - nextCellSize*3)/2;
          if (gemImages[type]) {
            this.p.tint(255, this.nextPieceAlpha);
            this.p.image(gemImages[type], 0, py, nextCellSize, nextCellSize);
            this.p.noTint();
          }
        }
      }
      this.p.pop();

      // Gauge Display (Top of Board)
      
      // Gauge Background
      this.p.noStroke();
      this.p.fill(20, 20, 20, 200);
      this.p.rect(0, gaugeY, gaugeW, gaugeH, 4);
      
      // Attack Gauge (Accumulated Blocks / 18)
      let gaugeVal = this.attackGauge;
      let gaugeRatio = this.p.constrain(gaugeVal / 15.0, 0, 1);
      
      // Neon Gauge Effect
      if (gaugeRatio > 0) {
        this.p.push();
        this.p.blendMode(this.p.ADD);
        this.p.noStroke();
        
        let barW = gaugeW * gaugeRatio;
        
        // Glow layers
        this.p.fill(255, 215, 0, 50); // Wide soft glow
        this.p.rect(0, gaugeY - 4, barW, gaugeH + 8, 8);
        
        this.p.fill(255, 255, 0, 100); // Medium glow
        this.p.rect(0, gaugeY - 1, barW, gaugeH + 2, 4);
        
        this.p.fill(255, 255, 200, 255); // Core brightness
        this.p.rect(0, gaugeY + 4, barW, gaugeH - 8, 2);
        
        // Full charge pulse
        if (gaugeVal >= 15) {
          let pulse = (Math.sin(this.p.frameCount * 0.2) + 1) * 0.5;
          this.p.fill(255, 255, 255, pulse * 150);
          this.p.rect(0, gaugeY, barW, gaugeH, 4);
        }
        this.p.pop();
      }
      
      // Gauge Frame
      this.p.stroke(COLORS.gridBorder);
      this.p.strokeWeight(2);
      this.p.noFill();
      this.p.rect(0, gaugeY, gaugeW, gaugeH, 4);
      
      // Item Frame
      const itemY = boardHeight + 5;
      const firstSlotSize = cellSize * 1.4;
      
      this.p.stroke(COLORS.gridBorder);
      this.p.strokeWeight(2);
      this.p.noFill();
      
      // First slot (Larger)
      this.p.rect(0, itemY, firstSlotSize, firstSlotSize, 5);
      // Remaining slots (6 slots)
      const remainingW = boardWidth - firstSlotSize;
      const slotW = remainingW / 6;
      this.p.rect(firstSlotSize, itemY, remainingW, cellSize, 5);
      // Dividers for remaining slots
      for (let i = 1; i < 6; i++) {
        this.p.line(firstSlotSize + slotW * i, itemY, firstSlotSize + slotW * i, itemY + cellSize);
      }
      
      // Draw Items
      for(let i=0; i<this.itemStock.length; i++) {
        let itemType = this.itemStock[i];
        let imgIndex = itemType === 'P' ? 7 : (itemType === 'R' ? 8 : (itemType === 'C' ? 9 : 10));
        
        if (i === 0) {
          // Large display for first item
          let ix = firstSlotSize / 2; 
          let iy = itemY + firstSlotSize / 2;
          this.p.image(gemImages[imgIndex], ix, iy, firstSlotSize * 0.75, firstSlotSize * 0.75);
          
          // Highlight active item
          this.p.push();
          this.p.stroke(255, 255, 0, 150);
          this.p.strokeWeight(3);
          this.p.noFill();
          this.p.rect(0, itemY, firstSlotSize, firstSlotSize, 5);
          this.p.pop();
        } else {
          // Standard display for stock
          let ix = firstSlotSize + (i - 1) * slotW + slotW/2;
          let iy = itemY + cellSize/2;
          let size = Math.min(slotW, cellSize) * 0.7;
          this.p.image(gemImages[imgIndex], ix, iy, size, size);
        }
      }

      // Static Blocks - 可視領域のみ描画
      if (this.state !== 'COLLAPSING') {
        const grid = this.grid;
        for (let x = 0; x < COLS; x++) {
          const col = grid[x];
          // HIDDEN_ROWS以降のみ描画（可視領域）
          for (let y = HIDDEN_ROWS; y < ROWS; y++) {
            const cell = col[y];
            if (cell > 0) {
              this.drawBlock(x, y, cell, 1, 255, true);
            }
          }
        }
      } else {
        this.drawCollapse();
      }

      // Removing Blocks
      if (this.state === 'ANIMATING') {
        const flashDuration = 20;
        const totalDuration = 45;
        
        this.removingBlocks.forEach(b => {
           if (this.animationTimer < flashDuration) {
             // Flash phase
             let t = this.animationTimer / flashDuration;
             let scale = 1.0 + Math.sin(t * Math.PI) * 0.2;
             this.drawBlock(b.x, b.y, b.type, scale, 255);
             
             this.p.push();
             let cx = b.x * cellSize + cellSize/2;
             let cy = (b.y - HIDDEN_ROWS) * cellSize + cellSize/2;
             this.p.translate(cx, cy);
             this.p.blendMode(this.p.ADD);
             this.p.noStroke();
             this.p.fill(255, 255, 255, Math.sin(t * Math.PI) * 200);
             this.p.rectMode(this.p.CENTER);
             this.p.rect(0, 0, cellSize * 0.85 * scale, cellSize * 0.85 * scale);
             this.p.pop();
           } else {
             // Fade out phase
             let t = (this.animationTimer - flashDuration) / (totalDuration - flashDuration);
             let scale = 1.0 + t * 0.5;
             let alpha = 255 * (1 - t);
             this.drawBlock(b.x, b.y, b.type, scale, alpha);
           }
        });
      }

      // Ghost Piece (Guide)
      if (this.state === 'PLAYING' && this.currentPiece && !this.isCpu) {
        let ghostY = this.currentPiece.y;
        while (this.isValid(this.currentPiece.x, ghostY + 1)) {
          ghostY++;
        }
        if (ghostY >= this.currentPiece.y + 3) {
          for (let i = 0; i < 3; i++) {
            let visualY = ghostY + i;
            if (visualY < ROWS) {
               this.drawBlock(this.currentPiece.x, visualY, this.currentPiece.blocks[i], 1, 100);
            }
          }
        }
      }

      // === コンボヒント表示（強調版）===
      if (this.isTraining && this.comboHints.length > 0) {
        this.p.push();
        const pulseScale = 1.0 + Math.sin(this.p.frameCount * 0.15) * 0.05;
        const glowAlpha = 150 + Math.sin(this.p.frameCount * 0.1) * 50;
        
        this.comboHints.forEach(h => {
           let isMatch = false;
           if (this.currentPiece) {
             isMatch = true;
             for(let k=0; k<3; k++) {
               if (h.blocks[k] !== this.currentPiece.blocks[k]) {
                 isMatch = false;
                 break;
               }
             }
           }
           
           let strokeAlpha = isMatch ? 255 : 80;
           let strokeW = isMatch ? 4 : 2;
           let imgAlpha = isMatch ? 220 : 100;

           // 外枠のグロー効果
           if (isMatch) {
             for(let i=0; i<3; i++) {
               let gy = h.y + i;
               if (gy >= HIDDEN_ROWS) {
                 let px = h.x * cellSize + cellSize/2;
                 let py = (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
                 
                 // 外側のグロー
                 this.p.noFill();
                 this.p.stroke(255, 215, 0, glowAlpha * 0.3);
                 this.p.strokeWeight(8);
                 this.p.rectMode(this.p.CENTER);
                 this.p.rect(px, py, cellSize * pulseScale, cellSize * pulseScale);
               }
             }
           }

           for(let i=0; i<3; i++) {
             let gy = h.y + i;
             if (gy >= HIDDEN_ROWS) {
               let px = h.x * cellSize + cellSize/2;
               let py = (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
               
               this.p.noFill();
               this.p.stroke(255, 215, 0, strokeAlpha);
               this.p.strokeWeight(strokeW);
               this.p.rectMode(this.p.CENTER);
               this.p.rect(px, py, cellSize, cellSize);
               
               let type = h.blocks[i];
               if (gemImages[type]) {
                 this.p.tint(255, 255, 200, imgAlpha);
                 this.p.image(gemImages[type], px, py, cellSize*0.9, cellSize*0.9);
                 this.p.noTint();
               }
             }
           }
           
           // コンボ数ラベル（強調版）
           if (h.y >= HIDDEN_ROWS) {
             let tx = h.x * cellSize + cellSize/2;
             let ty = (h.y - HIDDEN_ROWS) * cellSize - 5;
             
             // 背景バッジ（マッチ時は「▼ここ！」も含めるため高さを大きく）
             const badgeW = 70;
             const badgeH = isMatch ? 38 : 24;
             const badgeCenterY = ty - badgeH/2 - (isMatch ? 8 : 0);
             this.p.fill(0, 0, 0, isMatch ? 200 : 100);
             this.p.stroke(255, 215, 0, isMatch ? 255 : 100);
             this.p.strokeWeight(2);
             this.p.rectMode(this.p.CENTER);
             this.p.rect(tx, badgeCenterY, badgeW, badgeH, 12);
             
             // テキスト
             this.p.noStroke();
             this.p.fill(255, 215, 0, isMatch ? 255 : 150);
             this.p.textAlign(this.p.CENTER, this.p.CENTER);
             this.p.textSize(isMatch ? 16 : 14);
             this.p.textStyle(this.p.BOLD);
             this.p.text("★" + h.chain + "C★", tx, badgeCenterY - (isMatch ? 7 : 0));
             this.p.textStyle(this.p.NORMAL);
             
             // 「今すぐ！」インジケーター（バッジ内に統合）
             if (isMatch) {
               this.p.fill(50, 255, 50, glowAlpha);
               this.p.textSize(11);
               this.p.text("▼ここ！", tx, badgeCenterY + 10);
             }
           }
           
           // === コンボルート視覚化（連鎖の消える順番を表示）===
           if (showComboRouteVisualization && h.chainSteps && h.chainSteps.length > 0 && isMatch) {
             this.drawComboRouteVisualization(h.chainSteps, h.x, h.y);
           }
        });
        this.p.pop();
      }

      // === セットアップヒント（強調版）===
      if (this.isTraining && this.createHints.length > 0) {
        this.p.push();
        const pulseAlpha = 180 + Math.sin(this.p.frameCount * 0.12) * 40;
        
        this.createHints.forEach((h, idx) => {
           let isMatch = false;
           if (this.currentPiece) {
             isMatch = true;
             for(let k=0; k<3; k++) {
               if (h.blocks[k] !== this.currentPiece.blocks[k]) {
                 isMatch = false;
                 break;
               }
             }
           }

           // 消去用の手はオレンジ、セットアップ用はシアン
           const isClearingMove = h.isClearingMove || false;
           const baseColor = isClearingMove ? [255, 150, 50] : [0, 220, 255];
           
           let strokeAlpha = isMatch ? 255 : 80;
           let strokeW = isMatch ? 4 : 2;
           let imgAlpha = isMatch ? 200 : 90;

           // グロー効果（マッチ時）
           if (isMatch) {
             for(let i=0; i<3; i++) {
               let gy = h.y + i;
               if (gy >= HIDDEN_ROWS) {
                 let px = h.x * cellSize + cellSize/2;
                 let py = (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
                 
                 this.p.noFill();
                 this.p.stroke(baseColor[0], baseColor[1], baseColor[2], pulseAlpha * 0.3);
                 this.p.strokeWeight(8);
                 this.p.rectMode(this.p.CENTER);
                 this.p.rect(px, py, cellSize, cellSize);
               }
             }
           }

           for(let i=0; i<3; i++) {
             let gy = h.y + i;
             if (gy >= HIDDEN_ROWS) {
               let px = h.x * cellSize + cellSize/2;
               let py = (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
               
               this.p.noFill();
               this.p.stroke(baseColor[0], baseColor[1], baseColor[2], strokeAlpha);
               this.p.strokeWeight(strokeW);
               this.p.rectMode(this.p.CENTER);
               this.p.rect(px, py, cellSize, cellSize);
               
               let type = h.blocks[i];
               if (gemImages[type]) {
                 if (isClearingMove) {
                   this.p.tint(255, 220, 180, imgAlpha);
                 } else {
                   this.p.tint(180, 255, 255, imgAlpha);
                 }
                 this.p.image(gemImages[type], px, py, cellSize*0.9, cellSize*0.9);
                 this.p.noTint();
               }
             }
           }
           
           // 手数とポテンシャル情報を表示（強調版）
           if (h.y >= HIDDEN_ROWS && idx === 0) {
             let tx = h.x * cellSize + cellSize/2;
             let ty = (h.y - HIDDEN_ROWS) * cellSize - 5;
             
             // 背景バッジ
             const badgeW = 80;
             const badgeH = isClearingMove ? 38 : 26;
             this.p.fill(0, 0, 0, isMatch ? 200 : 120);
             this.p.stroke(baseColor[0], baseColor[1], baseColor[2], isMatch ? 255 : 120);
             this.p.strokeWeight(2);
             this.p.rectMode(this.p.CENTER);
             this.p.rect(tx, ty - badgeH/2, badgeW, badgeH, 10);
             
             this.p.noStroke();
             this.p.textAlign(this.p.CENTER, this.p.CENTER);
             this.p.textStyle(this.p.BOLD);
             
             if (isClearingMove) {
               // 消去用の手（1手目）- シンプルな表現に変更
               this.p.fill(255, 180, 80, isMatch ? 255 : 150);
               this.p.textSize(14);
               this.p.text("まず消去", tx, ty - badgeH/2 - 6);
               this.p.fill(255, 220, 100, isMatch ? 255 : 150);
               this.p.textSize(12);
               this.p.text("目標:" + h.potential + "C", tx, ty - badgeH/2 + 8);
             } else {
               // セットアップ用の手 - シンプルな表現に変更
               this.p.fill(100, 255, 255, isMatch ? 255 : 150);
               this.p.textSize(14);
               // 「n手→nC」から「目標nC」のようにシンプルに
               this.p.text("目標:" + h.potential + "C", tx, ty - badgeH/2);
             }
             this.p.textStyle(this.p.NORMAL);
             
             // 「ここに置く」インジケーター
             if (isMatch) {
               this.p.fill(100, 255, 150, pulseAlpha);
               this.p.textSize(10);
               this.p.text("▼配置", tx, ty + 8);
             }
           }
        });
        this.p.pop();
      }
      
      // === 不要ブロック消去経路の表示（改良版）===
      if (this.isTraining && this.clearPathHints && this.clearPathHints.moves && this.clearPathHints.moves.length > 1) {
        this.p.push();
        const pathHint = this.clearPathHints;
        const futureMoves = pathHint.moves.slice(1); // 2手目以降
        const pulseAlpha = 150 + Math.sin(this.p.frameCount * 0.1) * 50;
        
        // 2手目以降のブロック配置をNextエリア横に表示
        futureMoves.forEach((move, moveIdx) => {
          if (moveIdx > 1) return; // 最大2手先まで表示
          
          const baseAlpha = moveIdx === 0 ? 200 : 120;
          const moveNumber = moveIdx + 2;
          
          // ===「NEXT」エリアの右下に2手目以降を表示===
          // Nextエリアの位置（boardWidth右側のエリア）を基準にする
          const nextAreaX = boardWidth + 10; // Nextエリアの開始X座標（画面外なので、フィールド内左上に表示）
          
          // フィールド左上角に2手目の情報を表示
          const infoBoxX = 5;
          const infoBoxY = 5 + moveIdx * 85;
          const infoBoxW = cellSize * 2.2;
          const infoBoxH = cellSize * 3.5;
          
          // 背景ボックス
          this.p.fill(20, 20, 40, baseAlpha * 0.7);
          this.p.stroke(180, 100, 255, baseAlpha);
          this.p.strokeWeight(2);
          this.p.rectMode(this.p.CORNER);
          this.p.rect(infoBoxX, infoBoxY, infoBoxW, infoBoxH, 5);
          
          // ラベル（「2手目」「3手目」など）
          this.p.fill(180, 100, 255, pulseAlpha);
          this.p.noStroke();
          this.p.textAlign(this.p.CENTER, this.p.TOP);
          this.p.textSize(11);
          this.p.textStyle(this.p.BOLD);
          this.p.text(moveNumber + "手目", infoBoxX + infoBoxW/2, infoBoxY + 3);
          
          // ブロック画像を表示
          if (move.blocks) {
            const blockStartY = infoBoxY + 18;
            const blockSize = cellSize * 0.65;
            for (let i = 0; i < 3; i++) {
              const bx = infoBoxX + infoBoxW/2;
              const by = blockStartY + i * blockSize + blockSize/2;
              const blockType = move.blocks[i];
              if (gemImages[blockType]) {
                this.p.tint(255, baseAlpha);
                this.p.image(gemImages[blockType], bx, by, blockSize, blockSize);
                this.p.noTint();
              }
            }
          }
          
          // 列番号を表示
          this.p.fill(255, 220, 100, baseAlpha);
          this.p.textAlign(this.p.CENTER, this.p.BOTTOM);
          this.p.textSize(10);
          this.p.text("▼列" + (move.x + 1), infoBoxX + infoBoxW/2, infoBoxY + infoBoxH - 2);
          this.p.textStyle(this.p.NORMAL);
          
          // フィールド上に矢印で配置位置を示す
          const targetX = move.x * cellSize + cellSize/2;
          const arrowY = 0;
          
          // 矢印（▼）
          this.p.fill(180, 100, 255, baseAlpha * 0.8);
          this.p.noStroke();
          this.p.triangle(
            targetX - 8, arrowY + 5,
            targetX + 8, arrowY + 5,
            targetX, arrowY + 18
          );
        });
        
        // === 経路全体の情報を上部バナーに表示（強調版）===
        const bannerH = 28;
        // グラデーション背景
        this.p.noStroke();
        for (let i = 0; i < bannerH; i++) {
          const gradAlpha = 180 - i * 3;
          this.p.fill(30, 20, 60, gradAlpha);
          this.p.rect(0, i, boardWidth, 1);
        }
        
        // メインテキスト（パルスアニメーション付き）- シンプルな表現に変更
        const comboTextSize = 14 + Math.sin(this.p.frameCount * 0.08) * 1;
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.textSize(comboTextSize);
        this.p.textStyle(this.p.BOLD);
        
        // アウトライン
        this.p.fill(0, 0, 0, 200);
        this.p.stroke(0);
        this.p.strokeWeight(4);
        // 「n手→nC」から「あとn手でnC」のようにシンプルで分かりやすく
        const comboText = pathHint.stepsToCombo + "手で" + pathHint.finalChain + "C!";
        this.p.text(comboText, boardWidth/2 + 1, bannerH/2 + 1);
        
        // メインカラー（ゴールド〜オレンジグラデ）
        const hueShift = (this.p.frameCount * 2) % 60;
        this.p.fill(255, 200 + hueShift, 50, 255);
        this.p.stroke(255, 150, 0);
        this.p.strokeWeight(1);
        this.p.text(comboText, boardWidth/2, bannerH/2);
        this.p.textStyle(this.p.NORMAL);
        
        // === コンボルート視覚化（clearPathHintsの場合）===
        if (showComboRouteVisualization && pathHint.chainSteps && pathHint.chainSteps.length > 0) {
          // プレイヤーのブロック並び順が一致しているかチェック
          let isFirstMoveMatch = false;
          if (this.currentPiece && pathHint.moves && pathHint.moves.length > 0) {
            isFirstMoveMatch = true;
            for(let k=0; k<3; k++) {
              if (pathHint.moves[0].blocks[k] !== this.currentPiece.blocks[k]) {
                isFirstMoveMatch = false;
                break;
              }
            }
          }
          if (isFirstMoveMatch) {
            this.drawComboRouteVisualization(pathHint.chainSteps, pathHint.moves[pathHint.moves.length-1].x, pathHint.moves[pathHint.moves.length-1].y);
          }
        }
        
        this.p.pop();
      }

      // AI Intent Visualization
      this.drawAIIntent();

      // Current Piece
      if (this.state === 'PLAYING' && this.currentPiece) {
        for (let i = 0; i < 3; i++) {
          let logicalY = this.currentPiece.y + i;
          
          let vx = this.currentPiece.visualX;
          let vy = this.currentPiece.visualY + i;
          
          let px = vx * cellSize + cellSize/2;
          let py = (vy - HIDDEN_ROWS) * cellSize + cellSize/2;

          if (logicalY < ROWS) {
             let isHidden = logicalY < HIDDEN_ROWS;
             let drawAlpha = isHidden ? 128 : 255;
             this.drawBlock(0, 0, this.currentPiece.blocks[i], 1, drawAlpha, false, true, px, py);
          }
        }
      }

      // Particles
      this.updateAndDrawParticles(isPaused);
      
      // Fireworks
      this.updateAndDrawFireworks(isPaused);

      // Combo
      if (this.comboCount >= 2) {
        this.p.push();
        this.p.translate(boardWidth / 2, boardHeight / 2);
        
        // 幻想的な演出のためにADDブレンドとHSBを使用
        this.p.blendMode(this.p.ADD);
        this.p.colorMode(this.p.HSB, 360, 100, 100, 100);
        
        let s = Math.max(1.0, this.comboScale);
        // サイズ調整: フィールド幅に合わせて計算 (文字がはみ出さないように)
        let baseSize = boardWidth * 0.18; 
        let textSize = baseSize * s;
        
        let hue = (this.p.frameCount * 2 + this.comboCount * 20) % 360;
        
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.textStyle(this.p.BOLD);
        this.p.textSize(textSize);
        
        // 振動効果 (コンボ数が増えると激しく)
        let shakeAmt = (this.comboCount - 1) * 0.5 * (s - 0.8);
        let shakeX = this.p.random(-shakeAmt, shakeAmt);
        let shakeY = this.p.random(-shakeAmt, shakeAmt);
        this.p.translate(shakeX, shakeY);

        // 回転アニメーション (ゆっくり)
        this.p.rotate(Math.sin(this.p.frameCount * 0.05) * 0.05);

        // 1. 光の輪 (背景装飾)
        this.p.noFill();
        this.p.strokeWeight(2);
        let ringSize = boardWidth * 0.7 * s;
        
        this.p.push();
        this.p.rotate(this.p.frameCount * 0.02);
        this.p.stroke(hue, 60, 100, 50);
        this.p.arc(0, 0, ringSize, ringSize, 0, this.p.PI * 1.2);
        this.p.stroke((hue + 180) % 360, 60, 100, 50);
        this.p.arc(0, 0, ringSize * 0.8, ringSize * 0.8, this.p.PI, this.p.PI * 2.2);
        this.p.pop();

        // 2. テキストのグロー効果 (多重描画)
        this.p.noStroke();
        // 外側のぼんやりした光
        for(let i=3; i>0; i--) {
            this.p.fill(hue, 80, 100, 30 / i);
            this.p.textSize(textSize * (1 + i * 0.1));
            this.p.text("SYNC " + this.comboCount, 0, 0);
        }
        
        // メインテキスト
        this.p.textSize(textSize);
        // 縁取り
        this.p.strokeWeight(4);
        this.p.stroke(hue, 90, 80, 80);
        this.p.fill(0, 0, 100, 100); // 白
        this.p.text("SYNC " + this.comboCount, 0, 0);
        
        this.p.textSize(textSize * 0.4);
        this.p.text("OPTIMIZED", 0, textSize * 0.8);
        
        // 3. キラキラパーティクル装飾
        this.p.strokeWeight(3);
        for(let i=0; i<4; i++) {
            let angle = this.p.frameCount * 0.1 + (i * this.p.TWO_PI / 4);
            let dist = ringSize * 0.6 + Math.sin(this.p.frameCount * 0.2) * 10;
            let px = Math.cos(angle) * dist;
            let py = Math.sin(angle) * dist;
            this.p.stroke((hue + i * 90) % 360, 40, 100, 80);
            this.p.point(px, py);
        }
        
        this.p.pop();
        this.p.colorMode(this.p.RGB);
        this.p.blendMode(this.p.BLEND);
        if (!isPaused && this.comboScale > 1) this.comboScale -= 0.05;
      }

      // Garbage Warning
      if (this.garbageQueue > 0) {
        this.p.push();
        this.p.translate(boardWidth / 2, boardHeight);
        
        let alpha = 150 + 100 * this.p.sin(this.p.frameCount * 0.2);
        this.p.fill(255, 0, 0, alpha * 0.3);
        this.p.noStroke();
        this.p.rectMode(this.p.CENTER);
        this.p.rect(0, -20, boardWidth, 40);
        
        this.p.fill(255, 50, 50);
        this.p.stroke(255);
        this.p.strokeWeight(3);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.textSize(24);
        this.p.textStyle(this.p.BOLD);
        this.p.text(`⚠️ +${this.garbageQueue}`, 0, -20);
        this.p.rectMode(this.p.CORNER);
        this.p.pop();
      }

      // Item Get Effects
      this.updateAndDrawItemGetEffects(isPaused);
      
      // Item Use Effects
      this.updateAndDrawItemUseEffects(isPaused);

      this.drawWarningOverlay();

      this.p.pop();
    }

    // --- アイテム・コンボロジック ---
    triggerItemGetEffect(type) {
      let color = type === 'P' ? '#FF69B4' : (type === 'R' ? '#00FFFF' : (type === 'C' ? '#FFD700' : '#8A2BE2'));
      let particles = [];
      // 軽量化: パーティクル数を削減 (12→6)
      for(let i=0; i<6; i++) {
        let angle = (this.p.TWO_PI / 6) * i;
        let dist = 150;
        particles.push({
          angle: angle,
          dist: dist,
          size: this.p.random(4, 8),
          speed: this.p.random(0.12, 0.18)
        });
      }

      this.itemGetEffects.push({
        type: type,
        life: 1.0,
        particles: particles,
        color: color,
        scale: 0
      });
      
      if (!this.isCpu) {
        audio.playItemGet();
      }
    }

    updateAndDrawItemGetEffects(isPaused) {
      for (let i = this.itemGetEffects.length - 1; i >= 0; i--) {
        let effect = this.itemGetEffects[i];
        
        if (!isPaused) {
          effect.life -= 0.015;
          if (effect.life > 0.8) {
            effect.scale = this.p.lerp(effect.scale, 1.2, 0.1);
          } else {
            effect.scale = this.p.lerp(effect.scale, 1.0, 0.1);
          }
        }

        if (effect.life <= 0) {
          this.itemGetEffects.splice(i, 1);
          continue;
        }

        let cx = boardWidth / 2;
        let cy = boardHeight / 2;
        
        this.p.push();
        this.p.translate(cx, cy);
        this.p.blendMode(this.p.ADD);
        
        // 1. 収束する六角形パーティクル
        let c = this.p.color(effect.color);
        c.setAlpha(effect.life * 255);
        this.p.fill(c);
        this.p.noStroke();
        
        effect.particles.forEach(pt => {
          if (!isPaused) {
             pt.dist = this.p.lerp(pt.dist, 0, pt.speed);
          }
          
          let px = Math.cos(pt.angle) * pt.dist;
          let py = Math.sin(pt.angle) * pt.dist;
          
          this.p.push();
          this.p.translate(px, py);
          this.p.rotate(this.p.frameCount * 0.1);
          this.p.beginShape();
          for(let k=0; k<6; k++) {
             let a = k * this.p.TWO_PI / 6;
             this.p.vertex(Math.cos(a)*pt.size, Math.sin(a)*pt.size);
          }
          this.p.endShape(this.p.CLOSE);
          
          // Trail
          if (pt.dist > 30) {
             this.p.stroke(c);
             this.p.strokeWeight(1);
             this.p.line(0, 0, -Math.cos(pt.angle)*20, -Math.sin(pt.angle)*20);
             this.p.noStroke();
          }
          this.p.pop();
        });

        // 2. 中央のアイコン表示
        this.p.scale(effect.scale);
        
        // 背景の六角形枠
        this.p.noFill();
        this.p.stroke(c);
        this.p.strokeWeight(2);
        this.p.push();
        this.p.rotate(this.p.frameCount * 0.02);
        this.p.beginShape();
        let r = cellSize * 3.0;
        for(let k=0; k<6; k++) {
           let a = k * this.p.TWO_PI / 6;
           this.p.vertex(Math.cos(a)*r, Math.sin(a)*r);
        }
        this.p.endShape(this.p.CLOSE);
        this.p.pop();

        // アイコン
        let imgIndex = effect.type === 'P' ? 7 : (effect.type === 'R' ? 8 : (effect.type === 'C' ? 9 : 10));
        if (gemImages[imgIndex]) {
          this.p.tint(255, effect.life * 255);
          this.p.image(gemImages[imgIndex], 0, 0, cellSize * 2.5, cellSize * 2.5);
        }
        
        // テキスト
        this.p.textAlign(this.p.CENTER, this.p.BOTTOM);
        this.p.textSize(20);
        this.p.textStyle(this.p.BOLD);
        this.p.fill(c);
        this.p.noStroke();
        this.p.text("MODULE ACQUIRED", 0, -cellSize * 3.2);
        this.p.textSize(40);
        this.p.text(effect.type, 0, -cellSize * 2.0);
        
        this.p.pop();
      }
    }

    triggerItemUseEffect(type) {
      let color = type === 'P' ? '#FF69B4' : (type === 'R' ? '#00FFFF' : (type === 'C' ? '#FFD700' : (type === 'S' ? '#8A2BE2' : '#FF0000')));
      
      // Generate binary particles (軽量化: 24→12)
      let particles = [];
      for(let i=0; i<12; i++) {
        particles.push({
          angle: this.p.random(this.p.TWO_PI),
          dist: 20,
          speed: this.p.random(4, 10),
          char: this.p.random() < 0.5 ? '0' : '1'
        });
      }

      this.itemUseEffects.push({
        type: type,
        life: 1.0,
        maxLife: 50, // 軽量化: 60→50
        frame: 0,
        particles: particles,
        color: color
      });
      
      if (!this.isCpu) this.stats.itemsUsed++;
    }

    updateAndDrawItemUseEffects(isPaused) {
      for (let i = this.itemUseEffects.length - 1; i >= 0; i--) {
        let effect = this.itemUseEffects[i];
        
        if (!isPaused) {
          effect.frame++;
          effect.life = 1.0 - (effect.frame / effect.maxLife);
          
          // Update particles
          effect.particles.forEach(p => {
            p.dist += p.speed;
            p.speed *= 0.92;
          });
        }

        if (effect.life <= 0) {
          this.itemUseEffects.splice(i, 1);
          continue;
        }

        let cx = boardWidth / 2;
        let cy = boardHeight / 2;
        let t = effect.frame;
        
        this.p.push();
        this.p.translate(cx, cy);
        this.p.blendMode(this.p.ADD);
        
        let c = this.p.color(effect.color);
        
        // 1. Rotating Cyber Rings
        this.p.noFill();
        
        // Outer Hexagon
        let hexSize = 100 + t * 2;
        let alphaHex = Math.sin(effect.life * Math.PI) * 200;
        c.setAlpha(alphaHex);
        this.p.stroke(c);
        this.p.strokeWeight(2);
        
        this.p.push();
        this.p.rotate(t * 0.03);
        this.p.beginShape();
        for(let k=0; k<6; k++) {
           let a = k * this.p.TWO_PI / 6;
           this.p.vertex(Math.cos(a)*hexSize, Math.sin(a)*hexSize);
        }
        this.p.endShape(this.p.CLOSE);
        this.p.pop();

        // Inner Tech Circle (Dashed)
        this.p.push();
        this.p.rotate(-t * 0.05);
        this.p.strokeWeight(3);
        this.p.drawingContext.setLineDash([15, 25]);
        this.p.ellipse(0, 0, 140);
        this.p.drawingContext.setLineDash([]);
        this.p.pop();

        // 2. Binary Data Explosion
        this.p.textSize(14);
        this.p.noStroke();
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        effect.particles.forEach(p => {
           let pa = effect.life * 255;
           c.setAlpha(pa);
           this.p.fill(c);
           let px = Math.cos(p.angle) * p.dist;
           let py = Math.sin(p.angle) * p.dist;
           this.p.text(p.char, px, py);
        });
        
        // 3. Central Hologram Text
        let scale = Math.min(1.0, t / 10) * (1.0 + Math.sin(t * 0.2) * 0.1);
        this.p.scale(scale);
        
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.textSize(60);
        this.p.textStyle(this.p.BOLD);
        c.setAlpha(effect.life * 255);
        this.p.fill(c);
        this.p.noStroke();
        
        // Glitch Text Effect
        let displayText = effect.type;
        if (this.p.random() < 0.15) {
           // Random char glitch
           displayText = String.fromCharCode(65 + Math.floor(Math.random() * 26));
           this.p.fill(255); // Flash white
        }
        this.p.text(displayText, 0, 0);
        
        // Subtitle (Protocol Name)
        this.p.textSize(16);
        this.p.fill(255, 255, 255, effect.life * 200);
        let label = "EXECUTING PROTOCOL";
        if (effect.type === 'REVIVE') label = "SYSTEM REBOOT";
        else if (effect.type === 'S') label = "SWAPPING MATRIX";
        else if (effect.type === 'C') label = "CLEARING CACHE";
        else if (effect.type === 'R') label = "INVERTING GRAVITY";
        else if (effect.type === 'P') label = "PRISM BREAK";
        
        this.p.text(label, 0, 50);
        
        // 4. Scanline
        c.setAlpha(150);
        this.p.stroke(c);
        this.p.strokeWeight(2);
        let scanY = (t * 8) % 100 - 50;
        this.p.line(-60, scanY, 60, scanY);
        
        this.p.pop();
      }
    }

    // --- ブロック描画 ---
    drawBlock(gx, gy, type, scale = 1, alpha = 255, useBounce = false, forceRender = false, overrideX = null, overrideY = null) {
      if (gy < HIDDEN_ROWS && !forceRender) return;
      
      let x = overrideX !== null ? overrideX - cellSize/2 : gx * cellSize;
      let y = overrideY !== null ? overrideY - cellSize/2 : (gy - HIDDEN_ROWS) * cellSize;

      if (useBounce && !overrideX && this.bounceState[gx] && this.bounceState[gx][gy]) {
        y += this.bounceState[gx][gy].y;
      }

      if (!forceRender && y < -cellSize) return;

      let cx = x + cellSize / 2;
      let cy = y + cellSize / 2;
      let size = cellSize * 1.0 * scale;

      let isPenalty = type > 100;
      let drawType = isPenalty ? type - 100 : type;

      // Optimization: Draw directly without push/pop/translate
      if (gemImages[drawType]) {
        if (alpha < 255) {
            this.p.tint(255, alpha);
            this.p.image(gemImages[drawType], cx, cy, size, size);
            this.p.noTint();
        } else {
            this.p.image(gemImages[drawType], cx, cy, size, size);
        }
      }

      if (isPenalty) {
        // Penalty Mark Design Update
        let t = this.p.frameCount * 0.05;
        let pulse = (Math.sin(t) + 1) * 0.5;
        let pAlpha = this.p.lerp(100, 240, pulse);
        if (alpha < 255) pAlpha = Math.min(pAlpha, alpha);

        this.p.rectMode(this.p.CENTER);
        this.p.noStroke();
        
        // Shadow
        this.p.fill(0, 0, 0, pAlpha * 0.2); // Shadow
        this.p.rect(cx + 2, cy + 2, size, size, 6);
        
        // Base
        this.p.fill(60, 65, 70, pAlpha * 0.3); // Base
        this.p.stroke(120, 125, 130, pAlpha * 0.8); // Edge
        this.p.strokeWeight(2);
        this.p.rect(cx, cy, size, size, 6);

        // X Mark (No shadowBlur)
        this.p.stroke(245, 222, 179, pAlpha);
        this.p.strokeWeight(size * 0.15);
        this.p.strokeCap(this.p.ROUND);
        let xSize = size * 0.35;
        this.p.line(cx - xSize, cy - xSize, cx + xSize, cy + xSize);
        this.p.line(cx + xSize, cy - xSize, cx - xSize, cy + xSize);
        
        // Highlight
        this.p.stroke(255, 255, 255, pAlpha * 0.8);
        this.p.strokeWeight(size * 0.05);
        this.p.line(cx - xSize, cy - xSize, cx + xSize, cy + xSize);
        this.p.line(cx + xSize, cy - xSize, cx - xSize, cy + xSize);
      }
    }

    // --- アイテム報酬決定 ---
    determineItemReward() {
      if (this.itemStock.length >= 7) return;

      let r = this.p.random();
      let itemType = null;

      if (this.comboCount >= 6) {
        if (isTrainingMode) {
          if (r < 0.5) itemType = 'C';
          else itemType = 'P';
        } else {
          if (r < 0.3) itemType = 'C';
          else if (r < 0.7) itemType = 'P';
          else itemType = 'S';
        }
      } else if (this.comboCount === 5) {
        if (isTrainingMode) {
          itemType = 'P';
        } else {
          if (r < 0.5) itemType = 'P';
          else if (r < 0.7) itemType = 'S';
        }
      } else if (this.comboCount === 4) {
        if (isTrainingMode) {
          if (r < 0.3) itemType = 'R';
        } else {
          if (r < 0.3) itemType = 'R';
          else if (r < 0.4) itemType = 'S';
        }
      } else if (this.comboCount === 3) {
        if (r < 0.2) itemType = 'R';
      } else if (this.comboCount === 2) {
        if (r < 0.15) itemType = 'R';
      }

      if (itemType) {
        this.itemStock.push(itemType);
        this.triggerItemGetEffect(itemType);
      }
    }

    // --- アイテム効果: スワップ ---
    performSwap(opponent) {
      if (!opponent) return;

      // 1. Swap Grid (Rows 12-22, indices 11-22 are visible bottom part? No, indices 12-22 are bottom 11 rows)
      // Visible rows: 8 to 22.
      // "1段目" is index 22. "11段目" is index 12.
      // Swap range: 12 to 22.
      for (let x = 0; x < COLS; x++) {
        for (let y = 12; y < ROWS; y++) {
          let temp = this.grid[x][y];
          this.grid[x][y] = opponent.grid[x][y];
          opponent.grid[x][y] = temp;
        }
        // Clear Rows 12+ (Indices 0-11)
        for (let y = 0; y < 12; y++) {
          this.grid[x][y] = 0;
          opponent.grid[x][y] = 0;
        }
      }

      // 2. Swap Combo & Animation State
      let tempCombo = this.comboCount;
      this.comboCount = opponent.comboCount;
      opponent.comboCount = tempCombo;

      let tempState = this.state;
      this.state = opponent.state;
      opponent.state = tempState;

      let tempRemoving = this.removingBlocks;
      this.removingBlocks = opponent.removingBlocks;
      opponent.removingBlocks = tempRemoving;

      let tempTimer = this.animationTimer;
      this.animationTimer = opponent.animationTimer;
      opponent.animationTimer = tempTimer;

      // 3. Handle Collision & Piece State
      this.handleSwapCollision();
      opponent.handleSwapCollision();

      if (!this.isCpu) audio.playAttack();
    }

    handleSwapCollision() {
      if (this.state === 'ANIMATING') {
        // Received an animating field: wait at emission
        this.currentPiece = null;
      } else if (this.state === 'PLAYING') {
        // Force respawn to prevent getting stuck in blocks
        // Received a static field, ensure fresh piece
        this.spawnPiece();
      }
    }

    // --- アイテム操作 ---
    swapItems() {
      if (this.itemStock.length <= 1) return;
      // Move first to last (cycle)
      this.itemStock.push(this.itemStock.shift());
    }

    // --- アニメーション更新 ---
    updateAnimation() {
      // 2コンボ毎に30ms遅く、最大90ms (基本45F=750ms)
      const baseMs = 750;
      const delayMs = Math.min(Math.floor(this.comboCount / 2) * 30, 90);
      const speed = baseMs / (baseMs + delayMs);

      this.animationTimer += speed;
      if (this.animationTimer > 45) {
        if (this.removingBlocks.length > 0) {
          // コンボ倍率: 1連鎖=1.0, 2連鎖=1.5, 3連鎖=2.0, ... (0.5ずつ増加)
          let comboMultiplier = 1.0 + this.comboCount * 0.5;
          let points = this.removingBlocks.length * comboMultiplier;
          this.attackGauge += points;
          while (this.attackGauge >= 15) {
            this.attackGauge -= 15;
            if (this.onCombo) this.onCombo(1);
          }
        }

        let clearedCount = this.removingBlocks.length;
        this.removingBlocks.forEach(b => {
          this.grid[b.x][b.y] = 0;
          if (b.isMagic) {
            this.createMagicParticles(b.x, b.y, b.type);
          } else {
            this.createParticles(b.x, b.y, b.type);
          }
          
          // Unseal neighbors
          const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          dirs.forEach(([dx, dy]) => {
            let nx = b.x + dx;
            let ny = b.y + dy;
            if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
              if (this.grid[nx][ny] > 100) {
                this.grid[nx][ny] -= 100;
                this.createUnsealEffect(nx, ny);
              }
            }
          });
        });
        this.removingBlocks = [];
        this.applyGridGravity();
        
        this.comboCount++;
        if (this.comboCount > this.maxCombo) this.maxCombo = this.comboCount;
        this.totalBlocksCleared += clearedCount;
        if (!this.isCpu) audio.playCombo(this.comboCount, this.opponentIsDevil);
        if (this.comboCount >= 2) this.spawnFirework(this.boardX + boardWidth/2, this.boardY + boardHeight/3);

        let matches = this.findMatches();
        if (matches.length > 0) {
          this.removingBlocks = matches;
          this.animationTimer = 0;
          this.comboScale = 2.0;
          this.comboGraceTimer = 0;

        } else {
          this.state = 'PLAYING';
          this.comboGraceTimer = 60;
          this.spawnPiece();
        }
      }
    }

    // --- ブロック移動・操作 ---
    movePiece(dx, dy) {
      if (!this.currentPiece) return false;
      let nextX = this.currentPiece.x + dx;
      let nextY = this.currentPiece.y + dy;
      if (this.isValid(nextX, nextY)) {
        this.currentPiece.x = nextX;
        this.currentPiece.y = nextY;
        if (!this.isCpu) this.stats.moves++;
        // 高速タップ対策：lockDelayTimerのリセット回数を制限
        // 左右移動(dx!=0)でのみリセット回数をカウント、上限に達したらリセットしない
        if (this.lockDelayTimer > 0 && dx !== 0) {
          if (this.lockResetCount < this.LOCK_RESET_LIMIT) {
            this.lockDelayTimer = 0;
            this.lockResetCount++;
          }
          // リセット上限に達している場合はlockDelayTimerを維持
        } else if (this.lockDelayTimer > 0 && dy !== 0) {
          // 下移動ではリセット回数制限なし
          this.lockDelayTimer = 0;
        }
        return true;
      } else if (dy > 0) {
        return false;
      }
      return false;
    }

    hardDrop() {
      if (!this.currentPiece) return;
      while (this.isValid(this.currentPiece.x, this.currentPiece.y + 1)) {
        this.currentPiece.y++;
      }
      this.lockPiece();
    }

    isValid(x, y) {
      if (x < 0 || x >= COLS) return false;
      for (let i = 0; i < 3; i++) {
        if (this.currentPiece && this.currentPiece.blocks[i] === 0) continue;
        let by = y + i;
        if (by < 0) continue;
        if (by >= ROWS) return false;
        if (this.grid[x][by] !== 0) return false;
      }
      return true;
    }

    // --- ブロック回転 ---
    rotatePiece() {
      if (!this.currentPiece) return;
      if (this.currentPiece.blocks.includes(7)) return;
      let last = this.currentPiece.blocks.pop();
      this.currentPiece.blocks.unshift(last);
      if (!this.isCpu) this.stats.rotates++;
    }

    // --- ブロック固定・判定 ---
    lockPiece() {
      // Check for Item P
      if (this.currentPiece.blocks.includes(7)) {
        let pIndex = this.currentPiece.blocks.indexOf(7);
        let py = this.currentPiece.y + pIndex;
        let px = this.currentPiece.x;
        
        let targetType = 0;
        if (px >= 0 && px < COLS && py + 1 >= 0 && py + 1 < ROWS) {
          targetType = this.grid[px][py+1];
        }

        this.currentPiece = null;
        
        if (targetType && targetType !== 0) {
          // 手動操作による発動なので、既存のコンボはここで終了・リセット
          if (this.comboCount > 0) {
            this.determineItemReward();
            this.comboCount = 0;
          }
          if (targetType > 100) {
            let unsealed = false;
            for (let x = 0; x < COLS; x++) {
              for (let y = 0; y < ROWS; y++) {
                if (this.grid[x][y] > 100) {
                  this.grid[x][y] -= 100;
                  this.createUnsealEffect(x, y);
                  unsealed = true;
                }
              }
            }
            if (unsealed && !this.isCpu) audio.playAttack();
            
            let matches = this.findMatches();
            if (matches.length > 0) {
              this.state = 'ANIMATING';
              this.removingBlocks = matches;
              this.animationTimer = 0;
              this.comboScale = 2.0;
              this.comboGraceTimer = 0;
            } else {
              this.spawnPiece();
            }
          } else {
            let matches = this.findMatchesByType(targetType);
            if (matches.length > 0) {
              this.state = 'ANIMATING';
              this.removingBlocks = matches.map(m => ({...m, isMagic: true}));
              this.animationTimer = 0;
              if (!this.isCpu) audio.playAttack();
            } else {
              this.spawnPiece();
            }
          }
        } else {
          this.spawnPiece();
        }
        return;
      }

      for (let i = 0; i < 3; i++) {
        let by = this.currentPiece.y + i;
        if (by < 0) continue;
        this.grid[this.currentPiece.x][by] = this.currentPiece.blocks[i];
      }
      this.currentPiece = null;
      if (!this.isCpu) audio.playDrop(this.opponentIsDevil);
      
      if (!this.isCpu) {
        this.stats.drops++;
        let thinkTime = Date.now() - this.pieceStartTime;
        this.stats.totalThinkTime += thinkTime;
      }

      let matches = this.findMatches();
      
      // 手動操作による設置なので、既存のコンボはここで終了・リセット
      if (this.comboCount > 0) {
        this.determineItemReward();
        this.comboCount = 0;
      }

      if (matches.length > 0) {
        this.state = 'ANIMATING';
        this.removingBlocks = matches;
        this.animationTimer = 0;
        this.comboScale = 2.0;
        this.comboGraceTimer = 0;

      } else {
        if (this.grid[4][HIDDEN_ROWS] !== 0) {
          this.triggerGameOverGrace();
          return;
        }
        this.spawnPiece();
      }
      this.comboGraceTimer = 0;
    }

    // --- フィールド全消去 ---
    clearField(isBombing = false) {
      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          if (this.grid[x][y] !== 0) {
            this.createParticles(x, y, this.grid[x][y], isBombing);
            this.grid[x][y] = 0;
          }
        }
      }
      if (!this.isCpu) audio.playAttack();
    }

    triggerCollapse() {
      this.state = 'COLLAPSING';
      this.collapseTimer = 0;
      screenShake = 20;
      
      if (!this.isCpu) audio.playMissileHit(0);
      else audio.playMissileHit(1);

      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          if (this.grid[x][y] !== 0) {
            let type = this.grid[x][y];
            let px = x * cellSize + cellSize/2;
            let py = (y - HIDDEN_ROWS) * cellSize + cellSize/2;
            
            this.collapseParticles.push({
              x: px, y: py,
              vx: this.p.random(-8, 8),
              vy: this.p.random(-15, -5),
              rotation: this.p.random(this.p.TWO_PI),
              vRotation: this.p.random(-0.3, 0.3),
              type: type,
              gravity: 0.8,
              life: 1.0,
              delay: this.p.floor(this.p.random(0, 10))
            });
            this.grid[x][y] = 0;
          }
        }
      }
      
      if (this.currentPiece) {
         for(let i=0; i<3; i++) {
            let type = this.currentPiece.blocks[i];
            if (type !== 0) {
                let px = this.currentPiece.x * cellSize + cellSize/2;
                let py = (this.currentPiece.y + i - HIDDEN_ROWS) * cellSize + cellSize/2;
                this.collapseParticles.push({
                  x: px, y: py,
                  vx: this.p.random(-8, 8), vy: this.p.random(-15, -5),
                  rotation: this.p.random(this.p.TWO_PI), vRotation: this.p.random(-0.3, 0.3),
                  type: type, gravity: 0.8, life: 1.0, delay: 0
                });
            }
         }
         this.currentPiece = null;
      }
    }

    updateCollapse() {
      this.collapseTimer++;
      for (let i = this.collapseParticles.length - 1; i >= 0; i--) {
        let p = this.collapseParticles[i];
        if (p.delay > 0) { p.delay--; continue; }
        p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.rotation += p.vRotation; p.life -= 0.005;
        if (p.y > boardHeight + 200 || p.life <= 0) this.collapseParticles.splice(i, 1);
      }
      if (this.collapseParticles.length === 0 || this.collapseTimer > 240) this.state = 'GAMEOVER';
    }

    drawCollapse() {
      this.collapseParticles.forEach(p => {
         if (p.delay > 0) {
             this.drawBlock(0, 0, p.type, 1, 255, false, true, p.x, p.y); 
             return;
         }
         let size = cellSize * 1.0;
         let type = p.type > 100 ? p.type - 100 : p.type;
         this.p.push();
         this.p.translate(p.x, p.y);
         this.p.rotate(p.rotation);
         if (this.p.frameCount % 3 === 0) {
             this.p.noFill();
             this.p.stroke(p.type > 100 ? '#FF0000' : COLORS.gems[type] || '#FFF');
             this.p.strokeWeight(1);
             this.p.rectMode(this.p.CENTER);
             this.p.rect(0, 0, size, size);
         }
         if (gemImages[type]) {
            this.p.tint(255, p.life * 255);
            this.p.image(gemImages[type], 0, 0, size, size);
         }
         if (p.type > 100) {
            // Collapse Penalty Design
            this.p.fill(60, 65, 70, 100);
            this.p.stroke(120, 125, 130, 200);
            this.p.strokeWeight(2);
            this.p.rect(0, 0, size, size, 5);

            this.p.stroke(245, 222, 179, 200);
            this.p.strokeWeight(size * 0.15);
            this.p.strokeCap(this.p.ROUND);
            let xSize = size * 0.35;
            this.p.line(-xSize, -xSize, xSize, xSize); this.p.line(xSize, -xSize, -xSize, xSize);
            this.p.stroke(255, 255, 255, 200);
            this.p.strokeWeight(size * 0.05);
            this.p.line(-xSize, -xSize, xSize, xSize); this.p.line(xSize, -xSize, -xSize, xSize);
         }
         this.p.pop();
      });
    }

    // --- 復活トリガー ---
    triggerRevival() {
      this.hasRevived = true;
      this.revivalCount++;
      isReviving = true;
      revivalTimer = 0;
    }

    // --- マッチング判定 ---
    findMatches(checkGrid) {
      const grid = checkGrid || this.grid;
      const matchedFlags = this.matchBuffer;
      matchedFlags.fill(0);
      let hasMatch = false;
      const dirs = [{x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 1, y: -1}];

      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          const type = grid[x][y];
          if (!type || type > 100) continue;

          for (let d = 0; d < 4; d++) {
            const dir = dirs[d];
            let k = 1;
            while (true) {
              const nx = x + dir.x * k;
              const ny = y + dir.y * k;
              if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && grid[nx][ny] === type) {
                k++;
              } else {
                break;
              }
            }
            
            if (k >= 3) {
              hasMatch = true;
              for (let m = 0; m < k; m++) {
                matchedFlags[(x + dir.x * m) * ROWS + (y + dir.y * m)] = 1;
              }
            }
          }
        }
      }

      if (!hasMatch) return [];

      const result = [];
      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          if (matchedFlags[x * ROWS + y]) {
            result.push({x, y, type: grid[x][y]});
          }
        }
      }
      return result;
    }
    
    findMatchesByType(targetType) {
      let result = [];
      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          let t = this.grid[x][y];
          // 罰マーク（×）が付いたブロック（t > 100）は除外する
          // アイテムPは×マークが付与されていない同種のブロックのみをクリア
          if (t > 100) continue;
          if (t === targetType) {
            result.push({x, y, type: this.grid[x][y]});
          }
        }
      }
      return result;
    }

    // --- 重力処理 ---
    applyGridGravity() {
      for (let x = 0; x < COLS; x++) {
        let writeY = ROWS - 1;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (this.grid[x][y] !== 0) {
            this.grid[x][writeY] = this.grid[x][y];
            if (writeY !== y) {
              this.grid[x][y] = 0;
              this.bounceState[x][writeY].vy = -4;
            }
            writeY--;
          }
        }
        while (writeY >= 0) {
          this.grid[x][writeY] = 0;
          writeY--;
        }
      }
    }

    // --- フィールド反転 ---
    reverseField() {
      let wasAnimating = false;
      if (this.state === 'ANIMATING') {
        this.removingBlocks = [];
        this.state = 'PLAYING';
        this.animationTimer = 0;
        wasAnimating = true;
      }

      for (let x = 0; x < COLS; x++) {
        let col = [];
        for (let y = 0; y < ROWS; y++) col.push(this.grid[x][y]);
        col.reverse();
        for (let y = 0; y < ROWS; y++) this.grid[x][y] = col[y];
      }
      this.applyGridGravity();
      
      // Check for matches after reversal
      let matches = this.findMatches();
      if (matches.length > 0) {
        this.state = 'ANIMATING';
        this.removingBlocks = matches;
        this.animationTimer = 0;
        this.comboScale = 2.0;
        this.comboGraceTimer = 0;
      } else {
        if (wasAnimating) {
           this.state = 'PLAYING';
           this.comboGraceTimer = 60;
           this.spawnPiece();
        }
      }

      if (!this.isCpu) audio.playAttack();
    }

    // --- お邪魔ブロック・攻撃 ---
    addGarbageLines(lines) {
      this.garbageQueue += lines;
    }
    
    applyMissileDamage(tx, ty, revivalCount = 0) {
      let isHelpful = false;

      if (revivalCount === 1) {
        // Phase 2: 30% chance to clear (Helpful), 70% chance to mark (Harmful)
        isHelpful = this.p.random() < 0.3;
      } else if (revivalCount >= 2) {
        // Phase 3: 20% chance to clear (Helpful), 80% chance to mark (Harmful)
        isHelpful = this.p.random() < 0.2;
      } else {
        // Phase 1: 100% chance to mark (Harmful)
        isHelpful = false;
      }

      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          let nx = tx + dx;
          let ny = ty + dy;
          if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
            if (this.grid[nx][ny] !== 0) {
              if (isHelpful) {
                // Clear block
                this.createParticles(nx, ny, this.grid[nx][ny]);
                this.grid[nx][ny] = 0;
              } else if (this.grid[nx][ny] <= 100) {
                // Apply penalty mark
                this.grid[nx][ny] += 100; 
                this.createParticles(nx, ny, this.grid[nx][ny]);
              }
            }
          }
        }
      }

      if (isHelpful) {
        this.applyGridGravity();
      }
    }

    applyLaserDamage(col, isHelpful = false) {
      for (let y = 0; y < ROWS; y++) {
        if (this.grid[col][y] !== 0) {
          if (isHelpful) {
            this.createParticles(col, y, this.grid[col][y]);
            this.grid[col][y] = 0;
          } else if (this.grid[col][y] <= 100) {
            this.grid[col][y] += 100; // Apply penalty
            this.createParticles(col, y, this.grid[col][y]);
          }
        }
      }
      if (isHelpful) this.applyGridGravity();
    }

    processGarbage() {
      let processed = false;
      while (this.garbageQueue > 0) {
        processed = true;
        this.garbageQueue--;
        
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS - 1; y++) {
            this.grid[x][y] = this.grid[x][y+1];
          }
          let newType = this.p.floor(this.p.random(1, BLOCK_TYPES + 1));
          if (this.p.random() < 0.5) newType += 100;
          this.grid[x][ROWS-1] = newType;
        }
        
        if (this.currentPiece) {
          this.currentPiece.y--;
        }
      }
      if (processed && this.isCpu) {
        this.aiTargetX = null;
      }
    }

    // --- エフェクト生成 ---
    createParticles(gx, gy, type, forceLowDetail = false) {
      // Performance optimization: パーティクル数上限チェック
      const isHeavyLoad = this.particles.length > MAX_PARTICLES * 0.7;
      if (this.particles.length >= MAX_PARTICLES) {
        // 上限に達したら古いパーティクルを削除して追加
        const removeCount = Math.min(10, this.particles.length - MAX_PARTICLES + 5);
        this.particles.splice(0, removeCount);
      }
      
      let startX = this.boardX + gx * cellSize;
      let startY = this.boardY + (gy - HIDDEN_ROWS) * cellSize;
      let effectType = type > 100 ? type - 100 : type;
      let pColor = COLORS.gems[effectType] || '#FFFFFF';
      
      // Enhanced Particle Explosion - 負荷に応じて数を調整
      let count = isHeavyLoad ? PARTICLE_SPAWN_THROTTLE_HEAVY : PARTICLE_SPAWN_THROTTLE;
      if (forceLowDetail) count = 3;
      
      if (this.opponentIsDevil) {
        count = isHeavyLoad ? 8 : 15; // 般若モードでも負荷時は制限
        if (forceLowDetail) count = 4;
      }
      
      for (let i = 0; i < count; i++) {
        let angle = this.p.random(this.p.TWO_PI);
        let speed = this.p.random(2, 12);
        let drag = this.p.random(0.92, 0.98);
        
        // 負荷時はシンプルなタイプを使用
        let pType = isHeavyLoad ? 'rect' : 'bit';
        if (!isHeavyLoad && this.p.random() < 0.3) pType = 'rect';
        if (forceLowDetail) pType = 'rect';
        
        let finalColor = pColor;
        let isSpark = false;
        let isAtomic = false;
        
        if (this.opponentIsDevil) {
           isAtomic = true;
           speed = this.p.random(0.5, 4);
           drag = 0.99;
        }
        
        this.particles.push({
          x: startX + cellSize/2,
          y: startY + cellSize/2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          gravity: this.opponentIsDevil ? 0 : this.p.random(0.1, 0.4),
          drag: drag,
          size: this.opponentIsDevil ? this.p.random(2, 4) : this.p.random(10, 22),
          life: this.p.random(0.5, 1.2),
          color: finalColor,
          type: pType,
          isSpark: isSpark,
          isAtomic: isAtomic,
          val: this.p.random() < 0.5 ? "0" : "1",
          blinkOffset: this.p.floor(this.p.random(10))
        });
      }
    }

    createBigExplosion(x, y) {
      // Performance optimization: パーティクル数チェック
      if (this.particles.length >= MAX_PARTICLES - 3) return;
      
      // Core Blast
      this.particles.push({
        x: x, y: y,
        vx: this.p.random(-2, 2), vy: this.p.random(-2, 2),
        life: 1.0, size: this.p.random(30, 60),
        color: '#FFFFA0', isFire: true, decay: 0.1
      });
      
      // Fireball - 負荷状況に応じて
      const fireCount = this.particles.length > MAX_PARTICLES * 0.7 ? 1 : 2;
      for(let i=0; i<fireCount; i++) {
         const angle = this.p.random(this.p.TWO_PI);
         const speed = this.p.random(2, 8);
         this.particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0, size: this.p.random(15, 40),
            color: this.p.random(['#FF4500', '#FF0000', '#FF8C00']), 
            isFire: true, decay: 0.05
         });
      }
    }

    createMagicParticles(gx, gy, type) {
      // Performance optimization: パーティクル数チェック
      if (this.particles.length >= MAX_PARTICLES - 5) return;
      
      let startX = this.boardX + gx * cellSize + cellSize/2;
      let startY = this.boardY + (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
      let effectType = type > 100 ? type - 100 : type;
      let pColor = COLORS.gems[effectType] || '#FFFFFF';
      
      // Flash
      this.particles.push({
        x: startX, y: startY, vx: 0, vy: 0, gravity: 0,
        size: cellSize * 1.5, life: 0.5, color: '#FFFFFF', isFlash: true
      });

      // Sparkles - 負荷状況に応じて数を調整
      const count = this.particles.length > MAX_PARTICLES * 0.6 ? 3 : 6;
      for (let i = 0; i < count; i++) {
        let angle = this.p.random(this.p.TWO_PI);
        let speed = this.p.random(2, 5);
        this.particles.push({
          x: startX, y: startY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          gravity: -0.1,
          size: this.p.random(10, 20),
          life: this.p.random(0.8, 1.5),
          color: pColor,
          isMagic: true
        });
      }
    }

    createUnsealEffect(gx, gy) {
      // Performance optimization: パーティクル数チェック
      if (this.particles.length >= MAX_PARTICLES - 2) return;
      
      let x = this.boardX + gx * cellSize + cellSize/2;
      let y = this.boardY + (gy - HIDDEN_ROWS) * cellSize + cellSize/2;
      const count = this.particles.length > MAX_PARTICLES * 0.7 ? 2 : 3;
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: x, y: y,
          vx: this.p.random(-3, 3), vy: this.p.random(-3, 3),
          life: 0.8, color: '#FFFFFF',
          size: 5
        });
      }
    }

    updateAndDrawParticles(isPaused) {
      const len = this.particles.length;
      if (len === 0) return;
      
      this.p.push();
      this.p.blendMode(this.p.ADD);
      this.p.noStroke();
      this.p.rectMode(this.p.CENTER);
      
      // キャッシュ用の変数
      const boardX = this.boardX;
      const boardY = this.boardY;
      const pObj = this.p;
      
      let writeIdx = 0;
      for (let i = 0; i < len; i++) {
        let pt = this.particles[i];
        if (!isPaused) {
            pt.x += pt.vx;
            pt.y += pt.vy;
            const drag = pt.drag || 0.96;
            pt.vx *= drag;
            pt.vy *= drag;
            if (pt.gravity) pt.vy += pt.gravity;
            
            if (pt.isAtomic) {
              pt.x += (Math.random() - 0.5);
              pt.y += (Math.random() - 0.5);
              pt.life -= 0.01;
            } else {
              pt.life -= 0.02;
            }
        }
        
        if (pt.life <= 0) continue;
        
        // 生存パーティクルを前方に詰める
        if (writeIdx !== i) this.particles[writeIdx] = pt;
        writeIdx++;
        
        const alpha = pt.life * 255;
        const px = pt.x - boardX;
        const py = pt.y - boardY;
        
        if (pt.isFlash) {
           let size = pt.size * (1 + (0.5 - pt.life));
           pObj.fill(255, 255, 255, alpha);
           pObj.ellipse(px, py, size, size);
        } else if (pt.isAtomic) {
           if (pt.life > 0.8) {
              pObj.fill(255, 255, 255, 255);
           } else {
              pObj.fill(255, 255, 255, alpha);
           }
           pObj.ellipse(px, py, pt.size);
           // グロー効果を簡略化
           pObj.fill(255, 255, 255, alpha * 0.2);
           pObj.ellipse(px, py, pt.size * 2.5);
        } else if (pt.isMagic) {
           let size = pt.size * pt.life;
           let c = pObj.color(pt.color);
           c.setAlpha(alpha);
           pObj.fill(c);
           pObj.rect(px, py, size, size/4);
           pObj.rect(px, py, size/4, size);
        } else if (pt.isSpark) {
           pObj.stroke(pt.color);
           pObj.strokeWeight(pt.size * pt.life);
           pObj.line(px, py, px - pt.vx * 2, py - pt.vy * 2);
           pObj.noStroke();
        } else if (pt.type) {
           let c = pObj.color(pt.color);
           c.setAlpha(alpha);
           pObj.fill(c);
           
           if (pt.type === 'bit') {
               pObj.textSize(pt.size);
               pObj.text(pt.val, px, py);
           } else {
               pObj.rect(px, py, pt.size, pt.size);
           }
        } else {
           let c = pObj.color(pt.color);
           c.setAlpha(alpha);
           pObj.fill(c);
           pObj.rect(px, py, pt.size, pt.size);
        }
      }
      // 配列の長さを調整
      this.particles.length = writeIdx;
      this.p.pop();
    }

    // --- 花火エフェクト ---
    spawnFirework(x, y) {
      // Performance optimization: 花火数の上限チェック（軽量化: 上限到達時は古いものをswap-popで削除）
      if (this.fireworks.length >= MAX_FIREWORKS) {
        // swap-pop方式で高速削除
        const removeCount = Math.min(3, this.fireworks.length - MAX_FIREWORKS + 2);
        for (let i = 0; i < removeCount; i++) {
          this.fireworks[i] = this.fireworks[this.fireworks.length - 1 - i];
        }
        this.fireworks.length -= removeCount;
      }
      
      const hue = this.p.random(360);
      // 軽量化: 生成数を削減 (4→2, 2→1)
      const count = this.fireworks.length > MAX_FIREWORKS * 0.5 ? 1 : 2;
      for (let i = 0; i < count; i++) {
        const angle = this.p.random(this.p.TWO_PI);
        const speed = this.p.random(2, 5);
        this.fireworks.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          hue: hue,
          gravity: 0.1,
          drag: 0.96,
          size: this.p.random(3, 5)
        });
      }
    }

    updateAndDrawFireworks(isPaused) {
      this.p.push();
      this.p.colorMode(this.p.HSB, 360, 100, 100, 100);
      this.p.blendMode(this.p.ADD);
      this.p.noStroke();
      for (let i = this.fireworks.length - 1; i >= 0; i--) {
        let fw = this.fireworks[i];
        if (!isPaused) {
        fw.x += fw.vx;
        fw.y += fw.vy;
        fw.vy += fw.gravity;
        fw.vx *= fw.drag;
        fw.vy *= fw.drag;
        fw.life -= 0.015;
        }
        if (fw.life <= 0) {
          this.fireworks[i] = this.fireworks[this.fireworks.length - 1];
          this.fireworks.pop();
        } else {
          let alpha = fw.life * 100;
          if (this.p.random() < 0.2) alpha = 0; // Twinkle
          this.p.fill(fw.hue, 80, 100, alpha);
          this.p.ellipse(fw.x - this.boardX, fw.y - this.boardY, fw.size * fw.life);
        }
      }
      this.p.pop();
    }
  }

  // ==========================================
  // エフェクトクラス群 (Effect Classes)
  // ==========================================
  class ReticleEffect {
    constructor(p, tx, ty, onLock, startDelay = 0) {
      this.p = p;
      this.target = p.createVector(tx, ty);
      this.pos = p.createVector(p.random(p.width), p.random(p.height));
      this.onLock = onLock;
      this.startDelay = startDelay;
      this.finished = false;
      this.timer = 0;
      this.moveDuration = 60;
      this.lockDuration = 40;
      this.angle = 0;
      this.particles = [];
    }

    update() {
      if (this.startDelay > 0) {
        this.startDelay--;
        return;
      }

      this.timer++;
      
      // Play beep sound
      if (this.timer < this.moveDuration && this.timer % 8 === 0) {
        audio.playReticleBeep();
      }

      if (this.timer < this.moveDuration) {
        let t = 0.1;
        this.pos.x = this.p.lerp(this.pos.x, this.target.x, t);
        this.pos.y = this.p.lerp(this.pos.y, this.target.y, t);
      } else if (this.timer < this.moveDuration + this.lockDuration) {
        this.pos.x = this.target.x;
        this.pos.y = this.target.y;
      } else {
        if (!this.finished) {
          this.finished = true;
          if (this.onLock) this.onLock();
        }
      }
      this.angle += 0.15;
    }

    draw() {
      if (this.startDelay > 0) return;
      this.p.push();
      this.p.translate(this.pos.x, this.pos.y);
      this.p.noFill();
      
      let isLocking = this.timer >= this.moveDuration;
      let color = isLocking ? '#FF0000' : '#00FF00';
      if (isLocking && Math.floor(this.timer / 4) % 2 === 0) color = '#FF8888';
      
      this.p.stroke(color);
      this.p.strokeWeight(2);
      
      this.p.push();
      this.p.rotate(this.angle);
      let size = isLocking ? 50 : 150 - (100 * (this.timer / this.moveDuration));
      for(let i=0; i<4; i++) {
        this.p.rotate(this.p.HALF_PI);
        this.p.arc(0, 0, size, size, 0.2, this.p.HALF_PI - 0.2);
      }
      this.p.pop();
      
      this.p.strokeWeight(1);
      this.p.line(-10, 0, 10, 0);
      this.p.line(0, -10, 0, 10);
      
      if (isLocking) {
        this.p.noStroke();
        this.p.fill(color);
        this.p.textAlign(this.p.CENTER, this.p.BOTTOM);
        this.p.textSize(14);
        this.p.textStyle(this.p.BOLD);
        this.p.text("LOCK ON", 0, -size/2 - 5);
      }
      this.p.pop();
    }
  }

  class LaserEffect {
    constructor(p, x, y, h, onHit, delay) {
      this.p = p;
      this.x = x;
      this.y = y;
      this.h = h;
      this.onHit = onHit;
      this.delay = delay;
      this.life = 0;
      this.maxLife = 60;
      this.fired = false;
      this.finished = false;
      this.particles = []; // Required for cleanup logic
    }

    update() {
      if (this.delay > 0) {
        this.delay--;
        return;
      }
      this.life++;
      
      if (this.life === 30) {
        if (this.onHit) this.onHit();
        this.fired = true;
      }
      
      if (this.life >= this.maxLife) {
        this.finished = true;
      }
    }

    draw() {
      if (this.delay > 0) return;
      
      this.p.push();
      this.p.blendMode(this.p.ADD);
      
      if (this.life < 30) {
        let alpha = (this.life / 30) * 200;
        this.p.stroke(255, 0, 0, alpha);
        this.p.strokeWeight(2);
        this.p.line(this.x, this.y - 100, this.x, this.y + this.h + 100);
      } else {
        let progress = (this.life - 30) / 30;
        let w = (1 - progress) * 40;
        let alpha = (1 - progress) * 255;
        
        this.p.stroke(255, 0, 0, alpha);
        this.p.strokeWeight(w);
        this.p.line(this.x, this.y - 100, this.x, this.y + this.h + 100);
        
        this.p.stroke(255, 255, 255, alpha);
        this.p.strokeWeight(w * 0.5);
        this.p.line(this.x, this.y - 100, this.x, this.y + this.h + 100);
      }
      this.p.pop();
    }
  }

  // ==========================================
  // QUANTUM PLASMA MISSILE - Futuristic AI Attack Effect
  // A high-tech energy projectile with holographic trail
  // ==========================================
  class MissileEffect {
    constructor(p, sx, sy, ex, ey, onHit) {
      this.p = p;
      this.start = p.createVector(sx, sy);
      this.target = p.createVector(ex, ey);
      this.pos = this.start.copy();
      this.onHit = onHit;
      this.finished = false;
      this.progress = 0;
      this.speed = 0.018;
      this.control = p.createVector((sx + ex)/2, Math.min(sy, ey) - 350); // Higher arch
      this.particles = [];
      this.shockwaves = [];
      this.dataStreams = [];
      this.energyRings = [];
      this.hitTriggered = false;
      this.trailPoints = [];
      this.hue = p.random(180, 300); // Cyan to purple range
      this.glitchOffset = 0;
    }

    update() {
      if (!this.hitTriggered) {
        this.progress += this.speed;
        this.speed += 0.0008; // Faster acceleration
        this.glitchOffset = Math.random() < 0.1 ? (Math.random() - 0.5) * 10 : 0;
        
        if (this.progress >= 1) {
          this.progress = 1;
          this.hitTriggered = true;
          if (this.onHit) this.onHit();
          this.createQuantumExplosion();
        }

        // Bezier curve
        const t = this.progress;
        const invT = 1 - t;
        const x = invT * invT * this.start.x + 2 * invT * t * this.control.x + t * t * this.target.x;
        const y = invT * invT * this.start.y + 2 * invT * t * this.control.y + t * t * this.target.y;
        this.pos.set(x, y);
        
        // Store trail points for energy ribbon
        this.trailPoints.push({x, y, life: 1.0});
        if (this.trailPoints.length > 30) this.trailPoints.shift();

        // Quantum energy particles trail
        if (this.p.frameCount % 2 === 0) {
          const angle = this.p.random(this.p.TWO_PI);
          const spread = 5;
          this.particles.push({
            x: x + Math.cos(angle) * spread, 
            y: y + Math.sin(angle) * spread,
            vx: this.p.random(-2, 2), 
            vy: this.p.random(-2, 2),
            life: 1.0, 
            size: this.p.random(4, 10),
            hue: this.hue + this.p.random(-30, 30),
            isEnergy: true, 
            decay: 0.06
          });
        }
        
        // Data stream particles
        if (this.p.frameCount % 4 === 0) {
          this.particles.push({
            x: x, y: y,
            vx: this.p.random(-1, 1) * 0.5, 
            vy: this.p.random(-3, -1),
            life: 1.0, 
            size: this.p.random(2, 4),
            isData: true,
            char: this.p.random(['0', '1', '∞', '◆', '●']),
            decay: 0.04
          });
        }
        
        // Expanding energy ring
        if (this.p.frameCount % 8 === 0) {
          this.energyRings.push({
            x: x, y: y,
            radius: 5,
            life: 1.0,
            hue: this.hue
          });
        }
      }

      // Update trail points
      for (let i = this.trailPoints.length - 1; i >= 0; i--) {
        this.trailPoints[i].life -= 0.05;
        if (this.trailPoints[i].life <= 0) {
          this.trailPoints.splice(i, 1);
        }
      }

      // Update particles
      for (let i = this.particles.length - 1; i >= 0; i--) {
        let pt = this.particles[i];
        pt.x += pt.vx;
        pt.y += pt.vy;
        pt.life -= pt.decay || 0.03;
        if (pt.life <= 0) {
          this.particles[i] = this.particles[this.particles.length - 1];
          this.particles.pop();
        }
      }

      // Update energy rings
      for (let i = this.energyRings.length - 1; i >= 0; i--) {
        let ring = this.energyRings[i];
        ring.radius += 3;
        ring.life -= 0.08;
        if (ring.life <= 0) this.energyRings.splice(i, 1);
      }

      // Update shockwaves
      for (let i = this.shockwaves.length - 1; i >= 0; i--) {
        let sw = this.shockwaves[i];
        sw.radius += sw.speed;
        sw.life -= 0.04;
        if (sw.life <= 0) this.shockwaves.splice(i, 1);
      }

      if (this.hitTriggered && this.particles.length === 0 && this.shockwaves.length === 0 && this.energyRings.length === 0) {
        this.finished = true;
      }
    }

    createQuantumExplosion() {
      // 1. Quantum Core Flash - Brilliant white center
      this.particles.push({
        x: this.target.x, y: this.target.y,
        vx: 0, vy: 0,
        life: 1.0, size: 80,
        isCore: true, decay: 0.15
      });

      // 2. Plasma burst - Cyan/Purple energy
      for(let i = 0; i < 6; i++) {
         const angle = this.p.random(this.p.TWO_PI);
         const speed = this.p.random(4, 12);
         this.particles.push({
            x: this.target.x, y: this.target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0, size: this.p.random(20, 40),
            hue: this.hue + this.p.random(-40, 40),
            isPlasma: true, decay: 0.04
         });
      }

      // 3. Energy sparks - Fast moving light particles
      for(let i = 0; i < 8; i++) {
         const angle = (i / 8) * this.p.TWO_PI + this.p.random(-0.2, 0.2);
         const speed = this.p.random(15, 25);
         this.particles.push({
            x: this.target.x, y: this.target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0, size: this.p.random(2, 5),
            isSpark: true, decay: 0.06
         });
      }

      // 4. Data fragments - Binary explosion
      for(let i = 0; i < 6; i++) {
         const angle = this.p.random(this.p.TWO_PI);
         const speed = this.p.random(3, 8);
         this.particles.push({
            x: this.target.x, y: this.target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0, size: 8,
            isData: true,
            char: this.p.random(['0', '1', '∞', '◆']),
            decay: 0.025
         });
      }

      // 5. Quantum shockwaves - Multiple expanding rings
      for (let i = 0; i < 3; i++) {
        this.shockwaves.push({
          x: this.target.x, y: this.target.y,
          radius: 10 + i * 15, 
          speed: 20 - i * 3, 
          life: 1.0, 
          hue: this.hue + i * 30,
          thickness: 4 - i
        });
      }
      
      // 6. Hexagonal grid burst
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * this.p.TWO_PI;
        const dist = 30;
        this.particles.push({
          x: this.target.x + Math.cos(angle) * dist,
          y: this.target.y + Math.sin(angle) * dist,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2,
          life: 1.0, size: 15,
          isHex: true, 
          angle: angle,
          decay: 0.03
        });
      }
    }

    draw() {
      this.p.push();
      
      // Draw energy trail ribbon
      if (this.trailPoints.length > 1) {
        this.p.noFill();
        this.p.blendMode(this.p.ADD);
        for (let layer = 0; layer < 3; layer++) {
          this.p.beginShape();
          this.trailPoints.forEach((pt, i) => {
            const alpha = pt.life * (100 - layer * 30);
            const hue = (this.hue + i * 2) % 360;
            this.p.stroke(this.p.color(`hsla(${hue}, 100%, 70%, ${alpha / 255})`));
            this.p.strokeWeight((4 - layer) * pt.life);
            this.p.vertex(pt.x, pt.y);
          });
          this.p.endShape();
        }
      }
      
      // Draw energy rings
      this.p.noFill();
      this.energyRings.forEach(ring => {
        const alpha = ring.life * 150;
        this.p.stroke(this.p.color(`hsla(${ring.hue}, 100%, 70%, ${alpha / 255})`));
        this.p.strokeWeight(2 * ring.life);
        this.p.ellipse(ring.x, ring.y, ring.radius * 2);
      });
      
      // Draw Quantum Shockwaves
      this.p.noFill();
      this.shockwaves.forEach(sw => {
        const alpha = sw.life * 200;
        this.p.stroke(this.p.color(`hsla(${sw.hue}, 100%, 80%, ${alpha / 255})`));
        this.p.strokeWeight((sw.thickness || 3) * sw.life);
        this.p.ellipse(sw.x, sw.y, sw.radius * 2);
        
        // Inner glow ring
        this.p.stroke(this.p.color(`hsla(${sw.hue}, 50%, 95%, ${alpha * 0.5 / 255})`));
        this.p.strokeWeight(1);
        this.p.ellipse(sw.x, sw.y, sw.radius * 1.8);
      });
      
      this.p.noStroke();

      // Draw particles
      this.p.blendMode(this.p.ADD);
      this.particles.forEach(pt => {
        const alpha = pt.life * 255;
        
        if (pt.isCore) {
          // White core flash
          this.p.fill(255, 255, 255, alpha);
          this.p.ellipse(pt.x, pt.y, pt.size * pt.life);
          this.p.fill(255, 255, 255, alpha * 0.3);
          this.p.ellipse(pt.x, pt.y, pt.size * pt.life * 1.5);
        } else if (pt.isPlasma) {
          // Colored plasma burst
          this.p.fill(this.p.color(`hsla(${pt.hue}, 100%, 70%, ${alpha / 255})`));
          this.p.ellipse(pt.x, pt.y, pt.size * pt.life);
        } else if (pt.isSpark) {
          // Fast sparks
          this.p.fill(255, 255, 255, alpha);
          this.p.ellipse(pt.x, pt.y, pt.size);
        } else if (pt.isEnergy) {
          // Energy trail particles
          this.p.fill(this.p.color(`hsla(${pt.hue}, 100%, 75%, ${alpha / 255})`));
          this.p.ellipse(pt.x, pt.y, pt.size * pt.life);
        } else if (pt.isData) {
          // Data fragments
          this.p.fill(0, 255, 255, alpha * 0.8);
          this.p.textSize(pt.size);
          this.p.textAlign(this.p.CENTER, this.p.CENTER);
          this.p.text(pt.char, pt.x, pt.y);
        } else if (pt.isHex) {
          // Hexagonal fragments
          this.p.push();
          this.p.translate(pt.x, pt.y);
          this.p.rotate(pt.angle);
          this.p.stroke(0, 255, 255, alpha);
          this.p.strokeWeight(1);
          this.p.noFill();
          this.p.beginShape();
          for (let i = 0; i < 6; i++) {
            const a = (i / 6) * this.p.TWO_PI;
            this.p.vertex(Math.cos(a) * pt.size * pt.life, Math.sin(a) * pt.size * pt.life);
          }
          this.p.endShape(this.p.CLOSE);
          this.p.pop();
        }
      });

      // Draw Missile Body - Futuristic Energy Projectile
      if (!this.hitTriggered) {
        this.p.blendMode(this.p.BLEND);
        this.p.push();
        this.p.translate(this.pos.x + this.glitchOffset, this.pos.y);
        
        // Calculate angle
        const t = this.progress;
        const tx = 2 * (1-t) * (this.control.x - this.start.x) + 2 * t * (this.target.x - this.control.x);
        const ty = 2 * (1-t) * (this.control.y - this.start.y) + 2 * t * (this.target.y - this.control.y);
        const angle = Math.atan2(ty, tx);
        
        this.p.rotate(angle);
        
        // Outer energy glow
        this.p.blendMode(this.p.ADD);
        this.p.noStroke();
        this.p.fill(this.p.color(`hsla(${this.hue}, 100%, 60%, 0.3)`));
        this.p.ellipse(0, 0, 50, 25);
        this.p.fill(this.p.color(`hsla(${this.hue}, 100%, 70%, 0.5)`));
        this.p.ellipse(0, 0, 35, 18);
        
        // Core body - sleek futuristic shape
        this.p.blendMode(this.p.BLEND);
        this.p.fill(20, 30, 40);
        this.p.beginShape();
        this.p.vertex(20, 0);
        this.p.vertex(5, -6);
        this.p.vertex(-15, -5);
        this.p.vertex(-20, 0);
        this.p.vertex(-15, 5);
        this.p.vertex(5, 6);
        this.p.endShape(this.p.CLOSE);
        
        // Glowing core center
        this.p.blendMode(this.p.ADD);
        this.p.fill(this.p.color(`hsla(${this.hue}, 100%, 80%, 0.9)`));
        this.p.ellipse(5, 0, 12, 8);
        this.p.fill(255, 255, 255, 200);
        this.p.ellipse(5, 0, 6, 4);
        
        // Energy fins
        this.p.fill(this.p.color(`hsla(${this.hue + 30}, 100%, 60%, 0.7)`));
        this.p.triangle(-10, 0, -18, -10, -12, -4);
        this.p.triangle(-10, 0, -18, 10, -12, 4);
        
        // Front targeting point
        this.p.fill(255, 50, 100, 200);
        this.p.ellipse(18, 0, 5, 5);
        
        // Engine trail
        this.p.fill(this.p.color(`hsla(${this.hue}, 100%, 70%, 0.8)`));
        this.p.ellipse(-18, 0, 15, 8);
        this.p.fill(255, 255, 255, 150);
        this.p.ellipse(-18, 0, 8, 4);
        
        this.p.pop();
      }

      this.p.pop();
    }
  }

  class AttackEffect {
    constructor(p, sx, sy, ex, ey, lines, onHit) {
      this.p = p;
      this.sx = sx;
      this.sy = sy;
      this.ex = ex;
      this.ey = ey;
      this.lines = lines;
      this.onHit = onHit;
      this.finished = false;
      this.meteors = [];
      this.particles = [];
      this.hitTriggered = false;
      
      // 流星の数: コンボ数(lines)に応じて増やす
      const count = Math.min(1 + Math.ceil(lines / 2), 2); // Optimized: Reduced count
      
      for(let i=0; i<count; i++) {
        // ターゲット位置を散らす
        const targetX = ex + p.random(-boardWidth/2, boardWidth/2);
        const targetY = ey + p.random(-boardHeight/2, boardHeight/2);
        
        // 制御点（アーチを描くための高さ）
        const controlX = (sx + ex) / 2 + p.random(-100, 100);
        const controlY = Math.min(sy, ey) - p.random(200, 400);

        this.meteors.push({
          start: p.createVector(sx, sy),
          control: p.createVector(controlX, controlY),
          target: p.createVector(targetX, targetY),
          pos: p.createVector(sx, sy),
          progress: 0,
          delay: i * 2, // 少しずつずらす
          speed: p.random(0.02, 0.035),
          size: p.random(10, 20),
          hue: p.random(0, 40),
          trail: [],
          active: false,
          hit: false
        });
      }
    }

    update() {
      let activeMeteors = 0;
      
      this.meteors.forEach(m => {
        if (m.hit) return;
        
        if (m.delay > 0) {
          m.delay--;
          activeMeteors++;
          return;
        }
        
        m.active = true;
        activeMeteors++;
        m.progress += m.speed;
        
        if (m.progress >= 1) {
          m.progress = 1;
          m.hit = true;
          this.createImpact(m.target.x, m.target.y, m.hue);
        } else {
          // 2次ベジェ曲線
          const t = m.progress;
          const invT = 1 - t;
          const x = invT * invT * m.start.x + 2 * invT * t * m.control.x + t * t * m.target.x;
          const y = invT * invT * m.start.y + 2 * invT * t * m.control.y + t * t * m.target.y;
          m.pos.set(x, y);
          
          // トレイル
          m.trail.push({x: x, y: y, size: m.size, life: 1.0});
          if (m.trail.length > 3) m.trail.shift(); // Optimized: Shorter trail
        }
        
        // トレイルのライフ減少
        m.trail.forEach(tr => tr.life -= 0.05);
      });

      // パーティクル更新
      for (let i = this.particles.length - 1; i >= 0; i--) {
        let pt = this.particles[i];
        pt.x += pt.vx;
        pt.y += pt.vy;
        pt.life -= 0.05;
        if (pt.life <= 0) {
          this.particles[i] = this.particles[this.particles.length - 1];
          this.particles.pop();
        }
      }

      // 全ての流星が着弾し、パーティクルも消えたら終了
      if (activeMeteors === 0 && this.particles.length === 0) {
        this.finished = true;
      }
      
      // お邪魔ブロックを送るタイミング
      if (activeMeteors === 0 && !this.hitTriggered) {
        this.hitTriggered = true;
        if (this.onHit) this.onHit();
      }
    }

    createImpact(x, y, hue) {
      for(let i=0; i<4; i++) {
         const angle = this.p.random(this.p.TWO_PI);
         const speed = this.p.random(2, 8);
         this.particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            hue: hue
         });
      }
    }

    draw() {
      this.p.push();
      this.p.colorMode(this.p.HSB, 360, 100, 100, 100);
      this.p.blendMode(this.p.ADD);
      this.p.noStroke();

      // 流星描画
      this.meteors.forEach(m => {
        if (!m.active || m.hit) return;
        
        // トレイル
        for (let i = 0; i < m.trail.length; i++) {
          let tr = m.trail[i];
          if (tr.life <= 0) continue;
          let alpha = tr.life * 80;
          let size = tr.size * tr.life;
          this.p.fill(m.hue, 90, 100, alpha);
          this.p.ellipse(tr.x, tr.y, size);
        }
        
        // 本体（輝く核）
        this.p.fill(0, 0, 100);
        this.p.ellipse(m.pos.x, m.pos.y, m.size);
      });

      // パーティクル描画
      this.particles.forEach(pt => {
        this.p.fill(pt.hue, 80, 100, pt.life * 100);
        this.p.ellipse(pt.x, pt.y, 10 * pt.life);
      });

      this.p.pop();
    }
  }
  
  class DataPacket {
    constructor(p) {
      this.p = p;
      this.reset(true);
    }
    
    reset(randomX = false) {
      this.x = randomX ? this.p.random(this.p.width) : -150;
      this.y = this.p.random(this.p.height);
      this.type = this.p.random() < 0.2 ? 'large' : 'small';
      
      if (this.type === 'large') {
        this.size = this.p.random(40, 80);
        this.speed = this.p.random(1.0, 2.0);
      } else {
        this.size = this.p.random(10, 20);
        this.speed = this.p.random(2.0, 4.0);
      }
      this.color = this.p.color(0, 255, 255, this.p.random(50, 150));
      this.angle = 0;
    }
    
    update() {
      this.x += this.speed;
      
      if (this.x > this.p.width + 150) {
        this.reset();
      }
    }
    
    draw() {
      this.p.push();
      this.p.translate(this.x, this.y);
      this.p.noStroke();
      this.p.fill(this.color);
      
      if (this.type === 'large') {
        // Data Block
        this.p.rectMode(this.p.CENTER);
        this.p.rect(0, 0, this.size, this.size * 0.3);
        this.p.fill(255, 255, 255, 100);
        this.p.textSize(10);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.text("DATA", 0, 0);
      } else {
        // Bit
        this.p.textSize(12);
        this.p.text(this.p.random() < 0.5 ? "0" : "1", 0, 0);
      }
      this.p.pop();
    }
  }
  
  class Bubble {
    constructor(p) {
      this.p = p;
      this.reset(true);
    }
    
    reset(randomY = false) {
      this.x = this.p.random(this.p.width);
      this.y = randomY ? this.p.random(this.p.height) : this.p.height + 20;
      this.size = this.p.random(2, 8);
      this.speed = this.p.random(0.5, 2);
      this.wobble = this.p.random(this.p.TWO_PI);
    }
    
    update() {
      this.y -= this.speed;
      this.wobble += 0.05;
      this.x += Math.sin(this.wobble) * 0.5;
      if (this.y < -20) this.reset();
    }
    
    draw() {
      this.p.noStroke();
      this.p.fill(0, 255, 255, 50);
      this.p.textSize(this.size * 2);
      this.p.text(this.p.random() < 0.5 ? "0" : "1", this.x, this.y);
    }
  }

  // ==========================================
  // 入力制御 (Input Controls)
  // ==========================================
  function setupControls() {
    const btnUp = document.getElementById('btn-up');
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnDown = document.getElementById('btn-down');
    const btnItem = document.getElementById('btn-item');
    const btnRetry = document.getElementById('retry-btn');
    const btnHome = document.getElementById('home-btn');
    const btnPause = document.getElementById('pause-btn');
    const btnAssist = document.getElementById('assist-btn');

    // Continuous Input Handlers (Left/Right)
    const bindRepeatBtn = (elem, key, action) => {
      const start = (e) => {
        if (e.cancelable) e.preventDefault();
        if (gameState !== 'PLAYING' || playerGame.state !== 'PLAYING' || isReviving) return;

        inputState[key] = true;
        
        // Immediate execution ensures responsiveness
        if (inputTimers[key] === 0) {
          action();
          inputTimers[key] = 1;
        }
      };
      const end = (e) => {
        if (e.cancelable) e.preventDefault();
        inputState[key] = false;
        inputTimers[key] = 0;
      };
      
      elem.addEventListener('touchstart', start, {passive: false});
      elem.addEventListener('touchend', end);
      elem.addEventListener('mousedown', start);
      elem.addEventListener('mouseup', end);
      elem.addEventListener('mouseleave', end);
    };

    bindRepeatBtn(btnLeft, 'left', () => playerGame.movePiece(-1, 0));
    bindRepeatBtn(btnRight, 'right', () => playerGame.movePiece(1, 0));
    
    // Single Action Handlers
    const bindActionBtn = (elem, action, allowAnimating = false, allowGraceTime = false) => {
      const handler = (e) => {
        if (e.cancelable) e.preventDefault();
        if (gameState !== 'PLAYING' || isReviving) return;
        if (playerGame.state === 'PLAYING' || 
            (allowAnimating && playerGame.state === 'ANIMATING') ||
            (allowGraceTime && playerGame.state === 'GAMEOVER_GRACE')) action();
      };
      elem.addEventListener('touchstart', handler, {passive: false});
      elem.addEventListener('mousedown', handler);
    };

    bindActionBtn(btnUp, () => playerGame.rotatePiece());
    
    const handleSwap = (e) => {
      if (e.cancelable) e.preventDefault();
      if (gameState === 'PLAYING' && !isPaused && !isReviving && 
          (playerGame.state === 'PLAYING' || playerGame.state === 'ANIMATING' || playerGame.state === 'GAMEOVER_GRACE')) {
        playerGame.swapItems();
      }
    };
    btnSwap.addEventListener('touchstart', handleSwap, {passive: false});
    btnSwap.addEventListener('click', handleSwap);

    bindActionBtn(btnItem, () => {
      if (playerGame.itemStock.length > 0) {
        const item = playerGame.itemStock[0];
        if (item === 'P' && !playerGame.nextSpawnIsItem) {
          if (playerGame.state === 'PLAYING' || playerGame.state === 'ANIMATING' || playerGame.state === 'GAMEOVER_GRACE') {
            playerGame.itemStock.shift();
            playerGame.nextSpawnIsItem = true;
            playerGame.nextPieceBlocks = [0, 0, 7];
            playerGame.triggerItemUseEffect('P');
          }
        } else if (item === 'R') {
          playerGame.itemStock.shift();
          playerGame.reverseField();
          playerGame.triggerItemUseEffect('R');
        } else if (item === 'C') {
          playerGame.itemStock.shift();
          playerGame.clearField();
          playerGame.triggerItemUseEffect('C');
        } else if (item === 'S') {
          playerGame.itemStock.shift();
          playerGame.performSwap(playerGame.opponent);
          playerGame.triggerItemUseEffect('S');
        }
      }
    }, true, true);
    
    // Down button - Hard Drop
    bindActionBtn(btnDown, () => playerGame.hardDrop());

    const pauseOverlay = document.getElementById('pause-overlay');
    const btnPauseResume = document.getElementById('pause-resume-btn');
    const btnPauseModeSelect = document.getElementById('pause-mode-select-btn');

    const togglePause = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      if (gameState === 'PLAYING') {
        isPaused = !isPaused;
        if (isPaused) {
          audio.pauseBGM();
          pauseOverlay.classList.add('active');
        } else {
          audio.resumeBGM();
          pauseOverlay.classList.remove('active');
        }
      }
    };

    const resumeGame = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      if (isPaused) {
        isPaused = false;
        audio.resumeBGM();
        pauseOverlay.classList.remove('active');
      }
    };

    const goToModeSelect = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      isPaused = false;
      pauseOverlay.classList.remove('active');
      audio.pauseBGM();
      audio.playTitleBGM();
      document.getElementById('mode-select-screen').style.display = 'flex';
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('ui-layer').style.display = 'none';
      document.getElementById('game-over-modal').style.display = 'none';
      gameState = 'TITLE';
      // Reinitialize HEXA logo effects
      initHexaLogoEffects();
    };

    btnPause.addEventListener('click', togglePause);
    btnPause.addEventListener('touchstart', togglePause, {passive: false});
    
    btnPauseResume.addEventListener('click', resumeGame);
    btnPauseResume.addEventListener('touchstart', resumeGame, {passive: false});
    
    btnPauseModeSelect.addEventListener('click', goToModeSelect);
    btnPauseModeSelect.addEventListener('touchstart', goToModeSelect, {passive: false});

    // =====================================================
    // BUTTON LAYOUT EDITOR - Control Position/Size Editor
    // =====================================================
    const LAYOUT_STORAGE_KEY = 'hexa_button_layout';
    const btnEditControls = document.getElementById('pause-edit-btn');
    const buttonEditOverlay = document.getElementById('button-edit-overlay');
    const editSaveBtn = document.getElementById('edit-save-btn');
    const editResetBtn = document.getElementById('edit-reset-btn');
    const editCancelBtn = document.getElementById('edit-cancel-btn');
    
    // Default button layout (will be calculated based on screen size)
    let defaultLayout = null;
    let currentEditLayout = null;
    let editState = {
      dragging: null,
      resizing: null,
      startX: 0,
      startY: 0,
      startW: 0,
      startH: 0,
      startLeft: 0,
      startTop: 0,
      corner: null
    };
    
    // Calculate default layout based on game globals and screen layout
    // This function calculates positions that match the actual game button positions
    function calculateDefaultLayout() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      
      // Use game globals for accurate positioning when available
      const useCellSize = typeof cellSize !== 'undefined' ? cellSize : 
        Math.min(screenWidth * 0.95 / 2 / 8, screenHeight * 0.65 / 15);
      const useBoardWidth = typeof boardWidth !== 'undefined' ? boardWidth : useCellSize * 8;
      const useBoardHeight = typeof boardHeight !== 'undefined' ? boardHeight : useCellSize * 15;
      const useBoardY = typeof boardY !== 'undefined' ? boardY : Math.max(useCellSize * 3.2 + 3, 90);
      
      // Controls area is at bottom 25% of screen
      const controlsAreaHeight = screenHeight * 0.25;
      const controlsAreaTop = screenHeight - controlsAreaHeight;
      
      // D-Pad: centered in controls area, size 180x180
      const dpadWidth = 180;
      const dpadHeight = 180;
      // D-Pad is centered with padding (30px left, 30px right)
      // Center position accounting for padding
      const dpadLeft = (screenWidth - dpadWidth) / 2;
      const dpadTop = controlsAreaTop + (controlsAreaHeight - dpadHeight) / 2 - 5 - 10; // -10 for padding-bottom adjustment
      
      // Item button: positioned at right side of controls area
      // CSS: btn-item has position: absolute, right: 25px, top: 25%, margin-top: 20px, transform: translateY(-50%)
      // btn-item size: width: 40px, height: 25px
      // The ::after element (visible button image) is 70x45, centered on btn-item
      // For editor display, we use the visible size (70x45)
      const itemWidth = 70;
      const itemHeight = 45;
      const btnItemWidth = 40;
      const btnItemHeight = 25;
      
      // controls-area spans full width (screenWidth)
      // btn-item is positioned with right: 25px (from controls-area padding box edge)
      // For position: absolute, right: 25px means 25px from the padding box right edge
      // So btn-item right edge is at: screenWidth - 25
      // btn-item left edge is at: screenWidth - 25 - 40
      const btnItemRightEdge = screenWidth - 25;
      const btnItemLeft = btnItemRightEdge - btnItemWidth;
      
      // Center the editor wrapper (70x45) on btn-item (40x25)
      const itemLeft = btnItemLeft - (itemWidth - btnItemWidth) / 2;
      
      // top: 25% of controls area height + margin-top: 20px, then translateY(-50%) centers on that point
      // This means btn-item center is at: controlsAreaTop + controlsAreaHeight * 0.25 + 20
      const btnItemCenterY = controlsAreaTop + controlsAreaHeight * 0.25 + 20;
      const btnItemTop = btnItemCenterY - btnItemHeight / 2;
      
      // Center the editor wrapper on btn-item
      const itemTop = btnItemTop - (itemHeight - btnItemHeight) / 2;
      
      // Swap button: below the board on the left side
      const playerX = screenWidth * 0.25 - useBoardWidth / 2;
      const itemSize = useCellSize * 1.4;
      const swapWidth = itemSize * 1.5;
      const swapHeight = useCellSize * 1.4;
      const swapLeft = playerX + (itemSize - swapWidth) / 2;
      const swapTop = useBoardY + useBoardHeight + 5 + itemSize + 5;
      
      return {
        dpad: { left: dpadLeft, top: dpadTop, width: dpadWidth, height: dpadHeight },
        item: { left: itemLeft, top: itemTop, width: itemWidth, height: itemHeight },
        swap: { left: swapLeft, top: swapTop, width: swapWidth, height: swapHeight }
      };
    }
    
    // Load saved layout from localStorage
    function loadSavedLayout() {
      try {
        const saved = localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (e) {
        console.warn('Failed to load button layout:', e);
      }
      return null;
    }
    
    // Save layout to localStorage
    function saveLayout(layout) {
      try {
        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(layout));
      } catch (e) {
        console.warn('Failed to save button layout:', e);
      }
    }
    
    // Clear saved layout
    function clearSavedLayout() {
      try {
        localStorage.removeItem(LAYOUT_STORAGE_KEY);
      } catch (e) {
        console.warn('Failed to clear button layout:', e);
      }
    }
    
    // Apply layout to actual game buttons
    function applyLayoutToGameButtons(layout) {
      if (!layout) return;
      
      const dpad = document.querySelector('.d-pad');
      const btnItemEl = document.getElementById('btn-item');
      const btnSwapEl = document.getElementById('btn-swap');
      const uiLayer = document.getElementById('ui-layer');
      
      // Store custom layout flag and values for use in game loop (deep copy)
      window.customButtonLayout = {
        dpad: { ...layout.dpad },
        item: { ...layout.item },
        swap: { ...layout.swap }
      };
      
      // Apply D-Pad layout - move to ui-layer for absolute positioning
      if (layout.dpad && dpad && uiLayer) {
        // Move D-Pad to ui-layer if not already there
        if (dpad.parentElement !== uiLayer) {
          uiLayer.appendChild(dpad);
        }
        
        dpad.style.position = 'fixed';
        dpad.style.width = layout.dpad.width + 'px';
        dpad.style.height = layout.dpad.height + 'px';
        dpad.style.left = layout.dpad.left + 'px';
        dpad.style.top = layout.dpad.top + 'px';
        dpad.style.transform = 'none';
        dpad.style.zIndex = '20';
        dpad.style.pointerEvents = 'auto';
        
        // Scale the inner buttons proportionally
        const scale = layout.dpad.width / 180;
        const btnSize = 80 * scale;
        const btns = dpad.querySelectorAll('.btn');
        btns.forEach(btn => {
          btn.style.width = btnSize + 'px';
          btn.style.height = btnSize + 'px';
        });
        // Adjust button positions
        const btnLeft = dpad.querySelector('.btn-left');
        const btnRight = dpad.querySelector('.btn-right');
        const btnUp = dpad.querySelector('.btn-up');
        const btnDown = dpad.querySelector('.btn-down');
        if (btnLeft) { btnLeft.style.left = (-16 * scale) + 'px'; }
        if (btnRight) { btnRight.style.right = (-16 * scale) + 'px'; }
        if (btnUp) { btnUp.style.top = (-10 * scale) + 'px'; }
        if (btnDown) { btnDown.style.bottom = (-10 * scale) + 'px'; }
      }
      
      // Apply Item button layout - move to ui-layer for absolute positioning
      if (layout.item && btnItemEl && uiLayer) {
        // Move Item button to ui-layer if not already there
        if (btnItemEl.parentElement !== uiLayer) {
          uiLayer.appendChild(btnItemEl);
        }
        
        btnItemEl.style.position = 'fixed';
        btnItemEl.style.left = layout.item.left + 'px';
        btnItemEl.style.top = layout.item.top + 'px';
        btnItemEl.style.width = layout.item.width + 'px';
        btnItemEl.style.height = layout.item.height + 'px';
        btnItemEl.style.right = 'auto';
        btnItemEl.style.transform = 'none';
        btnItemEl.style.marginTop = '0';
        btnItemEl.style.zIndex = '20';
        btnItemEl.style.pointerEvents = 'auto';
        
        // Scale the ::after pseudo element via CSS variable
        const scaleItem = layout.item.width / 70;
        btnItemEl.style.setProperty('--item-scale', scaleItem);
      }
      
      // Swap button is handled separately in game loop
    }
    
    // Initialize edit overlay with current positions
    function initEditOverlay() {
      const savedLayout = loadSavedLayout();
      defaultLayout = calculateDefaultLayout();
      
      if (!defaultLayout) {
        console.warn('Could not calculate default layout');
        return;
      }
      
      // Also check window.customButtonLayout which is set when layout is applied to game buttons
      // This ensures editor reflects the currently active layout
      const activeLayout = window.customButtonLayout || savedLayout;
      
      // Use saved/active layout if available, otherwise use default
      // Merge saved layout with default to ensure all properties exist
      if (activeLayout && activeLayout.dpad && activeLayout.item && activeLayout.swap) {
        // Deep copy from active layout, merging with defaults for any missing properties
        currentEditLayout = {
          dpad: { 
            left: activeLayout.dpad.left !== undefined ? activeLayout.dpad.left : defaultLayout.dpad.left,
            top: activeLayout.dpad.top !== undefined ? activeLayout.dpad.top : defaultLayout.dpad.top,
            width: activeLayout.dpad.width !== undefined ? activeLayout.dpad.width : defaultLayout.dpad.width,
            height: activeLayout.dpad.height !== undefined ? activeLayout.dpad.height : defaultLayout.dpad.height
          },
          item: { 
            left: activeLayout.item.left !== undefined ? activeLayout.item.left : defaultLayout.item.left,
            top: activeLayout.item.top !== undefined ? activeLayout.item.top : defaultLayout.item.top,
            width: activeLayout.item.width !== undefined ? activeLayout.item.width : defaultLayout.item.width,
            height: activeLayout.item.height !== undefined ? activeLayout.item.height : defaultLayout.item.height
          },
          swap: { 
            left: activeLayout.swap.left !== undefined ? activeLayout.swap.left : defaultLayout.swap.left,
            top: activeLayout.swap.top !== undefined ? activeLayout.swap.top : defaultLayout.swap.top,
            width: activeLayout.swap.width !== undefined ? activeLayout.swap.width : defaultLayout.swap.width,
            height: activeLayout.swap.height !== undefined ? activeLayout.swap.height : defaultLayout.swap.height
          }
        };
      } else {
        // No saved layout or incomplete, use default
        currentEditLayout = {
          dpad: { ...defaultLayout.dpad },
          item: { ...defaultLayout.item },
          swap: { ...defaultLayout.swap }
        };
      }
      
      updateEditWrapperPositions();
    }
    
    // Update edit wrapper positions based on currentEditLayout
    // Note: currentEditLayout stores screen coordinates, container now covers full screen
    function updateEditWrapperPositions() {
      if (!currentEditLayout) return;
      
      const dpadWrapper = document.getElementById('edit-dpad-wrapper');
      const itemWrapper = document.getElementById('edit-item-wrapper');
      const swapWrapper = document.getElementById('edit-swap-wrapper');
      
      // Container now covers full screen (position: absolute, top: 0, left: 0)
      // So wrapper positions are direct screen coordinates
      
      if (dpadWrapper && currentEditLayout.dpad) {
        dpadWrapper.style.left = currentEditLayout.dpad.left + 'px';
        dpadWrapper.style.top = currentEditLayout.dpad.top + 'px';
        dpadWrapper.style.width = currentEditLayout.dpad.width + 'px';
        dpadWrapper.style.height = currentEditLayout.dpad.height + 'px';
      }
      
      if (itemWrapper && currentEditLayout.item) {
        itemWrapper.style.left = currentEditLayout.item.left + 'px';
        itemWrapper.style.top = currentEditLayout.item.top + 'px';
        itemWrapper.style.width = currentEditLayout.item.width + 'px';
        itemWrapper.style.height = currentEditLayout.item.height + 'px';
      }
      
      if (swapWrapper && currentEditLayout.swap) {
        swapWrapper.style.left = currentEditLayout.swap.left + 'px';
        swapWrapper.style.top = currentEditLayout.swap.top + 'px';
        swapWrapper.style.width = currentEditLayout.swap.width + 'px';
        swapWrapper.style.height = currentEditLayout.swap.height + 'px';
      }
    }
    
    // Open edit overlay
    function openEditOverlay(e) {
      if (e && e.cancelable) e.preventDefault();
      if (e) e.stopPropagation();
      
      // Keep pause state but hide pause overlay
      pauseOverlay.classList.remove('active');
      
      // First activate the overlay so container can be measured
      buttonEditOverlay.classList.add('active');
      
      // Then initialize and update positions after layout has settled
      // Use double requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          initEditOverlay();
        });
      });
    }
    
    // Close edit overlay and return to pause
    function closeEditOverlay() {
      buttonEditOverlay.classList.remove('active');
      pauseOverlay.classList.add('active');
    }
    
    // Check if layout is same as default (within threshold)
    function isLayoutDefault(layout) {
      if (!layout || !defaultLayout) return false;
      const threshold = 5; // pixels
      
      const dpadSame = Math.abs(layout.dpad.left - defaultLayout.dpad.left) < threshold &&
                       Math.abs(layout.dpad.top - defaultLayout.dpad.top) < threshold &&
                       Math.abs(layout.dpad.width - defaultLayout.dpad.width) < threshold;
      const itemSame = Math.abs(layout.item.left - defaultLayout.item.left) < threshold &&
                       Math.abs(layout.item.top - defaultLayout.item.top) < threshold &&
                       Math.abs(layout.item.width - defaultLayout.item.width) < threshold;
      const swapSame = Math.abs(layout.swap.left - defaultLayout.swap.left) < threshold &&
                       Math.abs(layout.swap.top - defaultLayout.swap.top) < threshold &&
                       Math.abs(layout.swap.width - defaultLayout.swap.width) < threshold;
      
      return dpadSame && itemSame && swapSame;
    }
    
    // Save button handler
    function handleEditSave(e) {
      if (e && e.cancelable) e.preventDefault();
      if (e) e.stopPropagation();
      
      if (currentEditLayout) {
        // If layout is reset to default, clear custom layout
        if (isLayoutDefault(currentEditLayout)) {
          resetButtonsToDefault();
        } else {
          saveLayout(currentEditLayout);
          applyLayoutToGameButtons(currentEditLayout);
        }
      }
      
      closeEditOverlay();
    }
    
    // Reset button handler
    function handleEditReset(e) {
      if (e && e.cancelable) e.preventDefault();
      if (e) e.stopPropagation();
      
      // Reset to default layout
      if (defaultLayout) {
        currentEditLayout = {
          dpad: { ...defaultLayout.dpad },
          item: { ...defaultLayout.item },
          swap: { ...defaultLayout.swap }
        };
        updateEditWrapperPositions();
      }
    }
    
    // Reset buttons to original position (remove custom layout)
    function resetButtonsToDefault() {
      const dpad = document.querySelector('.d-pad');
      const btnItemEl = document.getElementById('btn-item');
      const controlsArea = document.querySelector('.controls-area');
      
      // Clear custom layout
      window.customButtonLayout = null;
      clearSavedLayout();
      
      // Move D-Pad back to controls-area and reset styles
      if (dpad && controlsArea) {
        const existingDpad = controlsArea.querySelector('.d-pad');
        if (!existingDpad) {
          controlsArea.insertBefore(dpad, controlsArea.firstChild);
        }
        dpad.style.position = 'relative';
        dpad.style.width = '180px';
        dpad.style.height = '180px';
        dpad.style.left = '';
        dpad.style.top = '-5px';
        dpad.style.transform = '';
        dpad.style.zIndex = '';
        dpad.style.pointerEvents = '';
        
        // Reset button sizes
        const btns = dpad.querySelectorAll('.btn');
        btns.forEach(btn => {
          btn.style.width = '80px';
          btn.style.height = '80px';
        });
        const btnLeft = dpad.querySelector('.btn-left');
        const btnRight = dpad.querySelector('.btn-right');
        const btnUp = dpad.querySelector('.btn-up');
        const btnDown = dpad.querySelector('.btn-down');
        if (btnLeft) { btnLeft.style.left = '-16px'; }
        if (btnRight) { btnRight.style.right = '-16px'; }
        if (btnUp) { btnUp.style.top = '-10px'; }
        if (btnDown) { btnDown.style.bottom = '-10px'; }
      }
      
      // Move Item button back to controls-area and reset styles
      if (btnItemEl && controlsArea) {
        const existingItem = controlsArea.querySelector('.btn-item');
        if (!existingItem) {
          controlsArea.appendChild(btnItemEl);
        }
        btnItemEl.style.position = 'absolute';
        btnItemEl.style.right = '25px';
        btnItemEl.style.top = '25%';
        btnItemEl.style.left = '';
        btnItemEl.style.marginTop = '20px';
        btnItemEl.style.transform = 'translateY(-50%)';
        btnItemEl.style.width = '40px';
        btnItemEl.style.height = '25px';
        btnItemEl.style.zIndex = '';
        btnItemEl.style.pointerEvents = '';
        btnItemEl.style.setProperty('--item-scale', '1');
      }
    }
    
    // Cancel button handler
    function handleEditCancel(e) {
      if (e && e.cancelable) e.preventDefault();
      if (e) e.stopPropagation();
      
      closeEditOverlay();
    }
    
    // Touch/Mouse handlers for dragging and resizing
    function getEventPos(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }
    
    function handleEditPointerDown(e) {
      const target = e.target;
      const wrapper = target.closest('.edit-btn-wrapper');
      
      if (!wrapper) return;
      
      if (e.cancelable) e.preventDefault();
      
      const pos = getEventPos(e);
      const rect = wrapper.getBoundingClientRect();
      const targetType = wrapper.dataset.target;
      
      // Check if resizing (clicked on handle)
      if (target.classList.contains('edit-resize-handle')) {
        editState.resizing = targetType;
        editState.startX = pos.x;
        editState.startY = pos.y;
        editState.startW = rect.width;
        editState.startH = rect.height;
        editState.startLeft = rect.left;
        editState.startTop = rect.top;
        
        // Determine which corner
        if (target.classList.contains('nw')) editState.corner = 'nw';
        else if (target.classList.contains('ne')) editState.corner = 'ne';
        else if (target.classList.contains('sw')) editState.corner = 'sw';
        else if (target.classList.contains('se')) editState.corner = 'se';
        
        wrapper.classList.add('resizing');
      } else {
        // Dragging
        editState.dragging = targetType;
        editState.startX = pos.x;
        editState.startY = pos.y;
        editState.startLeft = rect.left;
        editState.startTop = rect.top;
        
        wrapper.classList.add('dragging');
      }
    }
    
    function handleEditPointerMove(e) {
      if (!editState.dragging && !editState.resizing) return;
      
      if (e.cancelable) e.preventDefault();
      
      const pos = getEventPos(e);
      const dx = pos.x - editState.startX;
      const dy = pos.y - editState.startY;
      
      if (editState.dragging && currentEditLayout[editState.dragging]) {
        currentEditLayout[editState.dragging].left = editState.startLeft + dx;
        currentEditLayout[editState.dragging].top = editState.startTop + dy;
        updateEditWrapperPositions();
      }
      
      if (editState.resizing && currentEditLayout[editState.resizing]) {
        const layout = currentEditLayout[editState.resizing];
        const minSize = 40;
        
        switch (editState.corner) {
          case 'se':
            layout.width = Math.max(minSize, editState.startW + dx);
            layout.height = Math.max(minSize, editState.startH + dy);
            break;
          case 'sw':
            const newWidthSW = Math.max(minSize, editState.startW - dx);
            layout.left = editState.startLeft + (editState.startW - newWidthSW);
            layout.width = newWidthSW;
            layout.height = Math.max(minSize, editState.startH + dy);
            break;
          case 'ne':
            layout.width = Math.max(minSize, editState.startW + dx);
            const newHeightNE = Math.max(minSize, editState.startH - dy);
            layout.top = editState.startTop + (editState.startH - newHeightNE);
            layout.height = newHeightNE;
            break;
          case 'nw':
            const newWidthNW = Math.max(minSize, editState.startW - dx);
            const newHeightNW = Math.max(minSize, editState.startH - dy);
            layout.left = editState.startLeft + (editState.startW - newWidthNW);
            layout.top = editState.startTop + (editState.startH - newHeightNW);
            layout.width = newWidthNW;
            layout.height = newHeightNW;
            break;
        }
        
        updateEditWrapperPositions();
      }
    }
    
    function handleEditPointerUp(e) {
      if (editState.dragging) {
        const wrapper = document.getElementById('edit-' + editState.dragging + '-wrapper');
        if (wrapper) wrapper.classList.remove('dragging');
      }
      if (editState.resizing) {
        const wrapper = document.getElementById('edit-' + editState.resizing + '-wrapper');
        if (wrapper) wrapper.classList.remove('resizing');
      }
      
      editState.dragging = null;
      editState.resizing = null;
      editState.corner = null;
    }
    
    // Event listeners for edit controls
    if (btnEditControls) {
      btnEditControls.addEventListener('click', openEditOverlay);
      btnEditControls.addEventListener('touchstart', openEditOverlay, {passive: false});
    }
    
    if (editSaveBtn) {
      editSaveBtn.addEventListener('click', handleEditSave);
      editSaveBtn.addEventListener('touchstart', handleEditSave, {passive: false});
    }
    
    if (editResetBtn) {
      editResetBtn.addEventListener('click', handleEditReset);
      editResetBtn.addEventListener('touchstart', handleEditReset, {passive: false});
    }
    
    if (editCancelBtn) {
      editCancelBtn.addEventListener('click', handleEditCancel);
      editCancelBtn.addEventListener('touchstart', handleEditCancel, {passive: false});
    }
    
    // Edit overlay touch/mouse handlers
    if (buttonEditOverlay) {
      buttonEditOverlay.addEventListener('touchstart', handleEditPointerDown, {passive: false});
      buttonEditOverlay.addEventListener('touchmove', handleEditPointerMove, {passive: false});
      buttonEditOverlay.addEventListener('touchend', handleEditPointerUp, {passive: false});
      buttonEditOverlay.addEventListener('mousedown', handleEditPointerDown);
      buttonEditOverlay.addEventListener('mousemove', handleEditPointerMove);
      buttonEditOverlay.addEventListener('mouseup', handleEditPointerUp);
      buttonEditOverlay.addEventListener('mouseleave', handleEditPointerUp);
    }
    
    // Apply saved layout on game start (exposed globally)
    window.applySavedLayoutOnStart = function() {
      const savedLayout = loadSavedLayout();
      if (savedLayout) {
        // Delay to ensure DOM is ready
        setTimeout(() => {
          applyLayoutToGameButtons(savedLayout);
        }, 100);
      }
    };
    
    // Call on page load
    window.applySavedLayoutOnStart();
    // =====================================================
    // END OF BUTTON LAYOUT EDITOR
    // =====================================================

    // =====================================================
    // NEW AI CONTROL BUTTONS (Futuristic Design)
    // =====================================================
    const assistControlBtn = document.getElementById('assist-control-btn');
    const routeControlBtn = document.getElementById('route-control-btn');
    const assistValueEl = document.getElementById('assist-value');
    const routeValueEl = document.getElementById('route-value');
    
    // Update route button state based on assist state
    const updateRouteButtonState = () => {
      if (aiAssistLevel === 0) {
        // Assist is OFF - disable and turn off route
        showComboRouteVisualization = false;
        routeControlBtn.classList.remove('active', 'inactive');
        routeControlBtn.classList.add('inactive', 'disabled');
        routeValueEl.textContent = 'OFF';
      } else {
        // Assist is ON - enable route button (remove disabled)
        routeControlBtn.classList.remove('disabled');
        if (showComboRouteVisualization) {
          routeControlBtn.classList.remove('inactive');
          routeControlBtn.classList.add('active');
          routeValueEl.textContent = 'ON';
        } else {
          routeControlBtn.classList.remove('active');
          routeControlBtn.classList.add('inactive');
          routeValueEl.textContent = 'OFF';
        }
      }
    };
    
    // New Assist Button Toggle
    const toggleAssistNew = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      
      if (aiAssistLevel === 0) aiAssistLevel = 2;
      else if (aiAssistLevel < 8) aiAssistLevel++;
      else aiAssistLevel = 0;

      if (aiAssistLevel > 0) {
        assistControlBtn.classList.remove('inactive');
        assistControlBtn.classList.add('active');
        assistValueEl.textContent = `${aiAssistLevel}コンボ`;
      } else {
        assistControlBtn.classList.remove('active');
        assistControlBtn.classList.add('inactive');
        assistValueEl.textContent = 'OFF';
      }
      
      // Update route button state (disable if assist is off)
      updateRouteButtonState();
      
      if (playerGame) playerGame.updateHints();
    };
    
    assistControlBtn.addEventListener('click', toggleAssistNew);
    assistControlBtn.addEventListener('touchstart', toggleAssistNew, {passive: false});

    // New Route Button Toggle
    const toggleRouteNew = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      
      // Don't toggle if assist is off (button is disabled)
      if (aiAssistLevel === 0) return;
      
      showComboRouteVisualization = !showComboRouteVisualization;
      updateRouteButtonState();
    };
    
    routeControlBtn.addEventListener('click', toggleRouteNew);
    routeControlBtn.addEventListener('touchstart', toggleRouteNew, {passive: false});

    // Legacy button handlers (keep for compatibility but buttons are hidden)
    const toggleAssist = (e) => {
      if (e.cancelable) e.preventDefault();
      toggleAssistNew(e);
    };
    btnAssist.addEventListener('click', toggleAssist);
    btnAssist.addEventListener('touchstart', toggleAssist, {passive: false});

    // Legacy combo route button
    const btnComboRoute = document.getElementById('combo-route-btn');
    const toggleComboRoute = (e) => {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      toggleRouteNew(e);
    };
    btnComboRoute.addEventListener('click', toggleComboRoute);
    btnComboRoute.addEventListener('touchstart', toggleComboRoute, {passive: false});

    const handleRetry = (e) => {
      if (e.cancelable) e.preventDefault();
      document.getElementById('game-over-modal').style.display = 'none';
      initGame(currentCpuLevel, isDevilMode);
    };
    btnRetry.addEventListener('click', handleRetry);
    btnRetry.addEventListener('touchstart', handleRetry, {passive: false});

    const handleHome = (e) => {
      if (e.cancelable) e.preventDefault();
      audio.pauseBGM();
      audio.playTitleBGM();
      document.getElementById('mode-select-screen').style.display = 'flex';
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('ui-layer').style.display = 'none';
      document.getElementById('game-over-modal').style.display = 'none';
      gameState = 'TITLE';
      // Reinitialize HEXA logo effects
      initHexaLogoEffects();
    };
    btnHome.addEventListener('click', handleHome);
    btnHome.addEventListener('touchstart', handleHome, {passive: false});
    
    const handleResultSkip = (e) => {
      if (e.target === btnRetry || e.target === btnHome) return;
      if (gameState === 'GAMEOVER' && !isResultAnimationSkipped) {
        if (Date.now() - gameOverTimestamp > 1000) {
          if (e.cancelable) e.preventDefault();
          e.stopPropagation();
          isResultAnimationSkipped = true;
          resultAnimationTimeouts.forEach(clearTimeout);
          resultAnimationTimeouts = [];
          analyzePlayStyle(playerGame);
        }
      }
    };
    const gameOverModal = document.getElementById('game-over-modal');
    gameOverModal.addEventListener('click', handleResultSkip);
    gameOverModal.addEventListener('touchstart', handleResultSkip, {passive: false});

    // Keyboard Controls
    document.addEventListener('keydown', (e) => {
      if (gameState !== 'PLAYING' || isPaused || playerGame.state !== 'PLAYING' || isReviving) return;

      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      switch(e.key) {
        case 'ArrowLeft':
          if (!inputState.left) {
            inputState.left = true;
            if (inputTimers.left === 0) {
              playerGame.movePiece(-1, 0);
              inputTimers.left = 1;
            }
          }
          break;
        case 'ArrowRight':
          if (!inputState.right) {
            inputState.right = true;
            if (inputTimers.right === 0) {
              playerGame.movePiece(1, 0);
              inputTimers.right = 1;
            }
          }
          break;
        case 'ArrowUp':
          if (!e.repeat) playerGame.rotatePiece();
          break;
        case 'ArrowDown':
          if (!e.repeat) playerGame.hardDrop();
          break;
        case ' ':
        case 'Enter':
          if (!e.repeat) btnItem.dispatchEvent(new Event('mousedown'));
          break;
        case 'Shift':
          if (!e.repeat) playerGame.swapItems();
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') {
        inputState.left = false;
        inputTimers.left = 0;
      } else if (e.key === 'ArrowRight') {
        inputState.right = false;
        inputTimers.right = 0;
      }
    });
  }
};

new p5(sketch);

const tutorialSketch = (p) => {
  let grid = [];
  const cols = 5;
  const rows = 5;
  const cellSize = 30;
  let images = [];
  let state = 0; // 0:Init, 1:Drop, 2:Wait1, 3:Match1, 4:Wait2, 5:Match2, 6:Wait3, 7:Match3, 8:Reset, 9/10/11:GravityAnim
  let timer = 0;
  let dropY = 0;
  let removing = [];
  let fallingBlocks = []; // [Top, Mid, Bot]
  let lastRemoved = []; // 消えた場所を記録
  let showRemovedOutline = false; // 点線枠表示フラグ
  let outlineTimer = 0; // 点線枠表示タイマー
  
  // 落下アニメーション用
  let fallingCells = []; // {x, y, targetY, color, currentY} 落下中のブロック
  let gravityAnimSpeed = 0.2; // 落下速度
  
  // Colors
  const colorA = 2; // Red
  const colorB = 3; // Green
  const colorC = 4; // Blue

  p.preload = function() {
    for(let i=1; i<=6; i++) images[i] = p.loadImage(GEM_URLS[i]);
  };

  p.setup = function() {
    let canvas = p.createCanvas(150, 150);
    canvas.parent('tutorial-preview-container');
    p.noLoop();
    resetDemo();
  };

  function resetDemo() {
    grid = Array(cols).fill().map(() => Array(rows).fill(0));
    
    // Setup Board for 3-Chain Combo
    // Vertical Match Setup (A)
    grid[2][3] = colorA; 
    grid[2][4] = colorA;
    
    // Horizontal Match Setup (B)
    grid[1][4] = colorB;
    grid[3][4] = colorB;
    
    // Diagonal Match Setup (C)
    grid[0][2] = colorC;
    grid[1][3] = colorA; // Filler
    grid[1][2] = colorC; // Target
    
    // Background blocks
    grid[0][4] = 1; grid[4][4] = 1;
    grid[0][3] = 5; grid[4][3] = 6;
    
    // Falling Piece: [C, B, A]
    fallingBlocks = [colorC, colorB, colorA];
    
    state = 1; // Drop
    dropY = -3;
    timer = 0;
    removing = [];
    lastRemoved = [];
    showRemovedOutline = false;
    outlineTimer = 0;
    fallingCells = [];
  }
  
  function applyGravity() {
    for(let x=0; x<cols; x++) {
      let writeY = rows - 1;
      for(let y=rows-1; y>=0; y--) {
        if(grid[x][y] !== 0) {
          grid[x][writeY] = grid[x][y];
          if(writeY !== y) grid[x][y] = 0;
          writeY--;
        }
      }
    }
  }
  
  // 落下アニメーションを開始する準備
  function prepareGravityAnim() {
    fallingCells = [];
    for(let x=0; x<cols; x++) {
      let writeY = rows - 1;
      for(let y=rows-1; y>=0; y--) {
        if(grid[x][y] !== 0) {
          if(writeY !== y) {
            // このブロックは落下する
            fallingCells.push({
              x: x,
              y: y,
              targetY: writeY,
              color: grid[x][y],
              currentY: y
            });
          }
          writeY--;
        }
      }
    }
    // 落下するブロックをグリッドから消去（アニメーション中はdrawFallingCellsで描画）
    fallingCells.forEach(cell => {
      grid[cell.x][cell.y] = 0;
    });
  }
  
  // 落下アニメーションを適用（グリッドを更新）
  function finishGravityAnim() {
    // 落下するブロックを元の位置から削除
    fallingCells.forEach(cell => {
      grid[cell.x][cell.y] = 0;
    });
    // 落下先に配置
    fallingCells.forEach(cell => {
      grid[cell.x][cell.targetY] = cell.color;
    });
    fallingCells = [];
  }
  
  // 落下中のブロックを描画
  function drawFallingCells() {
    fallingCells.forEach(cell => {
      let img = images[cell.color];
      if (img) p.image(img, cell.x*cellSize, cell.currentY*cellSize, cellSize, cellSize);
    });
  }
  
  // 落下アニメーションを進める（完了したらtrue）
  function updateGravityAnim() {
    let allDone = true;
    fallingCells.forEach(cell => {
      if(cell.currentY < cell.targetY) {
        cell.currentY += gravityAnimSpeed;
        if(cell.currentY >= cell.targetY) {
          cell.currentY = cell.targetY;
        } else {
          allDone = false;
        }
      }
    });
    return allDone;
  }

  p.draw = function() {
    p.background(0, 20, 40);
    p.stroke(0, 100, 200);
    p.noFill();
    p.rect(0, 0, 149, 149);

    // Draw Grid
    for(let x=0; x<cols; x++) {
      for(let y=0; y<rows; y++) {
        if (grid[x][y] > 0) {
          let img = images[grid[x][y]];
          if (img) p.image(img, x*cellSize, y*cellSize, cellSize, cellSize);
        }
      }
    }

    // Logic
    if (state === 1) { // Drop
      dropY += 0.15;
      
      // Draw falling blocks
      for(let i=0; i<3; i++) {
        let img = images[fallingBlocks[i]];
        if (img) p.image(img, 2*cellSize, (dropY + i)*cellSize, cellSize, cellSize);
      }
      
      // Land check
      if (dropY >= 0) {
        grid[2][0] = fallingBlocks[0]; // C
        grid[2][1] = fallingBlocks[1]; // B
        grid[2][2] = fallingBlocks[2]; // A
        state = 2; timer = 0;
      }
    } 
    else if (state === 2) { // Wait before Match 1
      timer++;
      if (timer > 10) {
        state = 3; timer = 0;
        // Vertical Match A
        removing = [{x:2,y:2}, {x:2,y:3}, {x:2,y:4}];
      }
    }
    else if (state === 3) { // Match 1 Animation
      timer++;
      drawFlash();
      if (timer > 40) {
        lastRemoved = removing.slice();
        showRemovedOutline = true;
        outlineTimer = 0;
        removeBlocks();
        // applyGravity()は後で実行
        state = 4; timer = 0;
      }
    }
    else if (state === 4) { // 点線表示
      timer++;
      drawRemovedOutline();
      if (timer > 20) {
        showRemovedOutline = false;
        // 落下アニメーション準備
        prepareGravityAnim();
        state = 9; timer = 0; // 落下アニメーションへ
      }
    }
    else if (state === 9) { // 落下アニメーション (Match 1後)
      drawFallingCells();
      if(updateGravityAnim()) {
        finishGravityAnim();
        state = 5; timer = 0;
        // Horizontal Match B (B fell to 2,4)
        removing = [{x:1,y:4}, {x:2,y:4}, {x:3,y:4}];
      }
    }
    else if (state === 5) { // Match 2 Animation
      timer++;
      drawFlash();
      if (timer > 40) {
        lastRemoved = removing.slice();
        showRemovedOutline = true;
        outlineTimer = 0;
        removeBlocks();
        state = 6; timer = 0;
      }
    }
    else if (state === 6) { // 点線表示 (Match 2後)
      timer++;
      drawRemovedOutline();
      if (timer > 20) {
        showRemovedOutline = false;
        prepareGravityAnim();
        state = 10; timer = 0; // 落下アニメーションへ
      }
    }
    else if (state === 10) { // 落下アニメーション (Match 2後)
      drawFallingCells();
      if(updateGravityAnim()) {
        finishGravityAnim();
        state = 7; timer = 0;
        // Diagonal Match C (C fell to 2,4)
        removing = [{x:0,y:2}, {x:1,y:3}, {x:2,y:4}];
      }
    }
    else if (state === 7) { // Match 3 Animation
      timer++;
      drawFlash();
      if (timer > 40) {
        lastRemoved = removing.slice();
        showRemovedOutline = true;
        outlineTimer = 0;
        removeBlocks();
        state = 8; timer = 0;
      }
    }
    else if (state === 8) { // 点線表示 (Match 3後)
      timer++;
      drawRemovedOutline();
      if (timer > 20) {
        showRemovedOutline = false;
        prepareGravityAnim();
        state = 11; timer = 0; // 落下アニメーションへ
      }
    }
    else if (state === 11) { // 落下アニメーション (Match 3後)
      drawFallingCells();
      if(updateGravityAnim()) {
        finishGravityAnim();
        state = 12; timer = 0; // Reset Waitへ
      }
    }
    else if (state === 12) { // Reset Wait
      timer++;
      if (timer > 40) {
        resetDemo();
      }
    }
  };
  
  function drawFlash() {
    if (timer % 10 < 5) {
      p.noStroke(); p.fill(255, 255, 255, 150);
      removing.forEach(b => p.rect(b.x*cellSize, b.y*cellSize, cellSize, cellSize));
    }
  }
  
  function drawRemovedOutline() {
    if (showRemovedOutline && lastRemoved.length > 0) {
      outlineTimer++;
      p.noFill();
      p.strokeWeight(2);
      // 点線アニメーション効果
      let dashOffset = Math.floor(outlineTimer / 2) % 8;
      p.drawingContext.setLineDash([4, 4]);
      p.drawingContext.lineDashOffset = -dashOffset;
      // 点滅色
      let alpha = 150 + Math.sin(outlineTimer * 0.3) * 100;
      p.stroke(0, 255, 255, alpha);
      lastRemoved.forEach(b => {
        p.rect(b.x*cellSize + 2, b.y*cellSize + 2, cellSize - 4, cellSize - 4);
      });
      p.drawingContext.setLineDash([]);
      p.strokeWeight(1);
    }
  }
  
  function removeBlocks() {
    removing.forEach(b => grid[b.x][b.y] = 0);
    removing = [];
  }
};
window.tutorialP5 = new p5(tutorialSketch);

</script>
</body>
</html>